import time, os, io, datetime, sys, psutil, random, statistics, requests, re, json, math, subprocess, telepot, time
import urllib3

from  datetime import datetime, timedelta
import traceback

piFolder = "/home/pi/zack/"
if not os.path.isdir(piFolder):
    piFolder = "C:\\Users\\zcapo\\Documents\\workspace"
    if not os.path.isdir(piFolder):
        piFolder = "C:\\Users\\zcapozzi002\\Documents\\workspace"

zc_fldr = os.path.join(piFolder,"ZackInc")
lr_fldr = os.path.join(piFolder,"LacrosseReference")
sys.path.insert(0, zc_fldr)
import zack_inc_lite as zc

from zack_inc_lite import print_dict as pd
#import MySQLdb

from zack_inc_lite import mysql_connect

from math import log as ln

bot_token = json.loads(open(os.path.join(lr_fldr, "LRP", "client_secrets.json"), 'r').read())['local']['bot_token']
image_bot_token = json.loads(open(os.path.join(lr_fldr, "LRP", "client_secrets.json"), 'r').read())['local']['image_bot_token']

def write_game_JSON(json_data, specs):
    """
    This function is used to write a game JSON object to a file after compressing it down to avoid size issues
    """
    
def scan_ncaa_schedule_page(t, specs={}):
    """
    This function scans the NCAA schedule page for a specified team and returns an object that contains the relevant information from that page (i.e. Head Coach)
    """
    err = None
    res = {}
    
    if 'regexes' not in specs:
        specs['hc_regexes'] = []
        specs['hc_regexes'].append({'regex': re.compile(r'<legend>Head Coach</legend>[\s\r\n]*?<label[^>]*?>Name:\s*?</label>\s*?<a href=\"/people[^>]*?>\s*?([a-z\s\-\.\'\(\)]+)?</a>', re.IGNORECASE), 'match_group': 1, 'single': 1})
        
        specs['record_regexes'] = []
        specs['record_regexes'].append({'regex': re.compile(r'<legend>(?:<img[^>]+?>)?\s<a[^>]+?>.*?</a>\s*?\(\s*?([0-9\-\s]+?)\s*?\)', re.IGNORECASE), 'match_group': 1, 'single': 1})
        specs['record_regexes'].append({'regex': re.compile(r'<legend>(?:<img[^>]+?>)?\s.*?\s*?\(\s*?([0-9\-\s]+?)\s*?\)', re.IGNORECASE), 'match_group': 1, 'single': 1})
        
    try:
        user_agent = {'user-agent': 'Mozilla/5.0 (Windows NT 6.3; rv:36.1) ..'}
        http = urllib3.PoolManager(10, headers=user_agent);
        if '-u' not in sys.argv and '-test' not in sys.argv: time.sleep(3)


        #print ("Read data from %s" % t['ncaa_schedule_url'])
        r = http.request('GET', t['ncaa_schedule_url'])
        tmp_data = r.data
        if isinstance(tmp_data, bytes):
            tmp_data = tmp_data.decode("utf8")
        tmp_data = tmp_data.replace("&#39;", "'")
        
        for j, regex in enumerate(specs['hc_regexes']):
            if regex['single']:
                matches = list(set([z for z in re.findall(regex['regex'], tmp_data)]))
                if len(matches) == 1:
                    res['head_coach'] = matches[0]
                    break
        for j, regex in enumerate(specs['record_regexes']):
            if regex['single']:
                matches = list(set([z for z in re.findall(regex['regex'], tmp_data)]))
                if len(matches) == 1:
                    res['record'] = matches[0].replace(" ", "")
                    break
        if 'head_coach' not in res:
            err = {'traceback': None, 'missing_field': 'coach', 'msg': "CoachRegexesDidNotMatch"}
        elif 'record' not in res:
            err = {'traceback': None, 'missing_field': 'record', 'msg': "RecordRegexesDidNotMatch"}
    except Exception:
        err = {'traceback': traceback.format_exc(), 'msg': None}
    
    
    return err, t, res
    
def read_game_JSON(specs):
    """
    This function is used to read a game JSON object from a file and uncompress it if needed
    """
    
    return json_data

def game_to_game_file(g):
    clean_home = g['display_home_team'].lower().replace(' ', '_').replace("'", '').replace('-', '').replace('(', '').replace(')', '').replace('&', 'and')
    clean_away = g['display_away_team'].lower().replace(' ', '_').replace("'", '').replace('-', '').replace('(', '').replace(')', '').replace('&', 'and')
    if clean_home < clean_away:

        return "%s_%d_%s_%d_%s" % (clean_home, g['home_ID'], clean_away, g['away_ID'], g['game_date'].strftime("%Y%m%d"))
    else:

        return "%s_%d_%s_%d_%s" % (clean_away, g['away_ID'], clean_home, g['home_ID'], g['game_date'].strftime("%Y%m%d"))

def load_bracketology_results(t, selection_criteria, year=datetime.now().year):
    timestamps = []; ts = time.time()
    t['res'] = {}
    selection_criterias = ['_by_RPI']#, '_by_SOR']
    selection_criterias = [selection_criteria]

    for selection_criteria in selection_criterias:
        fname = os.path.join(lr_fldr, "Post_021", "SimResults", "team%04d_%d%s" % (t['ID'], year, selection_criteria))
        #print fname
        if os.path.isfile(fname):
        
            txt = open(fname, 'r').read()

            timestamps.append({'tag': 'Data read', 'elapsed': time.time() - ts}); ts = time.time()
            final_odds_regex = re.compile(r'[\n\s](.*?) is selected in ([0-9.]+)% of the simulations.\s*\n\s*they are projected to win their conference in ([0-9.]+)% of the simulations.\s*\n\s*they are projected to be seeded in ([0-9.]+)% of the simulations.', re.IGNORECASE)
            match = final_odds_regex.search(txt)
            t['selected_odds'] = None; t['champ_odds'] = None; t['seeded_odds'] = None
            if match:
                t['selected_odds'] = float(match.group(2))/100.
                t['champ_odds'] = float(match.group(3))/100.
                t['seeded_odds'] = float(match.group(4))/100.
                t['at_large_odds'] = t['selected_odds'] - t['champ_odds']
                t['selected_odds_str'] = "%.1f" % (100. * t['selected_odds']) if t['selected_odds'] > 0. else "---"
                t['champ_odds_str'] = "%.1f" % (100. * t['champ_odds']) if t['champ_odds'] > 0. else "---"
                t['seeded_odds_str'] = "%.1f" % (100. * t['seeded_odds']) if t['seeded_odds'] > 0. else "---"
                t['at_large_odds_str'] = "%.1f" % (100. * t['at_large_odds']) if t['at_large_odds'] > 0. else "---"
            timestamps.append({'tag': 'Final Odds Regex', 'elapsed': time.time() - ts}); ts = time.time()

            sim_run_regex = re.compile(r'Simulation as of (.+)\n?', re.IGNORECASE)
            t['res']['timestamp'] = datetime.now()
            match = sim_run_regex.search(txt)
            if match:

                t['timestamp'] = datetime.strptime("%d %s" % (datetime.now().year, match.group(1)), "%Y %b %d %I:%M %p")
            else:
                zc.send_telegram("Could not identify the time stamp from the file")
            timestamps.append({'tag': 'Timestamp regex', 'elapsed': time.time() - ts}); ts = time.time()
            num_sims_regex = re.compile(r'Number of simulations run: ([0-9]+)', re.IGNORECASE)
            t['res']['num_sims'] = None
            match = num_sims_regex.search(txt)
            if match:
                t['res']['num_sims'] = int(match.group(1))
            timestamps.append({'tag': 'Number of Sims Regex', 'elapsed': time.time() - ts}); ts = time.time()

            RPI_regex = re.compile(r'avg final RPI rank: ([0-9\.]+)\.', re.IGNORECASE)
            t['avg_RPI_rank'] = None
            match = RPI_regex.search(txt)
            if match:
                t['avg_RPI_rank'] = float(match.group(1))
                t['avg_RPI_rank_str'] = "%.1f" % t['avg_RPI_rank']
            timestamps.append({'tag': 'RPI Regex', 'elapsed': time.time() - ts}); ts = time.time()

            best_SOR_regex = re.compile(r'best SOR when left out: ([0-9\.]+)\.', re.IGNORECASE)
            t['best_SOR_left_out_str'] = None
            match = best_SOR_regex.search(txt)
            if match:
                t['best_SOR_left_out_str'] = "%d" % int(match.group(1))
            timestamps.append({'tag': 'Best SOR Regex', 'elapsed': time.time() - ts}); ts = time.time()

            seeds_regex = re.compile(r'seed probabilities: \[(.*?)\]', re.IGNORECASE)
            t['seed_probabilities'] = None
            match = seeds_regex.search(txt)
            if match:
                t['seed_probabilities'] = [{'seed': i, 'seed_str': i+1, 'probability': float(z.strip()), 'probability_str': "%.1f%%" % (100. * float(z.strip()))} for i, z in enumerate(match.group(1).split(","))]
            timestamps.append({'tag': 'SOR Regex', 'elapsed': time.time() - ts}); ts = time.time()



            SOR_regex = re.compile(r'avg final SOR rank: ([0-9\.]+)\.', re.IGNORECASE)
            t['avg_SOR_rank'] = None
            match = SOR_regex.search(txt)
            if match:
                t['avg_SOR_rank'] = float(match.group(1))
                t['avg_SOR_rank_str'] = "%.1f" % t['avg_SOR_rank']
            timestamps.append({'tag': 'SOR Regex', 'elapsed': time.time() - ts}); ts = time.time()

            SOS_regex = re.compile(r'avg final SOS rank: ([0-9\.]+)\.', re.IGNORECASE)
            t['avg_SOS_rank'] = None
            match = SOS_regex.search(txt)
            if match:
                t['avg_SOS_rank'] = float(match.group(1))
                t['avg_SOS_rank_str'] = "%.1f" % t['avg_SOS_rank']
            timestamps.append({'tag': 'SOS Regex', 'elapsed': time.time() - ts}); ts = time.time()

            LaxELO_regex = re.compile(r'avg final LaxELO: ([0-9\.]+)\.', re.IGNORECASE)
            t['avg_LaxELO'] = None
            match = LaxELO_regex.search(txt)
            if match:
                t['avg_LaxELO'] = float(match.group(1))
                t['avg_LaxELO_str'] = "%.1f" % t['avg_LaxELO']
            timestamps.append({'tag': 'LaxELO Regex', 'elapsed': time.time() - ts}); ts = time.time()

            LaxELO_rank_regex = re.compile(r'avg final LaxELO rank: ([0-9\.]+)\.', re.IGNORECASE)
            t['avg_LaxELO_rank'] = None
            match = LaxELO_rank_regex.search(txt)
            if match:
                t['avg_LaxELO_rank'] = float(match.group(1))
                t['avg_LaxELO_rank_str'] = "%.1f" % t['avg_LaxELO_rank']
            timestamps.append({'tag': 'LaxELO Rank Regex', 'elapsed': time.time() - ts}); ts = time.time()

            record_regex = re.compile(r'avg final record: ([0-9\.\s\-]+)\.', re.IGNORECASE)
            t['avg_record_str'] = None
            match = record_regex.search(txt)
            if match:
                t['avg_record_str'] = match.group(1)
            timestamps.append({'tag': 'Avg Record Regex', 'elapsed': time.time() - ts}); ts = time.time()

            txt_trunc = txt
            while "  " in txt_trunc:
                txt_trunc = txt_trunc.replace("  ", " ")

            #print txt_trunc


            game_regex = re.compile('\n([a-z][a-z\s\'-\.]+?)\s([0-9]+)\s([0-9\-]+)\s([a-z\-\s]+)\s([0-9\-]+\s\([0-9]+\%\))\s([0-9\.]+)\%\s([0-9\.]+)\%\s([0-9\.]+)\%\s([0-9\.]+)\%\s([0-9\.]+)\%\s([0-9\.]+)\%\s([0-9\.]+)\%\s([0-9\.]+)\%\s([0-9\.]+)\%', re.IGNORECASE)
            recs = re.findall(game_regex, txt_trunc)
            t['specific_games'] = []
            for rec in recs:
                if "\n" not in rec[0]:

                    g = {'team_ID': t['ID'], 'team': t['name'], 'display_name': t['display_name']}
                    g['opponent'] = rec[0]
                    g['opponentID'] = int(rec[1]) if rec[1] != "na" else None

                    g['date_str'] = rec[2]
                    g['date_val'] = datetime.strptime(g['date_str'], "%Y-%m-%d")
                    g['game_type'] = rec[3]
                    g['simulation_record'] = rec[4]
                    g['in_with_win'] = float(rec[5])/100.
                    g['in_with_loss'] = float(rec[6])/100.
                    g['diff'] = float(rec[7])/100.
                    g['champ_with_win'] = float(rec[8])/100.
                    g['champ_with_loss'] = float(rec[9])/100.
                    g['at_large_with_win'] = float(rec[10])/100.
                    g['at_large_with_loss'] = float(rec[11])/100.
                    g['seeded_with_win'] = float(rec[12])/100.
                    g['seeded_with_loss'] = float(rec[13])/100.

                    g['in_with_win_str'] = "%.1f%%" % (100. * g['in_with_win'])
                    g['in_with_loss_str'] = "%.1f%%" % (100. * g['in_with_loss'])
                    g['champ_with_win_str'] = "%.1f%%" % (100. * g['champ_with_win'])
                    g['champ_with_loss_str'] = "%.1f%%" % (100. * g['champ_with_loss'])
                    g['at_large_with_win_str'] = "%.1f%%" % (100. * g['at_large_with_win'])
                    g['at_large_with_loss_str'] = "%.1f%%" % (100. * g['at_large_with_loss'])
                    g['seeded_with_win_str'] = "%.1f%%" % (100. * g['seeded_with_win'])
                    g['seeded_with_loss_str'] = "%.1f%%" % (100. * g['seeded_with_loss'])

                    g['diff_str'] = "%.1f%%" % (100. * g['diff'])


                    t['specific_games'].append(g)
            timestamps.append({'tag': 'Specific games regex', 'elapsed': time.time() - ts}); ts = time.time()

            regex = re.compile(r'([0-9]+)-([0-9]+)\s+([0-9\.]+)\s+([0-9\.]+\%?)\s+([0-9\.]+\%?)\n', re.IGNORECASE)
            t['records'] = []
            matches = re.findall(regex, txt_trunc)
            for m in matches:
                rec = {'wins': float(m[0]), 'losses': float(m[1]), 'times_seen': float(m[2]), 'frequency_str': (m[3]), 'pct_in_str': m[4]}
                rec['times_seen_str'] = "{:,}".format(int(rec['times_seen']))
                rec['frequency'] = float(rec['frequency_str'].replace("%", "").strip())
                rec['pct_in'] = float(rec['pct_in_str'].replace("%", "").strip())/100.
                rec['remaining_record_str'] = "%d-%d" % (rec['wins'], rec['losses'])
                if (rec['wins'] + rec['losses']) > 0:
                    rec['remaining_winning_pct'] = rec['wins']/(rec['wins'] + rec['losses'])
                    rec['remaining_winning_pct_str'] = "{:.3f}".format(rec['remaining_winning_pct'])
                else:
                    rec['remaining_winning_pct'] = None
                    rec['remaining_winning_pct_str'] = "---"
                t['records'].append(rec)

            regex = re.compile(r'([0-9]+) losses\s+([0-9\.,]+)\s+([0-9\.]+\%?)\s+([0-9\.]+\%?)\n', re.IGNORECASE)
            t['future_losses'] = []
            matches = re.findall(regex, txt_trunc)
            for m in matches:
                rec = {'losses': int(m[0]), 'times_seen': float(m[1].replace(",","")), 'frequency_str': (m[2]), 'pct_in_str': m[3]}
                rec['times_seen_str'] = "{:,}".format(int(rec['times_seen']))
                rec['frequency'] = float(rec['frequency_str'].replace("%", "").strip())
                rec['pct_in'] = float(rec['pct_in_str'].replace("%", "").strip())/100.
                t['future_losses'].append(rec)
            t['future_losses'] = sorted(t['future_losses'], key=lambda x:x['losses'])

            regex = re.compile(r'([0-9]+) wins\s+([0-9\.,]+)\s+([0-9\.]+\%?)\s+([0-9\.]+\%?)\n', re.IGNORECASE)
            t['future_wins'] = []
            matches = re.findall(regex, txt_trunc)
            for m in matches:
                rec = {'wins': int(m[0]), 'times_seen': float(m[1].replace(",","")), 'frequency_str': (m[2]), 'pct_in_str': m[3]}
                rec['times_seen_str'] = "{:,}".format(int(rec['times_seen']))
                rec['frequency'] = float(rec['frequency_str'].replace("%", "").strip())
                rec['pct_in'] = float(rec['pct_in_str'].replace("%", "").strip())/100.
                t['future_wins'].append(rec)
            t['future_wins'] = sorted(t['future_wins'], key=lambda x:x['wins'], reverse=True)

            regex = re.compile('Most critical games/descs for .*?\n.*?\n\-+(\n[\s\S]+?)\nTotal', re.IGNORECASE)
            grab_text_match = regex.search(txt_trunc)
            t['games'] = []
            if grab_text_match:
                local_txt = grab_text_match.group(1).replace("+", "")
                game_regex = re.compile('\n(.*?)\s*([0-9]+)\s*([0-9\-\s%\(\)]+)\s([0-9.]+)%\s([0-9.]+)%\s([0-9.]+)%\s([0-9.]+)%\s([0-9.]+)%\s([0-9.]+)%\s([0-9.]+)%\s([0-9.]+)%\s([0-9.]+)%', re.IGNORECASE)
                recs = re.findall(game_regex, local_txt)
                #print local_txt

                for rec in recs:
                    g = {'ID': t['ID'], 'team': t['name'], 'display_name': t['display_name']}
                    g['opponent'] = rec[0];
                    g['opponentID'] = int(rec[1]) if rec[1] != "na" else None
                    g['record'] = rec[2]
                    g['in_with_win'] = float(rec[3])/100.
                    g['in_with_loss'] = float(rec[4])/100.
                    g['diff'] = g['in_with_win'] - g['in_with_loss']
                    g['in_with_win_str'] = "%.1f%%" % (100. * g['in_with_win'])
                    g['in_with_loss_str'] = "%.1f%%" % (100. * g['in_with_loss'])
                    g['diff_str'] = "%.1f%%" % (100. * g['diff'])

                    g['champ_with_win'] = float(rec[6])/100.
                    g['champ_with_loss'] = float(rec[7])/100.
                    g['at_large_with_win'] = float(rec[8])/100.
                    g['at_large_with_loss'] = float(rec[9])/100.
                    g['seeded_with_win'] = float(rec[10])/100.
                    g['seeded_with_loss'] = float(rec[11])/100.
                    g['at_large_with_win_str'] = "%.1f%%" % (100. * g['at_large_with_win'])
                    g['at_large_with_loss_str'] = "%.1f%%" % (100. * g['at_large_with_loss'])
                    g['seeded_with_win_str'] = "%.1f%%" % (100. * g['seeded_with_win'])
                    g['seeded_with_loss_str'] = "%.1f%%" % (100. * g['seeded_with_loss'])


                    t['games'].append(g)
                    t['db_games'].append(g)


            timestamps.append({'tag': 'All games regex', 'elapsed': time.time() - ts}); ts = time.time()


            t['at_large_knock_ons'] = []
            regex = re.compile('At\-Large vs Out Knock\-on\n.*?\n\-+\n([\s\S]+?)\n\n', re.IGNORECASE)
            row_regex = re.compile(r'(.*?)\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%(?:$|\n)', re.IGNORECASE)
            grab_text_match = regex.search(txt_trunc)
            if grab_text_match:
                local_txt = grab_text_match.group(1).replace("+", "")
                matches = re.findall(row_regex, local_txt)
                for m in matches:
                    d = {'display_name': m[0]}
                    d['in_diff'] = float(m[1])/100.
                    d['at_large_diff'] = float(m[2])/100.
                    d['seeded_diff'] = float(m[3])/100.
                    d['out_diff'] = float(m[4])/100.
                    d['champ_diff'] = float(m[5])/100.

                    d['in_diff_str'] = m[1]
                    d['at_large_diff_str'] = m[2]
                    d['seeded_diff_str'] = m[3]
                    d['out_diff_str'] = m[4]
                    d['champ_diff_str'] = m[5]
                    t['at_large_knock_ons'].append(d)
                t['at_large_knock_ons'] = sorted(t['at_large_knock_ons'], key=lambda x:x['in_diff'], reverse=True)
            timestamps.append({'tag': 'At-Large Knock-on regex', 'elapsed': time.time() - ts}); ts = time.time()

            t['in_knock_ons'] = []
            regex = re.compile('In vs Out Knock\-on\n.*?\n\-+\n([\s\S]+?)\n\n', re.IGNORECASE)
            row_regex = re.compile(r'(.*?)\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%(?:$|\n)', re.IGNORECASE)
            grab_text_match = regex.search(txt_trunc)
            if grab_text_match:
                local_txt = grab_text_match.group(1).replace("+", "")
                matches = re.findall(row_regex, local_txt)
                for m in matches:
                    d = {'display_name': m[0]}
                    d['in_diff'] = float(m[1])/100.
                    d['at_large_diff'] = float(m[2])/100.
                    d['seeded_diff'] = float(m[3])/100.
                    d['out_diff'] = float(m[4])/100.
                    d['champ_diff'] = float(m[5])/100.

                    d['in_diff_str'] = m[1]
                    d['at_large_diff_str'] = m[2]
                    d['seeded_diff_str'] = m[3]
                    d['out_diff_str'] = m[4]
                    d['champ_diff_str'] = m[5]
                    t['in_knock_ons'].append(d)
                t['in_knock_ons'] = sorted(t['in_knock_ons'], key=lambda x:x['in_diff'], reverse=True)
            t['conf_knock_ons'] = []
            regex = re.compile('Win Conf vs Out Knock\-on\n.*?\n\-+\n([\s\S]+?)\n\n', re.IGNORECASE)
            row_regex = re.compile(r'(.*?)\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%\s*([\-0-9.]+)%(?:$|\n)', re.IGNORECASE)
            grab_text_match = regex.search(txt_trunc)
            if grab_text_match:
                local_txt = grab_text_match.group(1).replace("+", "")
                matches = re.findall(row_regex, local_txt)
                for m in matches:
                    d = {'display_name': m[0]}
                    d['in_diff'] = float(m[1])/100.
                    d['at_large_diff'] = float(m[2])/100.
                    d['seeded_diff'] = float(m[3])/100.
                    d['out_diff'] = float(m[4])/100.
                    d['champ_diff'] = float(m[5])/100.

                    d['in_diff_str'] = m[1]
                    d['at_large_diff_str'] = m[2]
                    d['seeded_diff_str'] = m[3]
                    d['out_diff_str'] = m[4]
                    d['champ_diff_str'] = m[5]
                    t['conf_knock_ons'].append(d)
                t['conf_knock_ons'] = sorted(t['conf_knock_ons'], key=lambda x:x['in_diff'], reverse=True)
            timestamps.append({'tag': 'In Knock-on regex', 'elapsed': time.time() - ts}); ts = time.time()
        else:
            print ("File not found: %s" % (fname))
    #for ts in timestamps:
    #    print ("{:<40}{:>8}".format(ts['tag'], "%.3fs" % ts['elapsed']))

    return t

def build_fogo_splits(fogo, specs):

    fogo['career_json'] = None; fogo['season_json'] = None;
    fogo['career_json_path'] = os.path.join(lr_fldr, "Logs",  'faceoffs_analysis', 'FOGO_career%07d' % fogo['player_ID'])
    fogo['season_json_path'] = os.path.join(lr_fldr, "Logs",  'faceoffs_analysis', 'FOGO_season%07d_%04d' % (fogo['player_ID'], specs['year']))
    if os.path.isfile(fogo['career_json_path']):
        fogo['career_json'] = json.loads(open(fogo['career_json_path'], 'r').read())
    if os.path.isfile(fogo['season_json_path']):
        fogo['season_json'] = json.loads(open(fogo['season_json_path'], 'r').read())
    for tmp in ['career', 'season']:
        if fogo['%s_json' % tmp] is not None and 'total_faceoffs' in fogo['%s_json' % tmp]:
            fogo['%s_total_faceoffs' % tmp] = fogo['%s_json' % tmp]['total_faceoffs']
            fogo['%s_wins' % tmp] = fogo['%s_json' % tmp]['wins']
            fogo['%s_win_pct' % tmp] = fogo['%s_json' % tmp]['win_pct']
            fogo['%s_losses' % tmp] = fogo['%s_json' % tmp]['losses']



            tmp_suffixes = ['', "_by_primary_fogo", "_by_secondary_fogo"]

            r = {}

            for tmp_suffix in tmp_suffixes:
                r['n%s' % (tmp_suffix)] = sum([z['total'] for z in fogo['%s_json' % (tmp)]['seq_bucket%s' % (tmp_suffix)]])
                wins = sum([z['wins'] for z in fogo['%s_json' % (tmp)]['seq_bucket%s' % (tmp_suffix)]])
                losses = r['n%s' % (tmp_suffix)] - wins
                r['record%s' % (tmp_suffix)] = "%d - %d" % (wins, losses)
                r['pct%s' % (tmp_suffix)] = None if r['n%s' % (tmp_suffix)]  == 0 else (wins/r['n%s' % (tmp_suffix)])


                r['seq_bucket%s' % (tmp_suffix)] = {'x_label': "# of FOs taken in game", 'header': 'Win Rate by Faceoff Sequence', 'points': [{'x': z['seq_bucket'], 'y': z['win_rate'], 'label': "%d - %d" % (1 + 4*z['seq_bucket'], 4*(z['seq_bucket'] + 1))} for z in sorted(fogo['%s_json' % (tmp)]['seq_bucket%s' % (tmp_suffix)], key=lambda x:x['seq_bucket'])]}

                r['quarter_index%s' % (tmp_suffix)] = {'x_label': "Game Quarter", 'header': 'Win Rate by Quarter', 'points': [{'x': z['quarter_index'], 'y': z['win_rate'], 'label': "Q%d" % (z['quarter_index'] + 1)} for z in sorted(fogo['%s_json' % (tmp)]['quarter_index%s' % (tmp_suffix)], key=lambda x:x['quarter_index'])]}
                r['quarter_index%s' % (tmp_suffix)]['points'][-1]['label'] = "OT"
            fogo['%s_data' % (tmp)] = r
        #else:
        #    print "No faceoff %s record for %s" % (tmp, fogo['player'])
    fogo['default_career'] = 1
    if fogo['season_json'] is not None and fogo['season_total_faceoffs'] > 50:
        fogo['default_career'] = 0




    fogo['career_json'] = None; fogo['season_json'] = None;
    return fogo

def build_stats_future_games(scheduled_games, this_year_games, next_year_games, games_played_this_year, team_rec, poss_list, all_games, all_teams, specs):
    team_rec['next_game'] = None; team_rec['alt_next_game'] = None
    last_year_weight = 1.0 - float(min(6., games_played_this_year))/6.0
    this_year_weight = float(min(6., games_played_this_year))/6.0
    
    dt_today = datetime.now().strftime("%Y%m%d")
    this_year_scheduled_games = [z for z in scheduled_games if (z['game_year'] == specs['year']) and (z['game_date'].strftime("%Y%m%d") == dt_today or z['game_date'] > datetime.now())]
    
    SHOW_NEXT_SEASON_GAME=0
    if SHOW_NEXT_SEASON_GAME and len(this_year_scheduled_games) == 0 and len(next_year_games) > 0:
        next_game_ID = sorted(next_year_games, key=lambda x:x['game_epoch'])[0]['ID']
    elif len(this_year_scheduled_games) > 0:
        next_game_ID = None if len(scheduled_games) == 0 else sorted(scheduled_games, key=lambda x:x['game_epoch'])[0]['ID']
    else:
        next_game_ID = None if len(this_year_games) == 0 else sorted(this_year_games, key=lambda x:x['game_epoch'], reverse=True)[0]['ID']
    
    if '-t' in sys.argv: print ("\n\nThere are %d scheduled games for %s." % (len(scheduled_games), team_rec['display_name']))
    if len(this_year_games) > 0:

        for sg in this_year_games:
            if sg['status'] == "scheduled" or sg['ID'] == next_game_ID:

                #print "%s vs %s" % (team_rec['display_name'], sg['opponent'])
                
                if next_game_ID == sg['ID']:
                    
                    sg = build_opponent_time_based_profiles(team_rec, sg, poss_list, this_year_weight, last_year_weight, specs)
                    specs['game_year'] = sg['game_year']
                    sg = build_opponent_player_outcome_splits(team_rec, sg, specs)
                    
                if 1:
                    sg['matchup_advantages'] = {'shooting': {'offense': {}, 'defense': {}}, 'pacing': {'offense': {}, 'defense': {}}}
                    over_under_settings = []
                    margin_of_victory_settings = []
                    sg = build_betting(sg, over_under_settings, margin_of_victory_settings)

                    # Handle the shooting stats
                    
                    ma = sg['matchup_advantages']['shooting']
                    tmp_tags = [{'tag': 'offense', 'opp': 'defense'}, {'tag': 'defense', 'opp': 'offense'}]
                    for tmp in tmp_tags:

                        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (sg['opponentID'], sg['game_year'], tmp['opp']))
                        ma[tmp['tag']]['opp_shots_analysis_this_year'] = None
                        if os.path.isfile(path):
                            ma[tmp['tag']]['opp_shots_analysis_this_year'] = json.loads(open(path, 'r').read())

                        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (sg['opponentID'], sg['game_year']-1, tmp['opp']))
                        ma[tmp['tag']]['opp_shots_analysis_last_year'] = None
                        if os.path.isfile(path):
                            ma[tmp['tag']]['opp_shots_analysis_last_year'] = json.loads(open(path, 'r').read())




                        ttags = ['this_year', 'last_year']

                        for tag in ttags:
                            if None not in [team_rec['full_shooting_profile_%s' % ( tmp['tag'])][tag], ma[tmp['tag']]['opp_shots_analysis_%s' % tag]]:
                                me_shot_clock = team_rec['full_shooting_profile_%s' % ( tmp['tag'])][tag][ [z['tag'] for z in team_rec['full_shooting_profile_%s' % ( tmp['tag'])][tag]].index("shot_clock_remaining_bucket") ]
                                them_shot_clock = ma[tmp['tag']]['opp_shots_analysis_%s' % tag][ [z['tag'] for z in ma[tmp['tag']]['opp_shots_analysis_%s' % tag]].index("shot_clock_remaining_bucket") ]

                                for me, them in zip(me_shot_clock['buckets'], them_shot_clock['buckets']):

                                    me['share_effect'] = 0. if None in [me['share'], them['excess_shooting_pct'], me['excess_shooting_pct'], them['share_diff']] else them['excess_shooting_pct'] * them['share_diff']

                                    me['pct_effect'] = 0. if them['excess_shooting_pct'] is None else them['excess_shooting_pct']

                        ty_list = team_rec['full_shooting_profile_%s' % ( tmp['tag'])]["this_year"]
                        sc_ty = {} if ty_list is None else ty_list[ [z['tag'] for z in ty_list].index("shot_clock_remaining_bucket") ]['buckets']
                        ly_list = team_rec['full_shooting_profile_%s' % ( tmp['tag'])]["last_year"]
                        sc_ly = {} if ly_list is None else ly_list[ [z['tag'] for z in ly_list].index("shot_clock_remaining_bucket") ]['buckets']
                        for ty, ly in zip(sc_ty, sc_ly):
                            if 'share_effect' in ly and 'share_effect' in ty:
                                ty['share_effect_weighted'] = ty['share_effect'] * this_year_weight + ly['share_effect'] * last_year_weight
                                ty['pct_effect_weighted'] = ty['pct_effect'] * this_year_weight + ly['pct_effect'] * last_year_weight
                            elif 'share_effect' in ly and 'share_effect' not in ty:
                                ty['share_effect_weighted'] = ly['share_effect']
                                ty['pct_effect_weighted'] = ly['pct_effect']
                            elif 'share_effect' not in ly and 'share_effect' in ty:
                                ty['share_effect_weighted'] = ty['share_effect']
                                ty['pct_effect_weighted'] = ty['pct_effect']
                            else:

                                
                                if sg['opponentID'] not in [z['ID']for z in all_teams]:
                                    
                                    ty['share_effect_weighted'] = None
                                    ty['pct_effect_weighted'] = None
                                    msg = "In build_stats_future_games (%s vs ID %d), the opponent ID (%d) was not found in the all_teams list, which should include every team. For now, we are going to continue processing the stats and just ignoring this game, for the purposes of displaying opponents, but this error should not happen and needs to be fixed ASAP." % (team_rec['display_name'], sg['opponentID'], sg['opponentID'])
                                    print (msg)
                                    zc.send_crash(msg, bot_token)
                                else:
                                    db_team = all_teams[ [z['ID']for z in all_teams].index(sg['opponentID']) ]
                                    zc.print_dict(db_team)
                                    if sg['opponentID'] in [944, 14, 32, 41, 52, 55, 61, 62, 115, 155, 157, 158, 159, 160, 161, 162]:
                                        ty['share_effect_weighted'] = None
                                        ty['pct_effect_weighted'] = None
                                        pass # These are new teams or teams that did not play in 2021; 944 is Pitt WLAX
                                    elif datetime.now() < datetime(2024, 2, 12) and sg['opponentID'] == 1125: # Emory and Henry's first game as a program is on Feb 11, 2024
                                        ty['share_effect_weighted'] = None
                                        ty['pct_effect_weighted'] = None
                                
                                    elif db_team['min_year'] is None: # New programs who've yet to play a game should have a None value here (added 2024-02-13)
                                        ty['share_effect_weighted'] = None
                                        ty['pct_effect_weighted'] = None
                           
                                    else:
                                        msg = "In build_stats_future_games (%s vs ID %d), could not find either a this_year or last_year shots analysis.\n\nThis team has games played in the database, but for some reason, we do not have a shots analysis for them. Unclear why this would be other than that shots_analyzer.py did not run for them for some reason.\n\n[OLDER LOGIC]Are we sure that team #%d played last year? This is often the issue here." % (team_rec['display_name'], sg['opponentID'], sg['opponentID'])
                                        print (msg)
                                        zc.send_crash(msg, bot_token)
                                        zc.exit("laxref0008")

                    # Handle the pacing profile stuff

                    ma = sg['matchup_advantages']['pacing']

                    for ttag in [{'tag': 'offense', 'desc': 'offensive', 'opp': 'defense'}, {'tag': 'defense', 'desc': 'defensive', 'opp': 'offense'}]:
                        if sg['ID'] == next_game_ID:
                            specs['game_year'] = sg['game_year']
                            ma[ttag['tag']] = build_pacing_profile(sg['opponentID'], poss_list[team_rec['league']], ttag['tag'], specs)
                            specs['game_year'] = None
                        else:
                            ma[ttag['tag']] = None

                    for unit_tag in [{'tag': 'offense', 'desc': 'offensive', 'opp': 'defense'}, {'tag': 'defense', 'desc': 'defensive', 'opp': 'offense'}]:
                        #print("team_rec.%s_pace_profile.length_data" % ttag['desc'])
                        #zc.print_dict(team_rec["%s_pace_profile" % ttag['desc']]['length_data'])

                        for tag in ttags:
                            if ma[unit_tag['opp']] is not None and ma[unit_tag['opp']]['length_data'] is not None:
                                them = ma[unit_tag['opp']]['length_data']
                                if team_rec["%s_pace_profile" % (unit_tag['desc'])] is not None and team_rec["%s_pace_profile" % (unit_tag['desc'])]['length_data'] is not None:
                                    for ib, me in enumerate(team_rec["%s_pace_profile" % (unit_tag['desc'])]['length_data']):

                                        #print "{:<30}{:<30}{:<30}{:<30}{:<30}".format(me['share_%s' % tag], me['efficiency_diff_%s' % tag], them[ib]['share_diff_%s' % tag], them[ib]['efficiency_diff_%s' % tag], them[ib]['share_diff_%s' % tag])

                                        me['share_effect_%s' % tag] = None
                                        if them is not None:
                                            if 'efficiency_diff_%s' % tag in them[ib] and None not in [them[ib]['efficiency_diff_%s' % tag], me['share_%s' % tag], me['efficiency_diff_%s' % tag], them[ib]['share_diff_%s' % tag]]:
                                                them[ib]['efficiency_diff_%s' % tag] * them[ib]['share_diff_%s' % tag]

                                        me['pct_effect_%s' % tag] = None
                                        if them is not None:
                                            if 'efficiency_diff_%s' % tag in them[ib] and them[ib]['efficiency_diff_%s' % tag] is not None:
                                                them[ib]['efficiency_diff_%s' % tag]

                        if team_rec["%s_pace_profile" % unit_tag['desc']] is not None and team_rec["%s_pace_profile" % unit_tag['desc']]['length_data'] is not None:
                            for ib, me in enumerate(team_rec["%s_pace_profile" % unit_tag['desc']]['length_data']):
                                if 'share_effect_this_year' in me:
                                    if me['share_effect_this_year'] is not None and me['share_effect_last_year'] is not None:
                                        me['share_effect'] = me['share_effect_this_year'] * this_year_weight + me['share_effect_last_year'] * last_year_weight
                                        me['pct_effect'] = me['pct_effect_this_year'] * this_year_weight + me['pct_effect_last_year'] * last_year_weight
                                    elif me['share_effect_this_year'] is None and me['share_effect_last_year'] is not None:
                                        me['share_effect'] =  me['share_effect_last_year']
                                        me['pct_effect'] = me['pct_effect_last_year']
                                    elif me['share_effect_this_year'] is not None and me['share_effect_last_year'] is None:
                                        me['share_effect'] =  me['share_effect_this_year']
                                        me['pct_effect'] = me['pct_effect_this_year']
                                    elif me['share_effect_this_year'] is not None and me['share_effect_last_year'] is None:
                                        me['share_effect'] =  me['share_effect_this_year']
                                        me['pct_effect'] = me['pct_effect_this_year']
                                    else:
                                        me['share_effect'] = None
                                        me['pct_effect'] = None
                                else:
                                    me['share_effect'] = None
                                    me['pct_effect'] = None


                #print ("{:<40}{:<20}".format(team_rec['display_name'], "Next ID: %s" % next_game_ID))
                # Identify film stretches to watch
                
                if sg['ID'] == next_game_ID or '--rollins-film-guide' in sys.argv:
                    sg['film_guide'] = build_film_guide(sg['opponentID'], poss_list[team_rec['league']], [z for z in all_games if "complete" in z['status'] and z['game_year'] >= 2015], all_teams, specs)
                    
                    if sg['ID'] != next_game_ID and '--rollins-film-guide' in sys.argv:
                        tmp_msg = ""
                
                        
                        tmp_msg += "<BR><BR>Offense<BR><BR>"
                        tmp_msg += "<BR><BR>".join(["%s to %s vs %s on %s: %d goals on %d poss." % (z['start_timestamp'], z['end_timestamp'], z['opponent'], z['short_date_str'], z['goals'], z['possessions']) for z in sg['film_guide']['offense']['key_stretches']])
                        tmp_msg += "<BR><BR>Defense<BR><BR>"
                        tmp_msg += "<BR><BR>".join(["%s to %s vs %s on %s: %d goals on %d poss." % (z['start_timestamp'], z['end_timestamp'], z['opponent'], z['short_date_str'], z['goals'], z['possessions']) for z in sg['film_guide']['defense']['key_stretches']])
                        
                        
                        zc.send_email("<HTML>%s</HTML>" % tmp_msg, {'subject': "Rollins Film Guide: %s" % (sg['opponent'])})
                else:
                    sg['film_guide'] = None

        #team_rec['next_game'] = sorted(scheduled_games, key=lambda x:x['game_epoch'])[0]
        
        team_rec['next_game'] = None; team_rec['alt_next_game'] = None
        
        if next_game_ID is not None:
            # We make a copy so that we don't accidentally provide the game from the opponent's POV for the 2nd of the two teams that are processed
            if next_game_ID in [z['ID'] for z in next_year_games]:
                team_rec['alt_next_game'] = json.loads(json.dumps(next_year_games[ [z['ID'] for z in next_year_games].index(next_game_ID)], default=zc.json_handler, indent=2))
                team_rec['next_game'] = next_year_games[ [z['ID'] for z in next_year_games].index(next_game_ID)]
                #zc.print_dict(team_rec['next_game'])
            
            else:
                team_rec['alt_next_game'] = json.loads(json.dumps(this_year_games[ [z['ID'] for z in this_year_games].index(next_game_ID)], default=zc.json_handler, indent=2))
                team_rec['next_game'] = this_year_games[ [z['ID'] for z in this_year_games].index(next_game_ID)]
                #zc.print_dict(team_rec['next_game'])
            
    return team_rec


def build_games_list(misc, team_rec, possession_lists, player_game_summaries_by_game, game_stat_adjustments, all_statistics, summaries, all_summaries_by_team, all_teams, this_year_team_seasons, last_year_team_seasons, fogos, mod_val, specs):
    
        
    local_start_ms = time.time()
    local_time_log = [{'start': time.time(), 'end': None, 'tag': 'Start'}]
    path = os.path.join(lr_fldr, "Post_021", "SimResults", "team%04d_%d.json" % (team_rec['ID'], specs['year']))
    team_rec['win_loss_records'] = None
    team_rec['selection_rivals'] = None
    team_rec['future_wins'] = None
    team_rec['future_losses'] = None
    team_rec['selection_rivals'] = None
    team_rec['bubble_watch_games'] = None
    team_rec['num_conf_tournament_teams'] = None
    team_rec['seed_instances'] = None
    tmp_sims = None

    local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Load Sim Results'})
    if os.path.isfile(path):

        #tmp_s = time.time()
        tmp_sims = json.loads(open(path, 'r').read())
        
        #tmp_e = time.time(); print "{:>150}{:>10.4f}".format("Opn Sim results", tmp_e - tmp_s)
        
        team_rec['RPI_ranks_histogram'] = tmp_sims['RPI_ranks_histogram']

        team_rec['win_loss_records'] = tmp_sims['win_loss_records']

        if 'future_wins' not in tmp_sims: zc.send_telegram("%s does not have a future wins object." % team_rec['display_name'])
        team_rec['future_wins'] = tmp_sims['future_wins']
        team_rec['future_losses'] = tmp_sims['future_losses']
        team_rec['selection_rivals'] = tmp_sims['selection_rivals']
        team_rec['bubble_watch_games'] = "[1,23]"#tmp_sims['bubble_watch_games']
        team_rec['num_conf_tournament_teams'] = tmp_sims['num_conf_tournament_teams']
        team_rec['seed_instances'] = tmp_sims['seed_instances']

        team_rec['RPI_ranks_histogram'] = tmp_sims['RPI_ranks_histogram']

        for opp in tmp_sims['hypo_opponents']:
            opp['opp_ID'] = int(opp['oppDate'].split("|")[0])
            opp['tup'] = (opp['opp_ID'], opp['date'])

    misc['opponents'] = []
    
    local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Collect tmp_team_summaries'})
    tmp_team_summaries = [z for z in summaries if z['team_ID'] == team_rec['ID']]
    #print ("\n").join(["{:<10}{:<15}{:<30}".format(z['ID'], z['game_date'].strftime("%Y-%m-%d"), z['status']) for z in misc['games']])
    n_scheduled = len([z for z in misc['games'] if z['status'] == "scheduled"])
    
    for g in misc['games']:
        g['is_next'] = 0
    
    if n_scheduled > 0:
        misc['games'][n_scheduled-1]['is_next'] = 1
    else:
        if len(misc['games']) > 0:
            last_game_ID = sorted(misc['games'], key=lambda x:x['game_epoch'], reverse=True)[0]['ID']
            misc['games'][ [z['ID'] for z in misc['games']].index(last_game_ID) ]['is_next'] = 1
           
        
    local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Games Loop (n=%d)' % len(misc['games'])})
    local_local_time_log = []
    for ig, g in enumerate(misc['games']):

        g['seq'] = ig+1

        #tmp_s = time.time()
        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Collect tmp_team_summaries'})
        g['summaries'] = [z for z in tmp_team_summaries if z['game_ID'] == g["ID"]]
        #if g['ID'] == 10585 and team_rec['ID'] == 145:
        #    zc.print_dict([z for z in g['summaries'] if z['filter'] is None])
        #    print "n=%d" % len([z for z in g['summaries'] if z['filter'] is None])
        #    zc.exit("NU Summaries")
        #if ig == 0: tmp_e = time.time(); print "{:>150}{:>10.4f}".format("Filter summaries", tmp_e - tmp_s)


        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Collect opponent obj'})
        #g['summary_vals'] = [z.values() for z in summaries if z['game_ID'] == g["ID"]]
        g['opponent'] = g['confirmed_home_team'] if g['home_ID'] != team_rec['ID'] else g['confirmed_away_team']
        g['opponentID'] = g['home_ID'] if g['home_ID'] != team_rec['ID'] else g['away_ID']
        opp_obj = all_teams[[z['ID'] for z in all_teams].index(g['opponentID']) ]
        g['is_conference'] = 1 if team_rec['conference_ID'] == opp_obj['conference_ID'] else 0
        
        opp_elo = g['home_elo'] if g['home_ID'] != team_rec['ID'] else g['away_elo']
        team_elo = g['home_elo'] if g['home_ID'] == team_rec['ID'] else g['away_elo']
        g['is_peer'] = 1 if (g['is_conference'] or abs(opp_elo - team_elo) < 200) else 0
        
        if 0 and not g['is_conference']:
            input ("{:<30}{:<30}{:<10.0f}{:<10.0f}{:<10.0f}{:<10.0f}".format(
            g['opponent']
            , team_rec['display_name']
            , g['is_conference']
            , g['home_elo']
            , g['away_elo']
            , g['is_peer']
            ))
        #print (sorted(opp_obj.keys())); zc.exit("laxref0001")

        g['headline'] = "%s vs %s" % (team_rec['short_code'], opp_obj['short_code'])

        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Collect FOGO data'})
        if fogos is not None and g['is_next']:
            g['opp_fogos'] = [z for z in fogos if z['team_ID'] == g['opponentID']]

            #zc.print_dict(g)
            #print (sorted(g.keys())); zc.exit("laxref000g1")
                
            #print sorted(g.keys())
            #print "{:<10}{:<20}{:<20}".format(g['ID'], "NONE" if g['game_date'] is None else g['game_date'].strftime("%Y%m%d"), g['game_year'])
            src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_faceoff_splits_%d_LRP.json" % (g['opponentID'], g['game_year']))
            g['fogo_splits'] = None
            if os.path.isfile(src):
                g['fogo_splits'] = json.loads(open(src, 'r').read());
            
            if "Women" in g['league']:
                src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_draw_winners_%d_LRP.json" % (g['opponentID'], g['game_year']))
                g['draw_winners'] = None
                if os.path.isfile(src):
                    g['draw_winners'] = json.loads(open(src, 'r').read());
            
            src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_faceoff_splits_%d_LRP.json" % (g['opponentID'], g['game_year']-1))
            g['fogo_splits_last_year'] = None
            if os.path.isfile(src):
                g['fogo_splits_last_year'] = json.loads(open(src, 'r').read());
                        
            src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_roster_%d_LRP.json" % (g['opponentID'], g['game_year']))
            g['opp_roster'] = None
            if os.path.isfile(src):
                g['opp_roster'] = json.loads(open(src, 'r').read());
                
            src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_statistical_adjustments_%d_LRP.json" % (g['opponentID'], g['game_year']))
            g['opp_stat_adjustments'] = None
            g['opp_stat_adjustments_this_year'] = 1
            if os.path.isfile(src):
                g['opp_stat_adjustments'] = json.loads(open(src, 'r').read());
            else:
                src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_statistical_adjustments_%d_LRP.json" % (g['opponentID'], g['game_year']-1))
                if os.path.isfile(src):
                    g['opp_stat_adjustments'] = json.loads(open(src, 'r').read());
                    g['opp_stat_adjustments_this_year'] = 0
            
    
            g['fogo_splits_calculated'] = None if 'fogo_splits' not in opp_obj else opp_obj['fogo_splits']
            #print "From File"
            #zc.print_dict(g['fogo_splits_from_file'])
            #print "Calculated"
            #zc.print_dict(g['fogo_splits'])
            #sys.exit()
            
            #tmp_s = time.time()
            for fogo in g['opp_fogos']:
                fogo = build_fogo_splits(fogo, specs)

            #tmp_e = time.time(); print "{:>150}{:>10.4f}".format("FOGO Splits", tmp_e - tmp_s)


            g['opp_fogos'] = sorted(g['opp_fogos'], key=lambda x:(0 if x['num_faceoffs_taken_last_team_game'] is None else x['num_faceoffs_taken_last_team_game']), reverse=True)



        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Get opponent summaries'})
        g['opponent_display'] = opp_obj['display_name'].replace("'", "&#39;")
        g['opp_url'] = opp_obj['pro_url_tag']
        
        def game_to_game_pro_url_tag(g, specs={}):
            """
            Converts a game object into a pro_url_tag that can pull up the game on PRO
            """
            
            error = None
            tmp_g = {'team1': None, 'team2': None, 'gender_char': None, 'year': None, 'ID': None}
            
            if 'team' in specs and specs['team'] not in [None, ''] and 'opponent_display' in specs and specs['opponent_display'] not in [None, '']:
                tmp1 = hash_player_name(specs['team'])
                tmp2 = hash_player_name(specs['opponent_display'])
                if tmp1 < tmp2:
                    tmp_g['team1'] = tmp1; tmp_g['team2'] = tmp2; 
                else:
                    tmp_g['team1'] = tmp2; tmp_g['team2'] = tmp1; 
            elif 'team' in specs and specs['team'] not in [None, ''] and 'opponent' in specs and specs['opponent'] not in [None, '']:
                tmp1 = hash_player_name(specs['team'])
                tmp2 = hash_player_name(specs['opponent'])
                if tmp1 < tmp2:
                    tmp_g['team1'] = tmp1; tmp_g['team2'] = tmp2; 
                else:
                    tmp_g['team1'] = tmp2; tmp_g['team2'] = tmp1;
            elif 'team1' in specs and specs['team1'] not in [None, ''] and 'team2' in specs and specs['team2'] not in [None, '']:
                tmp1 = hash_player_name(specs['team1'])
                tmp2 = hash_player_name(specs['team2'])
                if tmp1 < tmp2:
                    tmp_g['team1'] = tmp1; tmp_g['team2'] = tmp2; 
                else:
                    tmp_g['team1'] = tmp2; tmp_g['team2'] = tmp1; 
            
            if 'league' in g and g['league'] not in [None, ""]:
                tmp_g['gender_char'] = "w" if "women" in g['league'].lower() else "m"
            elif 'gender' in g and g['gender'] not in [None, ""]:
                tmp_g['gender_char'] = "w" if "w" in g['gender'].lower() else "m"
            
            if 'year' in g and g['year'] not in [None, ""]:
                tmp_g['year'] = g['year']
            elif 'game_year' in g and g['game_year'] not in [None, ""]:
                tmp_g['year'] = g['game_year']
            elif 'zgame_year' in g and g['zgame_year'] not in [None, ""]:
                tmp_g['year'] = g['zgame_year']
            elif 'game_date' in g and g['game_date'] not in [None, ""] and isinstance(g['game_date'], datetime):
                tmp_g['year'] = g['game_date'].year
            
            if 'ID' in g and g['ID'] not in [None, ""]:
                tmp_g['ID'] = g['ID']
            elif 'gID' in g and g['gID'] not in [None, ""]:
                tmp_g['ID'] = g['gID']
            elif 'game_ID' in g and g['game_ID'] not in [None, ""]:
                tmp_g['ID'] = g['game_ID']
            
            
            #print ("\ngame --> pro_url_tag")
            
            #zc.print_dict(tmp_g)
            pro_url_tag = "game-{}-vs-{}-{}lax-{}-{}".format(tmp_g['team1'], tmp_g['team2'], tmp_g['gender_char'], tmp_g['year'], zc.to_zhex(tmp_g['ID'], 3).lower())
            #print ("tag: {}".format(pro_url_tag))
            return pro_url_tag, error
            
        team_mod = int(g['opponentID'] % mod_val)
        tmp_list = [z for z in all_summaries_by_team[team_mod] if z['filter'] is None and g['opponentID'] == z['team_ID']]
        tmp_url_tag, error = game_to_game_pro_url_tag(g, {'team1': team_rec['display_name'], 'team2': g['opponent_display']})
        if '--test-game-url' in sys.argv: 
            zc.print_dict(g)
            print ("\n tag: %s" % tmp_url_tag)
            input("-->")
        if error is None:
            g['url_tag'] = tmp_url_tag
        else:
            g['url_tag'] = None
            
        # [Feb 26th, 2024] These represent a large portion of the data object that is pulled up each time a team's page is requested by a user; they appear to serve no purpose outside of the next_game object, which was removed (i.e. misc.data.next_game is set to null if you load a team's page)
        
        # I'm going to remove these data by setting the list to empty for one team with the goal of seeing how that team's page reacts; if it doesn't cause any issues, we should make it permanent.
        
        # For context, I pulled up a team's page (MSM WLAX) and the size of the misc in JS was 3233kb; the misc.data object was 93.3% of that; alt_next_game itself was 38.9% of the data object, and the summaries within alt_next_game alone were 64% of the data object and therefore. Removing them would therefore cut down the size of the entire team JSON that is being served by 22%.
        
        # Test results: I see no degradation in the display as a result of making the change below. From a size perspective, the size of the misc.data object in JS was 2477; the misc.data object was 91% of that; alt_next_game itself down to 18.6% of the misc data object. Removing them cut down the size of the entire team JSON that is being served by 23%.
        if 1 or team_rec['ID'] == 175: # Remove this check (all objects should be without the summaries) assuming no issues pop up before March 1st
            g['opp_off_summaries'] = []
            g['opp_def_summaries'] = []
        else:
            g['opp_off_summaries'] = [z for z in tmp_list if z['data_type'] == "offense"]
            g['opp_def_summaries'] = [z for z in tmp_list if z['data_type'] == "defense"]
        for s in g['opp_off_summaries']:
            s['opp_short_code'] = all_teams[ [z['ID'] for z in all_teams].index(s['opp_team_ID']) ]['short_code']

        #tmp_s = time.time()
        #if ig == 0: tmp_e = time.time(); print "{:>150}{:>10.4f}".format("Opp summaries", tmp_e - tmp_s)
        g['opp_short_code'] = opp_obj['short_code']

        g['conference_game'] = 1 if opp_obj['conference_ID'] == team_rec['conference_ID'] else 0
        if g['opponent'] not in [z['opponent'] for z in misc['opponents']]:
            misc['opponents'].append({'opponent': g['opponent'], 'opp_short_code': opp_obj['short_code'], 'display_name': opp_obj['display_name'], 'opponentID': g['opponentID'], 'cnt': 0.})

        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Format opp ranking strings'})
        g['opp_rankings_summary_str'] = "N/A"; g['opp_rankings_summary_str_mob'] = "N/A";
        g['opp_rankings_dict'] = None
        g['opp_team_season'] = None; g['opp_last_team_season'] = None;
        
        #print (" Check on the rankings dict for %s ( opponent of %s )" % (g['opponent'], team_rec['display_name']))
        if '--test-opp-roster' in sys.argv and g['opponentID'] == 27:
            print ("27 in LY: %d" % (27 in [z['team_ID'] for z in last_year_team_seasons]))
            print("n this year: %d" % (len(this_year_team_seasons)))
            input("n last year: %d" % (len(last_year_team_seasons)))
            
            
        if this_year_team_seasons is not None:
            if g['opponentID'] in [z['team_ID'] for z in this_year_team_seasons]:
                g['opp_team_season'] = this_year_team_seasons[ [z['team_ID'] for z in this_year_team_seasons].index(g['opponentID'])]
                g['opp_rankings_summary_str'] = g['opp_team_season']['rankings_summary_str']
                g['opp_rankings_summary_str_mob'] = g['opp_team_season']['rankings_summary_str_mob']
                g['opp_rankings_dict'] = g['opp_team_season']['rankings_dict']
                
            if g['opponentID'] in [z['team_ID'] for z in last_year_team_seasons]:
                
                g['opp_last_team_season'] = last_year_team_seasons[ [z['team_ID'] for z in last_year_team_seasons].index(g['opponentID'])]

                if g['opp_rankings_dict'] is None:
                    g['opp_rankings_summary_str'] = "(Last Season): %s" %g['opp_last_team_season']['rankings_summary_str']
                    g['opp_rankings_summary_str_mob'] = "(Last Season): %s" %g['opp_last_team_season']['rankings_summary_str_mob']
                    g['opp_rankings_dict'] = g['opp_last_team_season']['rankings_dict']
        
        #print ("{:<40} @ {}".format ("     Opp (date): %s (%s)" % (g['opponent'], g['game_date_YYYYmmdd']), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Calculate game success rates'})
        for tmp in ['off_efficiency', 'def_efficiency_inverted', 'faceoff_win_rate']:
            g[tmp + "_color"] = "#FFF"
            g[tmp + "_color_last_season"] = "#FFF"
            if g['opp_team_season'] is not None:

                tmp_list = sorted([z[tmp] for z in this_year_team_seasons if z[tmp] is not None and z['league'] == team_rec['league']])
                tlen = len(tmp_list)
                if tlen < 30 or g['opp_team_season'][tmp] is None:
                    g[tmp + "_color"] = "#DDD"
                else:
                    #print ("{:<40} @ {}".format ("          A) %s (%s) %d to %d" % (tmp, g['opp_team_season'][tmp], tlen*1/20, tlen*19/20), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

                    low = tmp_list[int(tlen*1/20)]; high = tmp_list[int(tlen*19/20)]; rng = high - low
                    adj = min(max(0, (g['opp_team_season'][tmp] - low)/rng), 1)
                    g[tmp + "_color"] = zc.pct_to_red_green_scale(adj)
            if g['opp_last_team_season'] is not None:
                tmp_list = sorted([z[tmp] for z in last_year_team_seasons if z[tmp] is not None and z['league'] == team_rec['league']])

                tlen = len(tmp_list)
                if tlen < 30 or g['opp_last_team_season'][tmp] is None:
                    g[tmp + "_color_last_season"] = "#DDD"
                else:
                    #print ("{:<40} @ {}".format ("          B) %s (%s) %d to %d (tmp_list.length=%d)" % (tmp, g['opp_last_team_season'][tmp], tlen*1/20, tlen*19/20, tlen), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

                    low = tmp_list[int(tlen*1/20)];  high = tmp_list[int(tlen*19/20)]; rng = high - low
                    adj = min(max(0, (g['opp_last_team_season'][tmp] - low)/rng), 1)
                    g[tmp + "_color_last_season"] = zc.pct_to_red_green_scale(adj)
                #g['opp_last_team_season'] = None
        
        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Increment opponent count'})
        misc['opponents'][ [z['opponent'] for z in misc['opponents']].index(g['opponent']) ]['cnt'] += 1.

        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Format game result'})
        g['win'] = None; g['opponent_result'] = None; g['score_str'] = None; g['opp_short_code_result'] = None

        if 'complete' in g['status']:
            g['win'] = 1; g['win_letter'] = "W"; g['win_color'] = "#3B3"

            if g['home_ID'] == team_rec['ID'] and g['home_score'] < g['away_score']:
                g['win'] = 0; g['win_letter'] = "L"; g['win_color'] = "#E33"

            elif g['away_ID'] == team_rec['ID'] and g['away_score'] < g['home_score']:
                g['win'] = 0; g['win_letter'] = "L"; g['win_color'] = "#E33"

              

            g['team_score'] = g['away_score'] if g['away_ID'] == team_rec['ID'] else g['home_score']
            g['opp_score'] = g['away_score'] if g['away_ID'] != team_rec['ID'] else g['home_score']
            g['this_team_elo_transfer'] = "" if g['elo_transfer'] is None else ((1.0 if g['win'] else -1.0) * g['elo_transfer'])
            g['this_team_elo_transfer_html'] = "" if g['elo_transfer'] is None else ("<span class='contents' style='color:%s;'>%s%d</span>" % (g['win_color'], "+" if g['win'] else "-", g['elo_transfer']))

            if g['win']:
                if g['home_ID'] == team_rec['ID']:
                    g['end_elo'] = g['home_elo'] + (0. if g['elo_transfer'] is None else g['elo_transfer'])
                else:
                    g['end_elo'] = g['away_elo'] + (0. if g['elo_transfer'] is None else g['elo_transfer'])
                
            else:
                if g['home_ID'] == team_rec['ID']:
                    g['end_elo'] = g['home_elo'] - (0. if g['elo_transfer'] is None else g['elo_transfer'])
                else:
                    g['end_elo'] = g['away_elo'] - (0. if g['elo_transfer'] is None else g['elo_transfer'])

            #g['end_elo'] = get_team_elo_rating(team_rec['ID'], g['dashed_date'], start=False)
            
            if g['away_ID'] == team_rec['ID']:
                if g['win']:
                    g['end_elo_alt'] = g['away_elo'] + (0 if g['elo_transfer'] is None else g['elo_transfer'])
                else:
                    g['end_elo_alt'] = g['away_elo'] - (0 if g['elo_transfer'] is None else g['elo_transfer'])
                
            else:
                if g['win']:
                    g['end_elo_alt'] = g['home_elo'] + (0 if g['elo_transfer'] is None else g['elo_transfer'])
                else:
                    g['end_elo_alt'] = g['home_elo'] - (0 if g['elo_transfer'] is None else g['elo_transfer'])
                
            if g['ID'] not in [9892, 9879, 9851] and abs(g['end_elo'] - g['end_elo_alt']) > 2.:
                msg = "Error in game ID %s when processing %s (ID=%d), the alt ELO calculation failed. Original: %d; Alternate: %d" % (g['ID'], team_rec['display_name'], team_rec['ID'], g['end_elo'], g['end_elo_alt'])
                
                msg += "\n%s - %d; %s - %d; win? %s" % (g['home_team'], g['home_score'], g['away_team'], g['away_score'], g['win'])
                msg += "\n%s Elo: %d; %s Elo: %d; Elo Transfer: %d" % (g['home_team'], g['home_elo'], g['away_team'], g['away_elo'], g['elo_transfer'])
                zc.send_crash(msg, bot_token)
                zc.print_dict(g)
                print (msg)
                zc.exit("games_test321ewfsdsf")

            g['opponent_result'] = "%s (<span class='no-padding' style='color:%s;'>%s %d-%d</span>)" % (g['opponent_display'], g['win_color'], g['win_letter'], g['away_score'] if g['away_ID'] == team_rec['ID'] else g['home_score'], g['away_score'] if g['home_ID'] == team_rec['ID'] else g['home_score'])

            g['score_str_html'] = "<span class='no-padding' style='color:%s;'>%s %d-%d</span>" % (g['win_color'], g['win_letter'], g['away_score'] if g['away_ID'] == team_rec['ID'] else g['home_score'], g['away_score'] if g['home_ID'] == team_rec['ID'] else g['home_score'])

            g['score_str'] = "%s %d-%d" % (g['win_letter'], g['team_score'], g['opp_score'])

            g['opp_short_code_result'] = "%s (<span class='no-padding' style='color:%s;'>%s %d-%d</span>)" % (g['opp_short_code'], g['win_color'], g['win_letter'], g['away_score'] if g['away_ID'] == team_rec['ID'] else g['home_score'], g['away_score'] if g['home_ID'] == team_rec['ID'] else g['home_score'])

            g['headline_result_str'] = "%s %d - %s %d" % (team_rec['display_name'], g['team_score'], opp_obj['display_name'], g['opp_score'])


        wp = float((g['seq']%5)) * .225 + .05
        g['wp_bar_length'] = int(wp*100.)
        g['wp_bar_color'] = "rgb(%d,%d,%d)" % (255.*(1.-wp), 255.*wp, 128.*(abs(.5-wp)))


        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Calculate game efficiencies'})
        g['off_efficiency'] = None; g['def_efficiency'] = None; g['faceoff_win_rate'] = None;
        if 'offense' in [z['data_type'] for z in g['summaries']]:
            g['off_summary'] = g['summaries'][ [z['data_type'] for z in g['summaries']].index("offense") ]
            g['off_efficiency'] = g['off_summary']['goals']/g['off_summary']['possessions'] if g['off_summary']['possessions'] > 0 else None
            g['faceoff_win_rate'] = g['off_summary']['faceoff_win_rate']

            g['def_summary'] = g['summaries'][ [z['data_type'] for z in g['summaries']].index("defense") ]
            g['def_efficiency'] = g['def_summary']['goals']/g['def_summary']['possessions'] if g['def_summary']['possessions'] > 0 else None
           
            if g['def_efficiency'] is None:
                #print (sorted(g.keys()))
                #print ("\n\nDefensive Goals: %s" % (g['def_summary']['goals']))
                #print ("Defensive Possessions: %s\n\n" % (g['def_summary']['possessions']))
               
                try:
                    msg = "In update_team_summary_stats_LR.py, a game (ID=%d) on the schedule for %s (ID=%d; %s) was recorded with a NULL defensive efficiency for %s (ID=%d). " % (g['ID'], team_rec['display_name'], team_rec['ID'], team_rec['league'], g['opponent'], g['opponentID'])
                except Exception:
                    msg = "In update_team_summary_stats_LR.py, a game (ID=%d) on the schedule for %s (ID=%d; %s) was recorded with a NULL defensive efficiency for %s (ID=%d). " % (g['game_ID'], team_rec['display_name'], team_rec['ID'], team_rec['league'], g['opponent'], g['opponentID'])
                msg += "\n\ng.keys: %s" % str(sorted(g.keys()))
                msg += "\n\nteam_rec.keys: %s" % str(sorted(team_rec.keys()))
               
                msg += "\n\nOne time that this error occurred, it was because a game had been processed (and TGS records added) and then the game was later set to manualFinal."
     
                print (msg)
                zc.send_crash(msg, bot_token)
                zc.exit("BAD EFFICIENCY")
            g['def_efficiency_inverted'] = 1. - g['def_efficiency']

        # Get the win/loss sim stuff

        local_local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Collect RPI W/L chart data'})
        hypo_tup = (g['opponentID'], g['dashed_date'])

        g['avg_RPI_with_win'] = 37
        g['avg_RPI_with_loss'] = 37
        g['avg_RPI_with_win_str'] = "N/A"
        g['avg_RPI_with_loss_str'] = "N/A"


        if tmp_sims is not None and hypo_tup in [z['tup'] for z in tmp_sims['hypo_opponents']]:
            hypo = tmp_sims['hypo_opponents'][ [z['tup'] for z in tmp_sims['hypo_opponents']].index(hypo_tup) ]
            g['avg_RPI_with_win'] = hypo['win_avg_RPI']
            g['avg_RPI_with_loss'] = hypo['loss_avg_RPI']
            g['avg_RPI_with_win_str'] = "N/A" if g['avg_RPI_with_win'] is None else "{:.0f}{}" .format (g['avg_RPI_with_win'], zc.get_number_suffix(g['avg_RPI_with_win']))
            g['avg_RPI_with_loss_str'] = "N/A" if g['avg_RPI_with_loss'] is None else "{:.0f}{}" .format (g['avg_RPI_with_loss'], zc.get_number_suffix(g['avg_RPI_with_loss']))

    local_time_log[-1]['local_time_log'] = local_local_time_log
    local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Season Games'})
    team_rec['completed_games_cnt'] = len([1 for z in misc['games'] if 'complete' in z['status']])
    team_rec['completed_games_cnt_this_year'] = len([1 for z in misc['games'] if z['game_year'] == specs['year'] and 'complete' in z['status']])

    team_rec['season_games'] = []
    team_rec['show_next_season_games'] = 0
    
    # Create list of games for the current season
    for gm in [z for z in misc['games'] if z['this_year']]:
        d = {}
        tmp_keys = ['game_epoch', 'status', 'ID', 'url_tag', 'is_conference', 'is_peer', 'win', 'date_mmmdd', 'summaries', 'only_box_score', 'score_str_html', 'opp_short_code', 'opponent_display', 'opp_url', 'most_recent', 'opponentID', 'home_ID', 'away_ID', 'adj_off_eff', 'adj_def_eff', 'adj_fo_win', 'adj_turnover_rate', 'adj_poss_margin', 'pregame_home_wp', 'opp_rankings_dict']
        #print ("\n\nGame %d" % (gm['ID']))
        for k in tmp_keys:
            if k in gm:
                d[k] = gm[k]
                #if k not in ["summaries"]:
                #    print ("{:<30}{}".format(k, gm[k]))
        d['month'] = gm['game_date'].month
        
        team_rec['season_games'].append(d)
    
    # Calculate the splits for stats by month and by win vs loss
    if 'splits' not in team_rec:
        team_rec['splits'] = {}
        scenario_types = []
        scenario_types.append({'tag': 'win', 'split': "w_vs_l", 'tags': [{'win': 1}, {'win': 0}]})
        scenario_types.append({'tag': 'month', 'split': "months", 'tags': [{'month': 2}, {'month': 3}, {'month': 4}, {'month': 5}]})
        scenario_types.append({'tag': 'is_conference', 'split': "by_conference", 'tags': [{'is_conference': 1}, {'is_conference': 0}]})
        for scenarios in scenario_types:
            team_rec['splits'][scenarios['split']] = []
            for g in scenarios['tags']:
                g['missing_efficiency_data'] = 0
               
                # Check all the summaries from games that have been flagged as win==scenarios.tag
                FEB2024_FIX=1
                if FEB2024_FIX:
                    
                    for z in team_rec['season_games']:
                        z['off_summary'] = None
                        tmp_summaries = [y for y in z['summaries'] if y['team_ID'] == team_rec['ID'] and y['data_type'] == "offense" and y['filter'] is None]
                        if len(tmp_summaries) > 0:
                            z['off_summary'] = tmp_summaries[0]
                            
                    off_summaries = [z['off_summary'] for z in team_rec['season_games'] if z['only_box_score'] != 1 and z['status'] not in ['scheduled', 'manualFinal'] and z[scenarios['tag']] == g[scenarios['tag']] and z['off_summary'] is not None]
                                    
                    
                    for z in team_rec['season_games']:
                        z['def_summary'] = None
                        tmp_summaries = [y for y in z['summaries'] if y['team_ID'] == team_rec['ID'] and y['data_type'] == "defense" and y['filter'] is None]
                        if len(tmp_summaries) > 0:
                            z['def_summary'] = tmp_summaries[0]
                    def_summaries = [z['def_summary'] for z in team_rec['season_games'] if z['only_box_score'] != 1 and z['status'] not in ['scheduled', 'manualFinal'] and z[scenarios['tag']] == g[scenarios['tag']] and z['def_summary'] is not None]
                else:
                    
                    off_summaries = [[y for y in z['summaries'] if y['team_ID'] == team_rec['ID'] and y['data_type'] == "offense" and y['filter'] is None][0] for z in team_rec['season_games'] if z['only_box_score'] != 1 and z['status'] not in ['scheduled', 'manualFinal'] and z[scenarios['tag']] == g[scenarios['tag']]]
                                    
                    def_summaries = [[y for y in z['summaries'] if y['team_ID'] == team_rec['ID'] and y['data_type'] == "defense" and y['filter'] is None][0] for z in team_rec['season_games'] if z['only_box_score'] != 1 and z['status'] not in ['scheduled', 'manualFinal'] and z[scenarios['tag']] == g[scenarios['tag']]]
                    
                n = len(off_summaries)
                g['n_games'] = n
                if scenarios['split'] == "w_vs_l":
                    g['display'] = "In %d %s%s" % (n, "win" if g[scenarios['tag']] else "loss", "" if n == 1 else ("s" if g[scenarios['tag']] else "es"))
                elif scenarios['split'] == "months":
                    dt = datetime(1986, g[scenarios['tag']], 1)
                    g['display'] = "%s (%d game%s)" % (dt.strftime("%b"), n, "s" if n!=1 else "")
                elif scenarios['split'] == "by_conference":
                    g['display'] = "%s (%d game%s)" % ("vs Conf" if g[scenarios['tag']] else "Non-Conf", n, "s" if n!=1 else "")
                
                
                tmp_summaries = off_summaries
                g['off_possessions'] = sum([z['possessions'] for z in tmp_summaries])
                g['off_goals'] = sum([z['goals'] for z in tmp_summaries])
                g['off_assists'] = sum([z['assists'] for z in tmp_summaries])
                g['off_turnovers'] = sum([z['turnovers'] for z in tmp_summaries])
                g['off_shots'] = sum([z['shots'] for z in tmp_summaries])
                g['off_shots_per_possession'] = None if g['off_possessions'] == 0 else (g['off_shots'] / g['off_possessions'])
                g['off_on_keeper_shots'] = sum([z['on_keeper_shots'] for z in tmp_summaries])
                g['faceoff_wins'] = sum([z['faceoff_wins'] for z in tmp_summaries])
                g['faceoff_losses'] = sum([z['faceoff_losses'] for z in tmp_summaries])
                g['faceoff_win_rate'] = None if (g['faceoff_wins'] + g['faceoff_losses']) == 0 else (g['faceoff_wins'] / (g['faceoff_wins'] + g['faceoff_losses']))
                g['possession_margin'] = None if n == 0 else (sum([z['possession_margin'] for z in tmp_summaries]) / n)
                g['modified_possession_margin'] = None if n == 0 else (sum([z['modified_possession_margin'] for z in tmp_summaries]) / n)
                g['gbs_won'] = sum([z['gbs_won'] for z in tmp_summaries])
                g['gbs_lost'] = sum([z['gbs_lost'] for z in tmp_summaries])
                g['gb_win_rate'] = None if (g['gbs_won'] + g['gbs_lost']) == 0 else (g['gbs_won'])/(g['gbs_won'] + g['gbs_lost'])
                g['off_good_clears'] = sum([z['good_clears'] for z in tmp_summaries])
                g['off_failed_clears'] = sum([z['failed_clears'] for z in tmp_summaries])
                g['off_man_up_chances'] = sum([z['man_up_chances'] for z in tmp_summaries])
                g['off_possessions_plus_failed_clears'] = sum([z['possessions_plus_failed_clears'] for z in tmp_summaries])
                
                
                tmp_summaries = def_summaries
                g['def_possessions'] = sum([z['possessions'] for z in tmp_summaries])
                g['def_goals'] = sum([z['goals'] for z in tmp_summaries])
                g['def_assists'] = sum([z['assists'] for z in tmp_summaries])
                g['def_turnovers'] = sum([z['turnovers'] for z in tmp_summaries])
                g['def_shots'] = sum([z['shots'] for z in tmp_summaries])
                g['def_shots_per_possession'] = None if g['def_possessions'] == 0 else (g['def_shots'] / g['def_possessions'])
                g['def_on_keeper_shots'] = sum([z['on_keeper_shots'] for z in tmp_summaries])
                g['def_good_clears'] = sum([z['good_clears'] for z in tmp_summaries])
                g['def_failed_clears'] = sum([z['failed_clears'] for z in tmp_summaries])
                g['def_man_up_chances'] = sum([z['man_up_chances'] for z in tmp_summaries])
                g['def_possessions_plus_failed_clears'] = sum([z['possessions_plus_failed_clears'] for z in tmp_summaries])
                
                for tmp_unit in ['off', 'def']:
                    tmp_summaries = off_summaries if tmp_unit == "off" else def_summaries
                    n = len(tmp_summaries)
                    
                    def missing_adjusted_values_check(team_rec, g, tmp_unit, tag, reference_stat, tmp_summaries):
                        """
                        This function checks whether the specified stat is present in the tmp_summaries values for the team in question. If the stat value is None, then we may need to re-run the efficiency model script to update it for that game.
                        """
                        
                        if None in [z['adjusted_%s' % tag] for z in tmp_summaries if reference_stat is None or z[reference_stat] > 0]:
                            msg = "[WARNING] error in laxref.build_games_list when processing %s (ID=%s)!\n\nadjusted_%s was None in the TGS record" % (team_rec['display_name'], team_rec['ID'], tag)
                            
                            tup = (tag, sys.argv[sys.argv.index('-league') + 1])
                            
                            # There is no need to crash this script when the missing efficiency data is identified; instead, point out the problem and then do not process this team; this way, we can get the rest of the teams processed (and more importantly, upload) while being able to resolve the efficiency issue separately.
                            if not g['missing_efficiency_data'] and ('-final' not in sys.argv or sys.argv[sys.argv.index('-final') + 1] in ['yes', 'final', "1"]):
                                query = "SELECT game_ID from LaxRef_Team_Game_Summaries a, LaxRef_Games b where a.active and ISNULL(adjusted_{}) and ISNULL(filter) and data_type='offense' and b.ID=a.game_ID and b.active and b.status like 'comp%%' and b.zgame_year=%s and b.league=%s and IFNULL(only_box_score, 0)=0 and IFNULL(game_type,'')='' group by game_ID".format(tag)
                                param = [specs['year'], team_rec['league']]
                                print ("\nQuery %s w/ %s" % (query, param))
                                cursor = zc.zcursor("LR")
                                msg += "\nQuery %s w/ %s" % (query, param)
                                game_IDs = cursor.dqr(query, param)
                                cursor.close()
                                msg += "\ntmp unit: %s" % tmp_unit
                                msg += "\n\n(If you are not certain that it's only an issue with {}) You can try to fix this via\n\npython efficiency_model.py --update-all --just-new --no-debug --game-ID \"{}\" -league \"{}\" -year {}\n".format(
                                tag
                                , "|".join([str(z['game_ID']) for z in game_IDs])
                                , team_rec['league']
                                , specs['year']
                                )
                                msg += "\n\n(If you are certain that it's only an issue with {}) You can try to fix this via\n\npython efficiency_model.py --update-all --just-new --no-debug --game-ID \"{}\" -league \"{}\" -year {} -stat {}\n".format(
                                tag
                                , "|".join([str(z['game_ID']) for z in game_IDs])
                                , team_rec['league']
                                , specs['year']
                                , tag
                                )
                                msg += "\n\ng:\n%s\n" % json.dumps(g, default=zc.json_handler, indent=1)
                            
                                game = [z for z in tmp_summaries if z['adjusted_%s' % tag] is None][0]
                                msg += get_game_crash_info(game)
                                msg += "\n\n%s" % json.dumps([z for z in tmp_summaries if z['adjusted_%s' % tag] is None][0], default=zc.json_handler, indent=1)
             
                                if "update_team_summary_stats_LR.py" not in str(sys.argv):
                                    if tup not in [(z['tag'], z['league']) for z in specs['missing_efficiency_errors']]:
                                        print(msg)
                                        zc.send_crash(msg, bot_token)
                                        specs['missing_efficiency_errors'].append({'tag': tag, 'league': sys.argv[sys.argv.index('-league') + 1]})
                            g['missing_efficiency_data'] = 1
                            
                            
                        return g
                    # shooting_pct
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "shooting_pct", 'shots', tmp_summaries)
                    g['%s_shooting_pct' % tmp_unit] = None if g['%s_shots' % tmp_unit] == 0 else (g['%s_goals' % tmp_unit] / g['%s_shots' % tmp_unit])
                    g['adjusted_%s_shooting_pct' % tmp_unit] = None if g['missing_efficiency_data'] or g['%s_shots' % tmp_unit] == 0 else (sum([z['adjusted_shooting_pct'] * z['shots'] for z in tmp_summaries if z['shots'] > 0]) / g['%s_shots' % tmp_unit])
                    
                    # on_goal_shooting_pct
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "on_goal_shooting_pct", 'on_keeper_shots', tmp_summaries)
                    g['%s_on_goal_shooting_pct' % tmp_unit] = None if g['%s_on_keeper_shots' % tmp_unit] == 0 else (g['%s_goals' % tmp_unit] / g['%s_on_keeper_shots' % tmp_unit])
                    g['adjusted_%s_on_goal_shooting_pct' % tmp_unit] = None if g['missing_efficiency_data'] or g['%s_on_keeper_shots' % tmp_unit] == 0 else (sum([z['adjusted_on_goal_shooting_pct'] * z['on_keeper_shots'] for z in tmp_summaries if z['on_keeper_shots'] > 0]) / g['%s_on_keeper_shots' % tmp_unit])

                    # shots_per_possession
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "shots_per_possession", 'possessions', tmp_summaries)
                    g['%s_shots_per_possession' % tmp_unit] = None if g['%s_possessions' % tmp_unit] == 0 else (g['%s_shots' % tmp_unit] / g['%s_possessions' % tmp_unit])
                    g['adjusted_%s_shots_per_possession' % tmp_unit] = None if g['missing_efficiency_data'] or g['%s_possessions' % tmp_unit] == 0 else (sum([z['adjusted_shots_per_possession'] * z['possessions'] for z in tmp_summaries if z['possessions'] > 0]) / g['%s_possessions' % tmp_unit])

                    # efficiency
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "efficiency", 'possessions', tmp_summaries)
                    g['%s_efficiency' % tmp_unit] = None if g['%s_possessions' % tmp_unit] == 0 else (g['%s_goals' % tmp_unit] / g['%s_possessions' % tmp_unit])
                    g['adjusted_%s_efficiency' % tmp_unit] = None if g['missing_efficiency_data'] or g['%s_possessions' % tmp_unit] == 0 else (sum([z['adjusted_efficiency'] * z['possessions'] for z in tmp_summaries if z['possessions'] > 0]) / g['%s_possessions' % tmp_unit])

                    # adjusted_save_pct
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "save_pct", 'on_keeper_shots', tmp_summaries)
                    g['%s_save_pct' % tmp_unit] = None if g['%s_on_keeper_shots' % tmp_unit] == 0 else (g['%s_goals' % tmp_unit] / g['%s_on_keeper_shots' % tmp_unit])
                    g['adjusted_%s_save_pct' % tmp_unit] = None if g['missing_efficiency_data'] or g['%s_on_keeper_shots' % tmp_unit] == 0 else (sum([z['adjusted_save_pct'] * z['on_keeper_shots'] for z in tmp_summaries if z['on_keeper_shots'] > 0]) / g['%s_on_keeper_shots' % tmp_unit])

                    # adjusted_turnover_rate
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "turnover_rate", 'possessions', tmp_summaries)
                    g['%s_turnover_rate' % tmp_unit] = None if g['%s_possessions' % tmp_unit] == 0 else (g['%s_turnovers' % tmp_unit] / g['%s_possessions' % tmp_unit])
                    g['adjusted_%s_turnover_rate' % tmp_unit] = None if g['missing_efficiency_data'] or g['%s_possessions' % tmp_unit] == 0 else (sum([z['adjusted_turnover_rate'] * z['possessions'] for z in tmp_summaries if z['possessions'] > 0]) / g['%s_possessions' % tmp_unit])

                    # adjusted_modified_possession_margin
                    if tmp_unit == "off":
                        g = missing_adjusted_values_check(team_rec, g, tmp_unit, "modified_possession_margin", None, tmp_summaries)
                        g['adjusted_modified_possession_margin'] = None if g['missing_efficiency_data'] or n == 0 else (sum([z['adjusted_modified_possession_margin'] for z in tmp_summaries]) / n)

                    # adjusted_clear_rate
                    #, sum(adjusted_clear_rate*possessions_plus_failed_clears)/sum(possessions_plus_failed_clears) adjusted_clear_rate
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "clear_rate", 'possessions_plus_failed_clears', tmp_summaries)
                    g['adjusted_%s_clear_rate' % tmp_unit] = None if g['missing_efficiency_data'] or n == 0 else (sum([z['adjusted_clear_rate'] * z['possessions_plus_failed_clears'] for z in tmp_summaries if z['possessions_plus_failed_clears'] > 0]) / g['%s_possessions_plus_failed_clears' % tmp_unit])
                    
                    # adjusted_assist_rate
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "assist_rate", 'goals', tmp_summaries)
                    g['%s_assist_rate' % tmp_unit] = None if g['%s_goals' % tmp_unit] == 0 else (g['%s_assists' % tmp_unit] / g['%s_goals' % tmp_unit])
                    g['adjusted_%s_assist_rate' % tmp_unit] = None if g['missing_efficiency_data'] or g['%s_goals' % tmp_unit] == 0 else (sum([z['adjusted_assist_rate'] * z['goals'] for z in tmp_summaries if z['goals'] > 0]) / g['%s_goals' % tmp_unit])
                    
                    # adjusted_faceoff_conversion_rate
                    # sum(adjusted_faceoff_conversion_rate*faceoff_wins)/sum(faceoff_wins) adjusted_faceoff_conversion_rate
                    g = missing_adjusted_values_check(team_rec, g, tmp_unit, "faceoff_conversion_rate", 'faceoff_wins', tmp_summaries)
                    g['adjusted_%s_faceoff_conversion_rate' % tmp_unit] = None if g['missing_efficiency_data'] or g['faceoff_wins'] == 0 else (sum([z['adjusted_faceoff_conversion_rate'] * z['faceoff_wins'] for z in tmp_summaries if z['faceoff_wins'] > 0]) / g['faceoff_wins'])
                    
                    # adjusted_gb_win_rate
                    if tmp_unit == "off":
                        g = missing_adjusted_values_check(team_rec, g, tmp_unit, "gb_win_rate", None, tmp_summaries)
                        g['adjusted_gb_win_rate'] = None if g['missing_efficiency_data'] or (g['gbs_won'] + g['gbs_lost']) == 0 else (sum([z['adjusted_gb_win_rate'] * (z['gbs_won'] + z['gbs_lost']) for z in tmp_summaries if z['gbs_won'] + z['gbs_lost'] > 0]) / (g['gbs_won'] + g['gbs_lost']))
                    
                    # faceoff_win_rate
                    if tmp_unit == "off":
                        g = missing_adjusted_values_check(team_rec, g, tmp_unit, "faceoff_win_rate", None, tmp_summaries)
                        g['adjusted_faceoff_win_rate'] = None if g['missing_efficiency_data'] or (g['faceoff_wins'] + g['faceoff_losses']) == 0 else (sum([z['adjusted_faceoff_win_rate'] * (z['faceoff_wins'] + z['faceoff_losses']) for z in tmp_summaries if z['faceoff_wins'] + z['faceoff_losses'] > 0]) / (g['faceoff_wins'] + g['faceoff_losses']))
                    
                                    
                                    
                        
                team_rec['splits'][scenarios['split']].append(g)    

    local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Next Season Games'})
    team_rec['next_season_games'] = []
    for gm in [z for z in misc['games'] if z['next_year']]:
        d = {}
        
        tmp_keys = ['game_epoch', 'status', 'ID', 'date_mmmdd', 'score_str_html', 'opp_short_code', 'opponent_display', 'most_recent', 'opponentID', 'home_ID', 'away_ID', 'adj_off_eff', 'adj_def_eff', 'adj_fo_win', 'adj_turnover_rate', 'adj_poss_margin', 'pregame_home_wp', 'opp_rankings_dict']
        for k in tmp_keys:
            if k in gm:
                d[k] = gm[k]
        team_rec['next_season_games'].append(d)
    
    if datetime.now().month in [11,12]:
        team_rec['show_next_season_games'] = 1
    #zc.print_dict(team_rec['season_games']);
    #print "n = %d" % len( team_rec['season_games'] )
    #zc.exit("laxref0002")

    local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Elo Results'})
    #zc.print_dict(misc['games'][0])
    #zc.exit (misc['games'][0].keys())
    team_rec['elo_results'] = [{'opponentID': z['opponentID'], 'ID': z['ID'], 'opp_url': None if 'opp_url' not in z else z['opp_url'], 'this_year': z['this_year'], 'score_str_html': z['score_str_html'], 'opp_short_code': z['opp_short_code'], 'date_YYYYmmdd': z['date_YYYYmmdd'], 'this_team_elo_transfer_html': z['this_team_elo_transfer_html'], 'end_elo': z['end_elo'], 'this_team_elo_transfer': z['this_team_elo_transfer']} for z in misc['games'] if 'complete' in z['status']]


    tmp = [z for z in misc['games'] if "complete" in z['status']]
    team_rec['last_game'] = None
    for ig, gm in enumerate(misc['games']):
        gm['most_recent'] = 0
    local_time_log.append({'start': time.time(), 'end': None, 'tag': 'Process Game Possessions'})
    if len(tmp) > 0 and possession_lists is not None:
        max_gm_dt = sorted(tmp, key=lambda x:x['game_epoch'], reverse=True)[0]['date_YYYYmmdd']
        for ig, gm in enumerate(misc['games']):
            if "complete" in gm['status'] and max_gm_dt == gm['date_YYYYmmdd']:
                gm['most_recent'] = 1

            if "complete" in gm['status'] and gm['game_year'] in [specs['year'], specs['last_year']]:
                if gm['game_year'] not in possession_lists[gm['league']] and gm['league'] == team_rec['league']:
                    msg = "When processing the build_games_list function for %s (ID=%d), there are no possessions in the DB from %d for %s. Are we sure all games have been processed?" % (team_rec['display_name'], team_rec['ID'], gm['game_year'], gm['league'])
                    print (msg);
                    zc.send_crash(msg, bot_token)
                    zc.exit("laxref0003")

                # If a team switches divisions, then their last game will not have any possessions in the possessions list; that's fine; it's not going to happen very often. Just make the list empty and write nothing to the last game page.
                if gm['league'] == team_rec['league']:
                    game_poss = [z for z in possession_lists[gm['league']][gm['game_year']] if z['game_ID'] == gm['ID']]
                else:
                    game_poss = []
                mod_ID = int(gm['ID'] % mod_val)
                game_summaries = [z for z in player_game_summaries_by_game[mod_ID] if z['game_ID'] == gm['ID']]

                
                if gm['most_recent']:
                    gm = build_stats_completed_game(gm, game_stat_adjustments, game_poss, all_statistics, summaries, misc['keys'], game_summaries, team_rec, specs)
            

        
        if len(misc['games']) > 0:
            tmp_lg = [z for z in misc['games'] if z['most_recent']][0]
        
            #print (sorted(tmp_lg.keys()))
            tmp_vars_names = ['game_date']
            tmp_vars = {}
            for tmp_var in tmp_vars_names:
                tmp_vars[tmp_var] = tmp_lg[tmp_var]
                tmp_lg[tmp_var] = None
            team_rec['last_game'] = json.loads(json.dumps(tmp_lg))
                
            # Re-add date information
            for tmp_var in tmp_vars_names:
                tmp_lg[tmp_var] = tmp_vars[tmp_var]
    
    local_end_ms = time.time()
    local_elapsed = local_end_ms - local_start_ms

    for i, item in enumerate(local_time_log):
        if i == len(local_time_log) - 1:
            item['end'] = local_end_ms
        else:
            item['end'] = local_time_log[i+1]['start']
        item['elapsed'] = item['end'] - item['start']
        item['pct'] = item['elapsed'] / local_elapsed
        
        if 'local_time_log' in item:
            for ij, jitem in enumerate(item['local_time_log']):
                if ij == len(item['local_time_log']) - 1:
                    jitem['end'] = item['end']
                else:
                    jitem['end'] = item['local_time_log'][ij+1]['start']
                jitem['elapsed'] = jitem['end'] - jitem['start']
            tmp_total = sum([z['elapsed'] for z in item['local_time_log']])
            item['local_tags'] = [{'tag': z} for z in list(set([y['tag'] for y in item['local_time_log']]))]
            for ij, jitem in enumerate(item['local_tags']):
                jitem['elapsed'] = sum([z['elapsed'] for z in item['local_time_log'] if z['tag'] == jitem['tag']])
                jitem['pct'] = 0 if tmp_total == 0 else (jitem['elapsed'] / tmp_total)
        
    print ("{:<20}{:<60}{:<20}{:<20}".format("", "Task", "Elapsed", "Pct"))
    print ((" " * 20) + ("-" * 100))
    for i, item in enumerate(local_time_log):
        print ("{:<20}{:<60}{:<20.3f}{:<20.3f}".format("", item['tag'], item['elapsed'], item['pct']))
        if 'local_time_log' in item:
            print ("\n")
            for ij, jitem in enumerate(item['local_tags']):
                print ("{:<40}{:<60}{:<20.3f}{:<20.3f}".format("", jitem['tag'], jitem['elapsed'], jitem['pct']))    

    print ("{:<20}{:<60}{:<20.3f}{:<20}".format("", "Total", local_elapsed, ""))
    return misc, team_rec

def construct_js_RPI_factors(objects):
    js_data = {'cell_size': 'large-cell-holder'}
    js_data['classes'] = [{'class': "col-4 no-padding left"}, {'outer_class': 'col-8', 'classes': [{'class': ""}, {'class': ""}, {'class': ""},  {'class': ""}]}]
    js_data['fmt'] = [{'fmt': ""}, {'fmt': "3"}, {'fmt': "3"}, {'fmt': "3"}, {'fmt': "3"}]
    js_data['fields'] = [
    {'tag': 'desc', 'display': ""}
    , {'sort_by': 'RPI1', 'tag': 'RPI1', 'display': 'Win Pct'}
    , {'sort_by': 'RPI2', 'tag': 'RPI2', 'display': 'Opp Win%'}
    , {'sort_by': 'RPI3', 'tag': 'RPI3', 'dtop_display': 'Opp Opp Win%', 'mob_display': 'Opp Opp%'}
    , {'sort_by': 'RPI', 'tag': 'RPI', 'display': 'Avg RPI'}]
    js_data['data'] = []
    for t in [z for z in objects]:
        d = {}
        for i, f in enumerate(js_data['fields']):
            if 'sort_by' in f and f['sort_by'] not in d:
                d[f['sort_by']] = {'val': t[f['sort_by']], 'seq': -1}
        for i, f in enumerate(js_data['fields']):
            v = t[f['tag']]
            d[f['tag']] = {'val': v, 'seq': i}
        js_data['data'].append(d)
    return json.dumps(js_data)

def record_script_completion(s, success, error_msg=""):
    """
    This function updates the timestamps log for the specified update script. 
    """
    if error_msg not in [None, '']:
        error_msg += "\n\nOriginal Command: python %s" % (" ".join([z if " " not in z else ("\"%s\"" % z) for z in sys.argv]))
        
    error_msg = error_msg.replace("\n", "\\n").replace("|", " --- ")
    f = open(os.path.join(lr_fldr, "refresh_timestamps.txt"), 'a'); f.write("%s|%s|%s|%s\n" % (s,  datetime.now().strftime("%Y%m%d%H%M%S"), 1 if success else 0, error_msg)); f.close()
    
    # Now update the log JSON files (for /admin_automation route)
    if success:
        zc.automation_mark_script_complete(s, error_msg)
    else:
        zc.automation_mark_script_failed(s, error_msg)

def upload_file(m):
    if 'top_bucket' not in m:
        m['top_bucket'] = "capozziinc.appspot.com"
    if 'fname' not in m or m['fname'] is None:
        m['fname'] = m['src'].split("\\")[-1]
    if '--upload-to-LR' in sys.argv:
        creds = None
        try:
            #Upload Files
            if m['target_folder'] not in ['GeneralData', 'GameData']:

                creds = [{'username': z.split("|")[0], 'password': z.split("|")[1], 'url': z.split("|")[2]} for z in filter(None, open(os.path.join(lr_fldr, 'Logs', 'ftp_creds'), 'r').read().split("\n"))]
                ftp = FTP(creds[0]['url'])
                ftp.login(creds[0]['username'], creds[0]['password'])
                ftp.cwd('/wp-content/uploads/%s' % m['target_folder'])
                ftp.storbinary('STOR ' + m['fname'], open(m['src'], 'rb'))
                ftp.quit()

        except Exception:
            msg = "File upload failed for %s going to LR" % (m['fname'])
            msg +=  ("\n\n%s\n\nSRC: %s; Target Folder: %s\n\n%s" % (msg, m['src'], m['target_folder'], traceback.format_exc()))
            msg += "\n\nCreds\n\n%s" % json.dumps(creds)
            print (msg)
            zc.send_telegram(msg, bot_token)

    if '--upload-to-w10' in sys.argv:
        try:
            #Upload Files
            if "C:" in lr_fldr:
                target_path = os.path.join(lr_fldr, 'LRP', "LRP_flask", "\\".join(m['target_folder'].split("/")))


                args = ['copy', m['src'], os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "\\".join(m['target_folder'].split("/")))]

                script_fname = os.path.join(lr_fldr, "Logs", "laxref_w10_upload.bat")
                f = open(script_fname, 'w')
                f.write("\n\n\n%s\n" % (" ".join(args)))
                f.close()
                start_ms = datetime.now().strftime("%H:%M:%S")
                subprocess.call([script_fname])
            
        except Exception:
            msg = "File upload failed for %s going to w10\n\n%s" % (m['fname'], traceback.format_exc())
            print ("%s\n\nSRC: %s; Target Folder: %s\n\n%s" % (msg, m['src'],  "\\".join(m['target_folder'].split("/")), traceback.format_exc()))
            zc.send_telegram(msg, bot_token)


    if '--upload-to-LRP' in sys.argv or ('force_upload' in m and m['force_upload']):
        try:
            #Upload Files
            if '--use-upload-route' in sys.argv:
                url = "https://pro.lacrossereference.com/upload"
                key = open(os.path.join(lr_fldr, 'LRPuploadkey'), 'r').read().strip()
                key_pair = open(os.path.join(lr_fldr, 'LRPuploadkey_pair'), 'r').read().strip()
                print ("Uploading file of size {:,.2f}kb".format(float(os.path.getsize(m['src']))/1024.))
                files = {key_pair: key, 'file': open(m['src'], 'r'), 'bucket': m['target_folder']}
                response = requests.post(url, files=files).content
            else:
                args = [os.path.join(lr_fldr, "upload_to_storage_bucket.bat"), m['src'], "gs://%s/%s" % (m['top_bucket'], m['target_folder'])]
                print (args)
                
                proc = subprocess.Popen(args, stdout=subprocess.PIPE); time.sleep(0.01)
                tmp = proc.stdout.read()
                print (tmp)
        except Exception:
            msg = "File upload failed for %s going to LRP\n\n%s" % (m['fname'], traceback.format_exc())
            print ("%s\n\nSRC: %s; Target Folder: %s\n\n%s" % (msg, m['src'], m['target_folder'], traceback.format_exc()))
            zc.send_telegram(msg, bot_token)


def load_win_odds_data(league, league_tag, window_length, sections, all_leagues_db_win_odds = None):
    use_file = False
    if use_file:
        win_odds_data = open(os.path.join(lr_fldr, 'WinOddsTime_and_Score_%s_window%d_sections%d' % (league_tag,  window_length, sections)), 'r').read().split("\n")
        win_odds_ID = ['n/a']
        for w in filter(None, win_odds_data[1:]):
            win_odds_ID.append(int(w.split(",")[0]))

    else:
        if all_leagues_db_win_odds is None:
            print("     {:<95}{:<15}".format("Query win odds data...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
            zcursor = zc.zcursor("LR")
            query = "SELECT * from LaxRef_Win_Odds_Lookup where league=%s and window_length=%s and sections=%s"
            param = [league, window_length, sections]
            #print ("Query %s w/ %s" % (query, param))
            all_leagues_db_win_odds = zcursor.dqr(query, param)
            zcursor.close()

        db_win_odds_data_raw = [z for z in all_leagues_db_win_odds if z['league'] == league]
        win_odds_data = []
        

        win_odds_ID = ['n/a'] + sorted(list(set([int(z['game_section']) for z in db_win_odds_data_raw])))


        for ID in win_odds_ID:
            row = [("%03d" % ID if ID != "n/a" else ID)]
            section_data = sorted([z for z in db_win_odds_data_raw if z['game_section'] == ID], key=lambda x:x['deficit'], reverse=True)
            row += ["" if z['win_odds'] is None else ("%.4f" % z['win_odds']) for z in section_data]
            row = ",".join(row)
            win_odds_data.append(row)

    return win_odds_ID, win_odds_data

def content_to_fname(c):
    """
    Converts the data from a LaxRef_Content object into a slug for the PRO site
    """
    if c['summary_header'] is None: return None
    c['fname'] = c['summary_header'].replace(" ", "-").lower()
    #print ("A: %s" %c['fname'])
    
    
    
    tmp_team = None
    if c['team'] is not None:
        tmp_team = c['team'].replace(" ", "-").lower()
        tmp_team = "".join([z for z in tmp_team if 48 <= ord(z) <= 57 or 97 <= ord(z) <= 122 or z in ['-']])
    c['fname'] = "".join([z for z in c['fname'] if 48 <= ord(z) <= 57 or 97 <= ord(z) <= 122 or z in ['-']])
    #print ("B: %s" %c['fname'])
    if tmp_team is not None and tmp_team not in c['fname']:
        c['fname'] += "-%s-%s" % (tmp_team, c['gender'].lower())
        #print ("D1: %s (%s)" % (c['fname'], tmp_team))
    elif tmp_team is not None and tmp_team in c['fname']:
        c['fname'] = c['fname'].replace(tmp_team, "%s-%s" % (tmp_team, c['gender'].lower()))
        #print ("D2: %s" %c['fname'])
    c['fname'] = c['fname'].replace("-mlax-mlax", "-mlax")
    #print ("E: %s" %c['fname'])
    c['fname'] = c['fname'].replace("-wlax-wlax", "-wlax")
    #print ("F: %s" %c['fname'])
    c['fname'] += "-%d" % c['ID']
    #print ("G: %s" %c['fname'])
    if '--test-urls' in sys.argv and 'rpi' in c['fname'].lower() and 'schedule' in c['fname'].lower():
        zc.print_dict(c); zc.exit("RPI R")
    return c['fname']
            
def replace_special_chars(s):
    """
    Replace the non-ascii version of characters with the ascii version
    """
    if s is None: return s

    if ('--debug-special-chars' in sys.argv and "Morgan" in s) or ('--test-ascii-handling' in sys.argv):
        for c in s:
            print (c, ord(c))
        if '--test-ascii-handling' not in sys.argv:
            zc.exit("KATCH")
    apostrophes = []
    apostrophes.append({'str': "'#393a", 'repl': "'"})
    apostrophes.append({'str': chr(226) + chr(128) + chr(153), 'repl': "'"})
    apostrophes.append({'str': chr(226) + chr(63) + chr(63), 'repl': "'"})
    for j, ap in enumerate(apostrophes):
        s = s.replace(ap['str'], ap['repl'])
    
    accented_letters = []
    accented_letters.append({'str': chr(195) + chr(169), 'repl': "e"})
    for j, ap in enumerate(accented_letters):
        s = s.replace(ap['str'], ap['repl'])
            
    if '--test-ascii-handling' in sys.argv:
        zc.exit("Returned {}".format(s))
    return s
    
def load_play_values_data(league, league_tag, window_length, all_leagues_db_play_values = None):
    use_file = False

    if use_file:
        play_value_data = open(os.path.join(lr_fldr, 'PlayValues_%s_window%d' % (l['tag'], window_length)), 'r').read().split("\n")
        plays = []
        play_values_for = []
        play_values_against = []
        for p in filter(None, play_value_data[1:]):
            p0 = p.split(",")[0]
            p1 = float(p.split(",")[5])
            p2 = float(p.split(",")[6])
            if p0 != "" and p1 != "":
                plays.append(p0)
                play_values_for.append(p1)
                play_values_against.append(p2)



    else:
        if all_leagues_db_play_values is None:
            zcursor = zc.zcursor("LR")
            all_leagues_db_play_values = zcursor.dqr("SELECT * from LaxRef_Play_Values", [])
            zcursor.close()
            
        
        if league=="NCAA D3 Men":
            db_raw = [z for z in all_leagues_db_play_values if z['league'] == "NCAA D1 Men" and z['window_length'] == window_length]
        else:
            db_raw = [z for z in all_leagues_db_play_values if z['league'] == league and z['window_length'] == window_length]


        plays = list(set([z['play_type'] for z in db_raw]))
        play_values_for = []
        play_values_against = []
        adds = []
        for p in plays:
            play_values_for.append([z['goals_for']/z['num_occurrences'] if z['num_occurrences'] != 0 else None for z in db_raw if z['play_type'] == p][0])
            play_values_against.append([z['goals_against']/z['num_occurrences'] if z['num_occurrences'] != 0 else None for z in db_raw if z['play_type'] == p][0])
            if p == "Faceoff Win":
                # Caused turnover is the inverse of a forced turnover
                adds.append(["Faceoff Loss", 0., 0.])
            if p == "Forced Turnover":
                # Caused turnover is the inverse of a forced turnover
                adds.append(["Caused Turnover", play_values_against[-1], play_values_for[-1]])
            if p == "Saved Shot":
                # Save is the inverse of a saved shot for the offense
                adds.append(["Save", play_values_against[-1], play_values_for[-1]])
        for add in adds:
            plays.append(add[0])
            play_values_for.append(add[1])
            play_values_against.append(add[2])


    return plays, play_values_for, play_values_against



def add_dates_back(obj):
        for o in obj:
            if not (isinstance(o, str)):
                for k in o.keys():
                    if k.endswith("_epoch") and k.replace("_epoch", "_str") in o.keys() and k.replace("_epoch", "") in o.keys() and o[k.replace("_epoch", "")] is None:
                        #rint "I bet %s is a deflated date" % k
                        o[k.replace("_epoch", "")] = datetime.strptime(o[k.replace("_epoch", "_str")], "%Y%m%d%H%M%S")

        return obj

def reconnect_db(conn, cursor):
    try:
        cursor.execute("SELECT count(1) from LaxRef_Teams")
    except Exception:
        print ("Have to reconnect to the DB...")
        return zc.mysql_connect("LR")
    return conn, cursor

def create_table_of_LLM_analyses(gpt_log):
    """
    Creates a command prompt table of the analyses in a GPT log
    """
    
    prompts = [z for z in gpt_log if z['type'] == "prompt"]
    responses = [z for z in gpt_log if z['type'] == "response"]
    
    for p in prompts:
        p['response'] = None
        p['has_response'] = 0; p['is_edited'] = 0
        if p['id'] in [z['request_id'] for z in responses]:
            p['response'] = responses[ [z['request_id'] for z in responses].index(p['id']) ]
            p['has_response'] = 1
            if 'adminEditedVersion' in p['response'] and p['response']['adminEditedVersion'] is not None and p['response']['adminEditedVersion']['text'] not in [None, '']:
                p['is_edited'] = 1
    
    #print(json.dumps(prompts[0]['response']['ranking'], default=zc.json_handler, indent=1))
    txt = "{:<15}{:<60}{:<15}{:<15}{:<15}".format("Session TS", "Analysis", "Has Response", "Ranking", "Edited")
    txt += "\n%s\n" % ("-" * 115)
    txt += "\n".join(["{:<15}{:<60}{:<15}{:<15}{:<15}".format(z['session_ts']
    , z['analysis']
    , "YES" if z['has_response'] else "No"
    , str(z['response']['ranking'][0]['ranking']) if ('ranking' in z['response'] and z['response']['ranking'] is not None and len(z['response']['ranking']) > 0) else ""
    , "YES" if z['is_edited'] else "No"
    ) for z in prompts])
    #txt += "\n\nKeys: %s" % (sorted(prompts[0]['response'].keys()))
    #txt += "\n\n: %s" % json.dumps(prompts[0]['response']['ranking'], default=zc.json_handler, indent=1)
    
    return txt
    
def build_player_outcome_splits(player_groupings, all_statistics, player_summaries, team_summaries, all_players, last_year_players, team_rec, specs):
    start_ms = time.time()
    team_rec['player_outcome_splits'] = {}
    
    game_versions = [{'label': 'All Games', 'key': 'player_outcome_splits_all', 'game_filter': (lambda x:1) }
    , {'label': 'Conf Games', 'key': 'player_outcome_splits_conf_only', 'game_filter': (lambda x:x['is_conference']) }
    , {'label': 'Non-Conf Games', 'key': 'player_outcome_splits_nonconf_only', 'game_filter': (lambda x:not x['is_conference']) }
    , {'label': 'Peer Games', 'key': 'player_outcome_splits_peer_only', 'game_filter': (lambda x:(x['is_peer'])) }
    , {'label': 'Non-Peer Games', 'key': 'player_outcome_splits_nonpeer_only', 'game_filter': (lambda x:(not x['is_peer'])) }]
    #game_versions = game_versions[1:2]
    #game_versions = game_versions[0:1]
    
    debug = '--debug-player-outcome-split' in sys.argv
    for gv in game_versions:
        team_rec['player_outcome_splits'][gv['key']] = []
        sp = team_rec['player_outcome_splits'][gv['key']]
        sp.append({'unit': 'offense', 'my_team': 1, 'splits': []})
        sp.append({'unit': 'defense', 'my_team': 0, 'splits': []})
        
        
        all_stats = [z for z in all_statistics if 1 or z['use_in_player_outcome_splits']]
        all_stats = sorted(all_stats, key=lambda x:(0. if x['player_outcome_splits_priority'] is None else x['player_outcome_splits_priority']), reverse=True)
        all_stats = [z for z in all_stats if z['stat'] in ['assist_to_turnover_ratio', 'assists', 'turnovers', 'shots', 'goals', 'team_play_shares']]
        
        
        groupings = []
        groupings.append({'seq': 0, 'skip_offense': 0, 'skip_defense': 1, 'team': 0, 'desc': 'Ind. Players', 'tag': 'player_ID'})
        groupings.append({'seq': 0, 'skip_offense': 1, 'skip_defense': 0, 'team': 0, 'desc': 'Player Persona', 'values': ['has_highest_share_of_team_assists', 'has_highest_goals', 'has_highest_shots', 'is_primary_fogo', 'has_highest_weighted_team_play_shares', 'has_highest_usage_adjusted_EGA', 'has_highest_points', 'has_highest_turnover_rate']})
        groupings.append({'seq': 0, 'skip_offense': 0, 'skip_defense': 0, 'team': 0, 'desc': 'Player Grouping', 'tag': 'team_listed_role'})
        #groupings.append({'seq': 0, 'skip_offense': 0, 'skip_defense': 0, 'team': 1, 'desc': 'Team as a Whole'})
        
        

        for i, split in enumerate(sp):
            if split['unit'] == "offense":
                stats = [z for z in all_stats if z['stat'] not in ['team_play_shares']]
            elif split['unit'] == "defense":
                stats = [z for z in all_stats if z['stat'] not in ['turnovers']]
            
        
            if debug: print ("\n\n%s: %s (%s)\n" % (team_rec['display_name'], split['unit'].upper(), gv['label']))
            if split['my_team']:
                player_games = [z for z in player_summaries if z['team_ID'] == team_rec['ID']]
                team_games = [z for z in team_summaries if z['team_ID'] == team_rec['ID'] and z['filter'] is None and z['data_type'] == "offense"]
            else:
                player_games = [z for z in player_summaries if z['opp_team_ID'] == team_rec['ID']]
                team_games = [z for z in team_summaries if z['opp_team_ID'] == team_rec['ID'] and z['filter'] is None and z['data_type'] == "offense"]
            tmp_groupings = [z for z in groupings if (split['unit'] == "offense" and not z['skip_offense']) or (split['unit'] == "defense" and not z['skip_defense'])]
            
            #print ("There are {:,} player game records".format(len(player_games)))    
            for grouping in tmp_groupings:
                #print ("Grouping: %s" % grouping['desc'])
                if grouping['team']:
                    grouping['variants'] = [{'grouping_type': grouping['desc'], 'tag': None}]   
                    for v in grouping['variants']:
                        v['player_games'] = [z for z in team_games]
                    
                    #zc.print_dict(grouping['variants'])
                    #print "There are %d variants" % len(grouping['variants'])
                    #print ("\n").join(["{:<50}{:>15,}".format(z['tag'], len(z['player_games'])) for z in grouping['variants']])
             
                elif 'tag' in grouping:
                    if grouping['tag'] == "player_ID":
                        grouping['variants'] = [{'grouping_type': grouping['desc'], 'tag': z} for z in list(set([y[grouping['tag']] for y in player_games if not y['is_primary_fogo'] and y['season_team_play_shares'] is not None and y['season_team_play_shares'] > .02]))] 
                    else:
                        grouping['variants'] = [{'grouping_type': grouping['desc'], 'tag': z} for z in list(set([y[grouping['tag']] for y in player_games]))]   
                    for v in grouping['variants']:
                        v['player_games'] = [z for z in player_games if z[grouping['tag']] == v['tag']]
                    
                    #zc.print_dict(grouping['variants'])
                    #print ("There are %d variants" % len(grouping['variants']))
                    #print ("\n".join(["{:<50}{:>15,}".format(z['tag'], len(z['player_games'])) for z in grouping['variants']]))
                    #zc.exit("FDS")
                elif 'values' in grouping:
                    grouping['variants'] = [{'grouping_type': grouping['desc'], 'tag': z} for z in grouping['values']]   
                    for v in grouping['variants']:
                        v['player_games'] = [z for z in player_games if z[v['tag']]]
                    
                    #zc.print_dict(grouping['variants'][0])
                    #print "There are %d variants" % len(grouping['variants'])
                    #print ("\n").join(["{:<50}{:>15,}".format(z['tag'], len(z['player_games'])) for z in grouping['variants']])
                    #zc.exit("laxref0004")
                else:
                    grouping['variants'] = [{'grouping_type': grouping['desc'], 'tag': None}]   
                    for v in grouping['variants']:
                        v['player_games'] = [z for z in player_games]
                    
                    #zc.print_dict(grouping['variants'])
                    #print "There are %d variants" % len(grouping['variants'])
                    #print ("\n").join(["{:<50}{:>15,}".format(z['tag'], len(z['player_games'])) for z in grouping['variants']])
                    
            
            games = [z for z in team_summaries if (z['this_year'] or z['last_year']) and z['filter'] is None and z['data_type'] == "offense" and z['my_team'] == split['my_team'] and gv['game_filter'](z)]
            games_this_year = sum([1. for z in games if z['this_year']])
            if games_this_year >= 8:
                games = [z for z in games if z['this_year']]

            
            
            #zc.print_dict(games[0])
            if debug: 
                print ("Games\n-------------------------------------------------------------------------------------------------")
                print ("{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}".format("This Year", "Last Year", "Team ID", "Opp ID", "Win?", "Goals", "Eff", "Adj", "AdjEff"))
                
                
                
            use_adjusted_stats = 1
            for j, stat in enumerate(stats):
                #print "stat: %s" % stat['stat']
                # Loop through each stat in question and go from the min val to the max value to find the win pct split above and beyond the points in question (with a buffer range if needed)
                for k, grouping in enumerate(tmp_groupings):
                        
                    process_stat = 1
                    if grouping['team'] and 'team' not in stat['relevant_subjects']:
                        process_stat = 0
                    elif not grouping['team'] and 'player' not in stat['relevant_subjects']:
                        process_stat = 0
                        
                    if process_stat:
                        #print  "  grouping: %s" % grouping['desc']
                        for l, variant in enumerate(grouping['variants']):
                            #print "    variant: %s (%d game rows)" % (variant['tag'], len(variant['player_games']))
                            game_results = []
                            unique_vals = []
                            for g in games:
                                g['has_adjustment_data'] = 0
                                d = {'win': g['win'], 'opp_team_ID': g['opp_team_ID'], 'goals': g['goals'], 'possessions': g['possessions']}
                                if split['unit'] == "defense":
                                    d['efficiency_adjustment'] = g['opp_efficiency_adjustment']
                                    
                                else:
                                    tmp = [z for z in g['game_stat_adjustments'] if z['stat_ID'] == 1]
                                    d['efficiency_adjustment'] = None
                                    if len(tmp) > 0:
                                        d['efficiency_adjustment'] = tmp[0]['adjustment']
                                
                                if 0 and d['efficiency_adjustment'] is None:
                                    zc.print_dict(g)
                                    msg = "Error in laxref.build_player_outcome_splits. No efficiency adjustment was found for game ID %d when processing the stat %s" % (g['game_ID'], stat['stat'])
                                    msg += "\nPreviously, this was caused by an issue in the efficiency_model script, but if that is running through, then are we sure the game is showing up in the list of games? In a prior instance with this issue, the problem was that a game had been moved from pending to complete, but calculate_elo_ratings.py so it didn't show up in the ELO History file. In another situation, the problem was that LaxRef_Game_Stat_Adjustments where present for a game, but the game had been switched to different team IDs, so the game matches, but the team IDs no longer matched.\n\nSELECT * from LaxRef_Game_Stat_Adjustments where game_ID=%d" % g['game_ID']
                                    msg += "\n\nExiting..."
                                    print (msg)
                                    zc.send_crash(msg, bot_token)
                                    zc.exit("laxref0005")
                                
                                if d['efficiency_adjustment'] is not None:
                                    if debug and j + k + l == 0:
                                        print ("{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10.3f}{:<10.3f}{:<10.3f}".format(g['this_year'], g['last_year'], g['team_ID'], g['opp_team_ID'], g['win'], g['goals'], g['efficiency'], d['efficiency_adjustment'], g['efficiency'] + d['efficiency_adjustment']))
                                    #d['efficiency'] = g['goals']/g['possessions']                            
                                    d['adjusted_goals'] = None
                                    #d['adjusted_efficiency'] = None; d['adjusted_efficiency_alt'] = None
                                    
                                    if d['efficiency_adjustment'] is not None:
                                        d['adjusted_goals'] = d['goals'] + d['efficiency_adjustment'] * d['possessions']
                                    else:
                                        
                                        use_adjusted_stats = 0
                                    tmp = [z for z in variant['player_games'] if z['game_ID'] == g['game_ID']]
                                    
                    
                                    d['val'] = None; d['is_infinite'] = 0
                                    if len(tmp) > 0:
                                        
                                        if stat['numerator'] is None:
                                           
                                            denom = 1.
                                            numer = sum([z[stat['stat']] for z in tmp if None not in [z[stat['stat']]]])
                                            if split['unit'] == "offense" and variant['tag'] == "M" and debug and stat['stat'] == "goals":
                                                print ("{:<10}{:<10}{:<10}".format("", g['game_ID'], numer))
                                                if g['game_ID'] == 54510:
                                                    print ("\n".join(["{:<30}{:<10}{:<10}{:<10}".format(z['player_ID'], z[stat['stat']], z['game_ID'], z['team_ID']) for z in sorted(tmp, key=lambda x:x['player_ID'])]))
                                                    zc.exit("GAME 54510")
                                                
                                        else:
                                            
                                                
                                    
                                            denom = sum([z[stat['denominator']] for z in tmp if None not in [z[stat['denominator']], z[stat['numerator']]]])
                                            numer = sum([z[stat['numerator']] for z in tmp if None not in [z[stat['denominator']], z[stat['numerator']]]])

                                        # Assist to turnover ratio should be considered positive (i.e. infinite) if the player has assists but no turnovers
                                        if stat['stat'] == "assist_to_turnover_ratio" and numer > 0 and denom == 0:  
                                            d['is_infinite'] = 1
                                            
                                        d['val'] = None if denom == 0 else numer/denom

                                    if d['val'] is not None or d['is_infinite']:
                                        game_results.append(d)
                                        if d['val'] not in unique_vals and d['val'] is not None:
                                            unique_vals.append(d['val'])

                            if len(unique_vals) > 0:
                                unique_vals = sorted(unique_vals)
                            

                            n = len(unique_vals)
                            for inc in range(0, n-1):
                                d = {'is_whole_team': 1, 'fmt': stat['fmt'], 'st': stat['stat'], 'stdesc': stat['description'], 'lv': unique_vals[inc], 'hv': unique_vals[inc+1], 'gr': grouping['desc'], 'vr': variant['tag']}
                                tmp_low = [z for z in game_results if not z['is_infinite'] and z['val'] <= unique_vals[inc]]
                                d['low_wins'] = sum([z['win'] for z in tmp_low])
                                d['low_n'] = sum([1. for z in tmp_low])
                                d['low_opp_team_IDs'] = [z['opp_team_ID'] for z in tmp_low]
                                d['low_opp_team_IDs_wins'] = [z['opp_team_ID'] for z in tmp_low if z['win']]
                                d['low_opp_team_IDs_losses'] = [z['opp_team_ID'] for z in tmp_low if not z['win']]
                                if split['unit'] == "offense":
                                    d['subject_team_low_record'] = "%d - %d" % (d['low_wins'], d['low_n'] - d['low_wins'])
                                else:
                                    d['subject_team_low_record'] = "%d - %d" % (d['low_n'] - d['low_wins'], d['low_wins'])
                                d['low_wp'] = d['low_wins'] / d['low_n']
                                d['low_possessions'] = sum([z['possessions'] for z in tmp_low])
                                d['low_goals'] = sum([z['goals'] for z in tmp_low])
                                d['low_efficiency'] = d['low_goals'] / d['low_possessions']
                                if use_adjusted_stats:
                                    d['low_adjusted_goals'] = sum([z['adjusted_goals'] for z in tmp_low])
                                    d['low_adjusted_efficiency'] = d['low_adjusted_goals'] / d['low_possessions']
                                    
                                tmp_high = [z for z in game_results if z['is_infinite'] or z['val'] >= unique_vals[inc+1]]
                                d['high_wins'] = sum([z['win'] for z in tmp_high])
                                d['high_n'] = sum([1. for z in tmp_high])
                                d['high_opp_team_IDs'] = [z['opp_team_ID'] for z in tmp_high]
                                d['high_opp_team_IDs_wins'] = [z['opp_team_ID'] for z in tmp_high if z['win']]
                                d['high_opp_team_IDs_losses'] = [z['opp_team_ID'] for z in tmp_high if not z['win']]
                                if split['unit'] == "offense":
                                    d['subject_team_high_record'] = "%d - %d" % (d['high_wins'], d['high_n'] - d['high_wins'])
                                else:
                                    d['subject_team_high_record'] = "%d - %d" % (d['high_n'] - d['high_wins'], d['high_wins'])
                                d['high_wp'] = d['high_wins'] / d['high_n']
                                d['high_possessions'] = sum([z['possessions'] for z in tmp_high])
                                d['high_goals'] = sum([z['goals'] for z in tmp_high])
                                d['high_efficiency'] = d['high_goals'] / d['high_possessions']
                                if use_adjusted_stats:
                                    d['high_adjusted_goals'] = sum([z['adjusted_goals'] for z in tmp_high])
                                    d['high_adjusted_efficiency'] = d['high_adjusted_goals'] / d['high_possessions']
                                
                                d['diff_wp'] = (d['high_wp']) - (d['low_wp'])
                                d['diff_efficiency'] = (d['high_efficiency']) - (d['low_efficiency'])
                                if use_adjusted_stats:
                                    d['diff_adjusted_efficiency'] = (d['high_adjusted_efficiency']) - (d['low_adjusted_efficiency'])
                                
                                d['composite_diff'] = d['diff_efficiency'] + d['diff_wp'] / 5.
                                
                                if use_adjusted_stats:
                                    d['composite_adjusted_diff'] = d['diff_adjusted_efficiency'] + d['diff_wp'] / 5.
                                
                                d['full_hash'] = "%s|%s|%.02f" % (d['gr'], d['vr'], d['composite_adjusted_diff'])
                                d['player_hash'] = "%s|%s|%s" % (stat['stat'], d['gr'], d['vr'])
                                d['hash_seq'] = len([1 for z in split['splits'] if z['full_hash'] == d['full_hash']]) + 1
                                #print "what is the win percentage when the %s %s %s is less than (or equal to) %.3f (n=%d) vs when it is more than (or equal to) %.3f (n=%d): %.3f vs %.3f (diff = %.3f)" % (grouping['desc'], variant['tag'], stat['stat'], unique_vals[inc], d['low_n'], unique_vals[inc+1], d['high_n'], d['low_wp'], d['high_wp'], d['diff_wp'])
                                #print "what is the efficiency when the %s %s %s is less than (or equal to) %.3f (n=%d) vs when it is more than (or equal to) %.3f (n=%d): %.3f vs %.3f (diff = %.3f)\n" % (grouping['desc'], variant['tag'], stat['stat'], unique_vals[inc], d['low_n'], unique_vals[inc+1], d['high_n'], d['low_efficiency'], d['high_efficiency'], d['diff_efficiency'])
                                
                                keep_keys = ['fmt', 'high_n', 'full_hash','player_hash', 'hash_seq', 'low_adjusted_efficiency', 'high_goals', 'low_adjusted_goals', 'high_wp', 'diff_adjusted_efficiency', 'hv', 'low_possessions', 'high_wins', 'high_adjusted_goals', 'lv', 'low_goals', 'low_wp', 'diff_wp', 'high_opp_team_IDs', 'low_opp_team_IDs', 'high_opp_team_IDs_wins', 'low_opp_team_IDs_wins', 'high_opp_team_IDs_losses', 'low_opp_team_IDs_losses', 'st', 'stdesc', 'composite_adjusted_diff', 'low_wins', 'diff_efficiency', 'vr', 'high_efficiency', 'composite_diff', 'low_n', 'high_adjusted_efficiency', 'high_possessions', 'low_efficiency', 'gr', 'subject_team_low_record', 'subject_team_high_record']
                                d_ = {}
                                for key in keep_keys:
                                    d_[key] = d[key]
                                split['splits'].append(d_)
                                #if d['hv'] == 27:
                                #    zc.print_dict(d)
                                #    zc.exit("HIGH 27")
                                    
        
            split['splits'] = sorted(split['splits'], key=lambda x:x['composite_adjusted_diff'], reverse=True)
            #split['splits'] = [z for z in split['splits'] if z['low_n'] >= 2 and z['high_n'] >= 2]
            split['splits'] = [z for z in split['splits'] if z['low_n']/games_this_year >= .25 and z['high_n']/games_this_year >= .25]
            unique_player_hashes = list(set([z['player_hash'] for z in split['splits']]))
            for u in unique_player_hashes:
                tmps = sorted([z for z in split['splits'] if z['player_hash'] == u], key=lambda x:x['composite_adjusted_diff'], reverse=True)
                for i, t in enumerate(tmps):
                    t['hash_rank'] = i + 1
                
            
            if '--keep-all-player-outcome-splits' not in sys.argv:
                split['splits'] = [z for z in split['splits'] if z['hash_rank'] == 1 and z['hash_seq'] == 1]
                
            focus_splits = split['splits'][0:100]
            
            for s in focus_splits:
                s['keep'] = 1
                s['game_subset'] = gv['label']
                s['vrl'] = s['vr'] if s['vr'] is not None else ""
                if s['gr'] == "Player Grouping":
                    
                    
                    #if s['vr'] in [z['ID'] for z in player_groupings]:
                    #    tmp = player_groupings[ [z['ID'] for z in player_groupings].index(s['vr']) ]
                    #    s['vrl'] = tmp['unit_grouping']
                    #    if tmp['unit'] != "offense":
                    #        s['keep'] = 0
                    if s['vr'] == "A":
                        s['vrl'] = "Attack"
                    elif s['vr'] == "M":
                        s['vrl'] = "Midfield"
                    else:
                        s['vrl'] = "Unknown"
                        s['keep'] = 0
                    
                elif s['gr'] == "Ind. Players":
                    if s['vr'] in [z['player_ID'] for z in all_players]:
                        tmp = all_players[ [z['player_ID'] for z in all_players].index(s['vr']) ]
                        s['vrl'] = tmp['player']
                        if 'team_play_shares' in tmp:
                            s['team_play_shares'] = tmp['team_play_shares']
                            if tmp['team_play_shares'] is None or tmp['team_play_shares'] < .04:
                                s['keep'] = 0
                        
                    elif s['vr'] in [z['player_ID'] for z in last_year_players]:
                        s['vrl'] = last_year_players[ [z['player_ID'] for z in last_year_players].index(s['vr']) ]['player']
                        s['vrl'] = last_year_players[ [z['player_ID'] for z in last_year_players].index(s['vr']) ]['player']
                elif s['gr'] == "Player Persona":
                    if s['vr'] == "has_highest_weighted_team_play_shares":
                        s['vrl'] = "Field General"
                    elif s['vr'] == "has_highest_shots":
                        s['vrl'] = "Volume Shooter"
                    elif s['vr'] == "has_highest_goals":
                        s['vrl'] = "Leading Goal-Scorer"
                    elif s['vr'] == "has_highest_points":
                        s['vrl'] = "Leading Point-Scorer"
                    elif s['vr'] == "has_highest_turnover_rate":
                        s['vrl'] = "Most Turnover-Prone"
                    elif s['vr'] == "has_highest_share_of_team_assists":
                        s['vrl'] = "Primary Distributor"
                    elif s['vr'] == "is_primary_fogo":
                        s['vrl'] = "Primary FOGO"
                    elif s['vr'] == "":
                        s['vrl'] = ""
            
            
            focus_splits = [z for z in focus_splits if z['keep']][0:40]  

            
            
            
            
            
            if debug: 
                print ("{:<50}{:<20}{:<50}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>15}{:>7}{:>10}".format("Stat", "Grouping", "Variant", "Low Stat", "Low n", "Low Rec", "Low aEff", "High Stat", "High n", "High Rec", "High aEff", "wpDiff", "adjEffDiff", "AdjComposite", 'Seq', 'hashRank'))
                print ("-" * 275)
                print (("\n".join(["{:<50}{:<20}{:<50}{:>12.3f}{:>12.0f}{:>12}{:>12.3f}{:>12.3f}{:>12.0f}{:>12}{:>12.3f}{:>12.3f}{:>12.3f}{:>15.3f}{:>7}{:>10}".format(z['st'], z['gr'], z['vrl'], z['lv'], z['low_n'], z['subject_team_low_record'], z['low_adjusted_efficiency'], z['hv'], z['high_n'], z['subject_team_high_record'], z['high_adjusted_efficiency'], z['diff_wp'], z['diff_adjusted_efficiency'], z['composite_adjusted_diff'], z['hash_seq'], z['hash_rank']) for z in focus_splits])))
                

            split['top_splits'] = focus_splits[0:40]
            split['splits'] = None
     
    src = os.path.join(lr_fldr, "Logs", "PlayerOutcomeSplits", "team%04d_%d.json" % (team_rec['ID'], specs['year']))
    f = open(src, 'w')
    f.write(json.dumps(team_rec['player_outcome_splits']))
    f.close()
    
    end_ms = time.time()
    if debug: 
        print ("For one team it took {:.3f}s (final size in chars: {:,})" .format (end_ms - start_ms, len(str(team_rec['player_outcome_splits']))))
    #if debug: 
    #   zc.exit("laxref0006")
    return team_rec

def build_team_outcome_splits(player_groupings, all_statistics, player_summaries, team_summaries, all_players, last_year_players, team_rec, specs):
    start_ms = time.time()
    team_rec['team_outcome_splits'] = {}
    
    game_versions = [{'label': 'All Games', 'key': 'team_outcome_splits_all', 'game_filter': (lambda x:1) }
    , {'label': 'Conf Games', 'key': 'team_outcome_splits_conf_only', 'game_filter': (lambda x:x['is_conference']) }
    , {'label': 'Non-Conf Games', 'key': 'team_outcome_splits_nonconf_only', 'game_filter': (lambda x:not x['is_conference']) }
    , {'label': 'Peer Games', 'key': 'team_outcome_splits_peer_only', 'game_filter': (lambda x:(x['is_peer'])) }
    , {'label': 'Non-Peer Games', 'key': 'team_outcome_splits_nonpeer_only', 'game_filter': (lambda x:(not x['is_peer'])) }]
    #game_versions = game_versions[1:2]
    #game_versions = game_versions[0:1]
    
    debug = '--debug-team-outcome-split' in sys.argv
    team_rec['team_outcome_splits']['summary'] = {'n_games': None}
    for gv in game_versions:
        team_rec['team_outcome_splits'][gv['key']] = []
        sp = team_rec['team_outcome_splits'][gv['key']]
        sp.append({'unit': 'offense', 'my_team': 1, 'splits': []})
        sp.append({'unit': 'defense', 'my_team': 0, 'splits': []})
        
        
        all_stats = [z for z in all_statistics if z['stat'] in ['shooting_pct', 'shots_per_possession', 'sog_rate', 'assist_rate', 'assist_to_turnover_ratio', 'possessions']]
        all_stats.append({"stat": "ball_security", "description": "Ball Security", "fmt": "{:.0f}%"})

        
        
        groupings = []
        groupings.append({'seq': 0, 'skip_offense': 0, 'skip_defense': 0, 'team': 1, 'desc': 'Team as a Whole'})
        
        for i, split in enumerate(sp):
            
            stats = [z for z in all_stats]
            
        
            if debug: print ("\n\n%s: %s (%s)\n" % (team_rec['display_name'], split['unit'].upper(), gv['label']))
            if split['my_team']:
                #player_games = [z for z in player_summaries if z['team_ID'] == team_rec['ID']]
                team_games = [z for z in team_summaries if z['team_ID'] == team_rec['ID'] and z['filter'] is None and z['data_type'] == "offense"]
            else:
                #player_games = [z for z in player_summaries if z['opp_team_ID'] == team_rec['ID']]
                team_games = [z for z in team_summaries if z['opp_team_ID'] == team_rec['ID'] and z['filter'] is None and z['data_type'] == "offense"]
            tmp_groupings = [z for z in groupings if (split['unit'] == "offense" and not z['skip_offense']) or (split['unit'] == "defense" and not z['skip_defense'])]
            
            #print "There are {:,} player game records".format(len(player_games))    
            for grouping in tmp_groupings:
                #print "Grouping: %s" % grouping['desc']
                if grouping['team']:
                    grouping['variants'] = [{'grouping_type': grouping['desc'], 'tag': None}]   
                    for v in grouping['variants']:
                        v['player_games'] = [z for z in team_games]
                    
                    #zc.print_dict(grouping['variants'])
                    if debug:
                        print ("There are %d variants" % len(grouping['variants']))
                        print ("\n".join(["{:<50}{:>15,}".format("" if z['tag'] is None else z['tag'], len(z['player_games'])) for z in grouping['variants']]))
                
                    
            games = [z for z in team_summaries if z['this_year'] and z['filter'] is None and z['data_type'] == "offense" and z['my_team'] == split['my_team'] and gv['game_filter'](z)]
            games_this_year = sum([1. for z in games])
            if split['my_team'] and gv['key'] == "team_outcome_splits_peer_only":
                #player_games = [z for z in player_summaries if z['team_ID'] == team_rec['ID']]
                team_games = [z for z in team_summaries if z['team_ID'] == team_rec['ID'] and z['filter'] is None and z['data_type'] == "offense"]
                if team_rec['team_outcome_splits']['summary']['n_games'] is None or team_rec['team_outcome_splits']['summary']['n_games'] < games_this_year:
                    team_rec['team_outcome_splits']['summary']['n_games'] = games_this_year
                    team_rec['team_outcome_splits']['summary']['n_wins'] = sum([z['win'] for z in games])
                    team_rec['team_outcome_splits']['summary']['n_losses'] = team_rec['team_outcome_splits']['summary']['n_games'] - team_rec['team_outcome_splits']['summary']['n_wins']
 
                    
            
            #zc.print_dict(games[0])
            if debug: 
                print ("Games\n-------------------------------------------------------------------------------------------------")
                print ("{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}".format("This Year", "Last Year", "Team ID", "Opp ID", "Win?", "Goals", "Eff", "Adj", "AdjEff"))
                
                
            tmp_unknowns = []
            use_adjusted_stats = 1
            for j, stat in enumerate(stats):
                #print ("stat: %s" % stat['stat'])
                # Loop through each stat in question and go from the min val to the max value to find the win pct split above and beyond the points in question (with a buffer range if needed)
                for k, grouping in enumerate(tmp_groupings):
                        
                    process_stat = 1
                    #if grouping['team'] and 'team' not in stat['relevant_subjects']:
                    #    process_stat = 0
                    #elif not grouping['team'] and 'player' not in stat['relevant_subjects']:
                    #    process_stat = 0
                        
                    if process_stat:
                        #print  ("  grouping: %s" % grouping['desc'])
                        for l, variant in enumerate(grouping['variants']):
                            
                            game_results = []
                            unique_vals = []
                            for g in games:
                                g['has_adjustment_data'] = 0
                                d = {'win': g['win'], 'opp_team_ID': g['opp_team_ID'] if split['my_team'] else g['team_ID'], 'goals': g['goals'], 'possessions': g['possessions']}
                                if split['unit'] == "defense":
                                    d['efficiency_adjustment'] = g['opp_efficiency_adjustment']
                                    
                                else:
                                    tmp = [z for z in g['game_stat_adjustments'] if z['stat_ID'] == 1]
                                    d['efficiency_adjustment'] = None
                                    if len(tmp) > 0:
                                        d['efficiency_adjustment'] = tmp[0]['adjustment']
                                #print ("  d['efficiency_adjustment'] is not None: %s" % (d['efficiency_adjustment'] is not None))
                                if d['efficiency_adjustment'] is not None:
                                    if debug and j + k + l == 0:
                                        print ("{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10.3f}{:<10.3f}{:<10.3f}".format(g['this_year'], g['last_year'], g['team_ID'], g['opp_team_ID'], g['win'], g['goals'], g['efficiency'], d['efficiency_adjustment'], g['efficiency'] + d['efficiency_adjustment']))
                                    #d['efficiency'] = g['goals']/g['possessions']                            
                                    d['adjusted_goals'] = None
                                    #d['adjusted_efficiency'] = None; d['adjusted_efficiency_alt'] = None
                                    
                                    if d['efficiency_adjustment'] is not None:
                                        d['adjusted_goals'] = d['goals'] + d['efficiency_adjustment'] * d['possessions']
                                    else:
                                        
                                        use_adjusted_stats = 0
                                    tmp = [z for z in variant['player_games'] if z['game_ID'] == g['game_ID']][0]
                                    
                                    
                    
                                    d['val'] = None
                                    if len(tmp) > 0:
                                        if stat['stat'] == "shooting_efficiency":
                                            if tmp['shots'] > 0:
                                                d['val'] = tmp['shooting_EGA'] / tmp['shots']
                                        elif stat['stat'] == "possessions":
                                            d['val'] = tmp['possessions']
                                        elif stat['stat'] == "assist_rate":
                                            if tmp['goals'] > 0:
                                                d['val'] = tmp['assists'] / tmp['goals']
                                        elif stat['stat'] == "sog_rate":
                                            if tmp['shots'] > 0:
                                                d['val'] = tmp['sog'] / tmp['shots']
                                        elif stat['stat'] == "assist_to_turnover_ratio":
                                            if tmp['turnovers'] > 0:
                                                d['val'] = tmp['assists'] / tmp['turnovers']
                                        elif stat['stat'] == "shots_per_possession":
                                            if tmp['possessions'] > 0:
                                                d['val'] = tmp['shots'] / tmp['possessions']
                                        elif stat['stat'] == "ball_security":
                                            if tmp['possessions'] > 0:
                                                d['val'] = 1.0 - (tmp['turnovers'] / tmp['possessions'])
                                        elif stat['stat'] == "turnover_rate":
                                            if tmp['possessions'] > 0:
                                                d['val'] = tmp['turnovers'] / tmp['possessions']
                                        elif stat['stat'] == "shooting_pct":
                                            if tmp['shots'] > 0:
                                                d['val'] = tmp['goals'] / tmp['shots']
                                        else:
                                            if stat['stat'] not in tmp_unknowns:
                                                tmp_unknowns.append(stat['stat'])
                                                input("Unknown stat: %s" % stat['stat'])
                                       

                                    if d['val'] is not None:
                                        #if stat['stat'] == "ball_security":
                                        #    print (" %s: %.3f" % (stat['stat'], d['val']))
                                        game_results.append(d)
                                        if d['val'] not in unique_vals:
                                            unique_vals.append(d['val'])

                            if len(unique_vals) > 0:
                                unique_vals = sorted(unique_vals)
                            

                            n = len(unique_vals)
                            #print ("    variant: %s (%d game rows); unique vals = %d" % ("N/A" if variant['tag'] is None else variant['tag'], len(variant['player_games']), len(unique_vals)))
                            for inc in range(0, n-1):
                                d = {'is_whole_team': 1, 'fmt': stat['fmt'], 'st': stat['stat'], 'stdesc': stat['description'], 'lv': unique_vals[inc], 'hv': unique_vals[inc+1], 'gr': grouping['desc'], 'vr': variant['tag']}
                                tmp_low = [z for z in game_results if z['val'] <= unique_vals[inc]]
                                d['low_wins'] = sum([z['win'] for z in tmp_low])
                                d['low_n'] = sum([1. for z in tmp_low])
                                d['low_opp_team_IDs'] = [z['opp_team_ID'] for z in tmp_low]
                                d['low_opp_team_IDs_wins'] = [z['opp_team_ID'] for z in tmp_low if z['win']]
                                d['low_opp_team_IDs_losses'] = [z['opp_team_ID'] for z in tmp_low if not z['win']]
                                if split['unit'] == "offense":
                                    d['subject_team_low_record'] = "%d - %d" % (d['low_wins'], d['low_n'] - d['low_wins'])
                                else:
                                    d['subject_team_low_record'] = "%d - %d" % (d['low_n'] - d['low_wins'], d['low_wins'])
                                d['low_wp'] = d['low_wins'] / d['low_n']
                                d['low_possessions'] = sum([z['possessions'] for z in tmp_low])
                                d['low_goals'] = sum([z['goals'] for z in tmp_low])
                                d['low_efficiency'] = d['low_goals'] / d['low_possessions']
                                if use_adjusted_stats:
                                    d['low_adjusted_goals'] = sum([z['adjusted_goals'] for z in tmp_low])
                                    d['low_adjusted_efficiency'] = d['low_adjusted_goals'] / d['low_possessions']
                                    
                                tmp_high = [z for z in game_results if z['val'] >= unique_vals[inc+1]]
                                d['high_wins'] = sum([z['win'] for z in tmp_high])
                                d['high_n'] = sum([1. for z in tmp_high])
                                d['high_opp_team_IDs'] = [z['opp_team_ID'] for z in tmp_high]
                                d['high_opp_team_IDs_wins'] = [z['opp_team_ID'] for z in tmp_high if z['win']]
                                d['high_opp_team_IDs_losses'] = [z['opp_team_ID'] for z in tmp_high if not z['win']]
                                if split['unit'] == "offense":
                                    d['subject_team_high_record'] = "%d - %d" % (d['high_wins'], d['high_n'] - d['high_wins'])
                                else:
                                    d['subject_team_high_record'] = "%d - %d" % (d['high_n'] - d['high_wins'], d['high_wins'])
                                d['high_wp'] = d['high_wins'] / d['high_n']
                                d['high_possessions'] = sum([z['possessions'] for z in tmp_high])
                                d['high_goals'] = sum([z['goals'] for z in tmp_high])
                                d['high_efficiency'] = d['high_goals'] / d['high_possessions']
                                if use_adjusted_stats:
                                    d['high_adjusted_goals'] = sum([z['adjusted_goals'] for z in tmp_high])
                                    d['high_adjusted_efficiency'] = d['high_adjusted_goals'] / d['high_possessions']
                                
                                d['diff_wp'] = (d['high_wp']) - (d['low_wp'])
                                d['diff_efficiency'] = (d['high_efficiency']) - (d['low_efficiency'])
                                if use_adjusted_stats:
                                    d['diff_adjusted_efficiency'] = (d['high_adjusted_efficiency']) - (d['low_adjusted_efficiency'])
                                
                                d['composite_diff'] = d['diff_efficiency'] + d['diff_wp'] / 5.
                                
                                if use_adjusted_stats:
                                    d['composite_adjusted_diff'] = d['diff_adjusted_efficiency'] + d['diff_wp'] / 5.
                                
                                d['full_hash'] = "%s|%s|%.02f" % (d['gr'], d['vr'], d['composite_adjusted_diff'])
                                d['player_hash'] = "%s|%s|%s" % (stat['stat'], d['gr'], d['vr'])
                                d['hash_seq'] = len([1 for z in split['splits'] if z['full_hash'] == d['full_hash']]) + 1
                                #print "what is the win percentage when the %s %s %s is less than (or equal to) %.3f (n=%d) vs when it is more than (or equal to) %.3f (n=%d): %.3f vs %.3f (diff = %.3f)" % (grouping['desc'], variant['tag'], stat['stat'], unique_vals[inc], d['low_n'], unique_vals[inc+1], d['high_n'], d['low_wp'], d['high_wp'], d['diff_wp'])
                                #print "what is the efficiency when the %s %s %s is less than (or equal to) %.3f (n=%d) vs when it is more than (or equal to) %.3f (n=%d): %.3f vs %.3f (diff = %.3f)\n" % (grouping['desc'], variant['tag'], stat['stat'], unique_vals[inc], d['low_n'], unique_vals[inc+1], d['high_n'], d['low_efficiency'], d['high_efficiency'], d['diff_efficiency'])
                                
                                keep_keys = ['fmt', 'high_n', 'full_hash','player_hash', 'hash_seq', 'low_adjusted_efficiency', 'high_goals', 'low_adjusted_goals', 'high_wp', 'diff_adjusted_efficiency', 'hv', 'low_possessions', 'high_wins', 'high_adjusted_goals', 'lv', 'low_goals', 'low_wp', 'diff_wp', 'st', 'high_opp_team_IDs', 'low_opp_team_IDs', 'high_opp_team_IDs_wins', 'low_opp_team_IDs_wins', 'high_opp_team_IDs_losses', 'low_opp_team_IDs_losses', 'stdesc', 'composite_adjusted_diff', 'low_wins', 'diff_efficiency', 'vr', 'high_efficiency', 'composite_diff', 'low_n', 'high_adjusted_efficiency', 'high_possessions', 'low_efficiency', 'gr', 'subject_team_low_record', 'subject_team_high_record']
                                d_ = {}
                                for key in keep_keys:
                                    d_[key] = d[key]
                                split['splits'].append(d_)
                       
        
            split['splits'] = sorted(split['splits'], key=lambda x:x['composite_adjusted_diff'], reverse=True)
            # Keep only splits that have at least a quarter of the games on both sides
            split['splits'] = [z for z in split['splits'] if z['low_n']/games_this_year >= .25 and z['high_n']/games_this_year >= .25]
            
            # Keep the splits where the efficiency is actual worse (for the offense) when the value is lower
            split['splits'] = [z for z in split['splits'] if z['low_adjusted_efficiency'] < z['high_adjusted_efficiency']]
                
            unique_player_hashes = list(set([z['player_hash'] for z in split['splits']]))
            for u in unique_player_hashes:
                tmps = sorted([z for z in split['splits'] if z['player_hash'] == u], key=lambda x:x['composite_adjusted_diff'], reverse=True)
                for i, t in enumerate(tmps):
                    t['hash_rank'] = i + 1
                
            
            if '--keep-all-team-outcome-splits' not in sys.argv:
                split['splits'] = [z for z in split['splits'] if z['hash_rank'] == 1 and z['hash_seq'] == 1]
                
            focus_splits = split['splits'][0:100]
            
            for s in focus_splits:
                s['keep'] = 1
                s['game_subset'] = gv['label']
                s['vrl'] = s['vr'] if s['vr'] is not None else ""
                
            
            focus_splits = [z for z in focus_splits if z['keep']][0:40]  

            if debug: 
                print ("{:<30}{:<20}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>12}{:>15}{:>7}{:>10}".format("Stat", "Grouping", "Low Stat", "Low n", "Low Rec", "Low aEff", "High Stat", "High n", "High Rec", "High aEff", "wpDiff", "adjEffDiff", "AdjComposite", 'Seq', 'hashRank'))
                print ("-" * 200)
                print (("\n".join(["{:<30}{:<20}{:>12.3f}{:>12.0f}{:>12}{:>12.3f}{:>12.3f}{:>12.0f}{:>12}{:>12.3f}{:>12.3f}{:>12.3f}{:>15.3f}{:>7}{:>10}".format(z['st'], z['gr'], z['lv'], z['low_n'], z['subject_team_low_record'], z['low_adjusted_efficiency'], z['hv'], z['high_n'], z['subject_team_high_record'], z['high_adjusted_efficiency'], z['diff_wp'], z['diff_adjusted_efficiency'], z['composite_adjusted_diff'], z['hash_seq'], z['hash_rank']) for z in focus_splits])))
                

            split['top_splits'] = focus_splits[0:40]
            split['splits'] = None
    
    src = os.path.join(lr_fldr, "Logs", "TeamOutcomeSplits", "team%04d_%d.json" % (team_rec['ID'], specs['year']))
    f = open(src, 'w')
    f.write(json.dumps(team_rec['team_outcome_splits']))
    f.close()
    
    end_ms = time.time()
    if debug: 
        print ("For one team it took {:.3f}s (final size in chars: {:,})" .format (end_ms - start_ms, len(str(team_rec['player_outcome_splits']))))
    if debug: 
        zc.exit("laxref00061")
    return team_rec

def build_stats_faceoffs(fogos, team_players, all_faceoffs, team_rec, primary_fogos_by_team, specs):
    team_rec['fogos'] = [z for z in fogos if z['team_ID'] == team_rec['ID']]
    total_fos = sum([z['total_FOs'] for z in team_rec['fogos'] if z['total_FOs'] is not None])
    for f in team_rec['fogos']:
        f['pct_of_total'] = None if f['total_FOs'] in [None, 0] else f['total_FOs'] / total_fos
        f['display'] = 1 if (f['pct_of_total'] is not None and f['pct_of_total'] > .05) else 0

    
        
    team_rec['fogo_splits'] = []

    my_fos = [z for z in all_faceoffs if team_rec['ID'] in [z['team_ID'], z['opp_team_ID']] and z['year'] == specs['year']]
    if '--debug-fos' in sys.argv and team_rec['ID'] == 819:
        zc.exit("Found {:,} faceoffs in my_fos".format(len(my_fos)))
    
    for f in my_fos:
        f['won'] = 1. if f['team_ID'] == team_rec['ID'] else 0
        
        f['winning'] = 0
        if f['won'] and f['game_state'] > 0: f['winning'] = 1
        if not f['won'] and f['game_state'] < 0: f['winning'] = 1

        if f['team_ID'] not in primary_fogos_by_team:
            msg = "[Fatal primary_fogos_by_team] In build_stats_faceoffs, team_ID %s was not in the primary_fogos_by_team object" % f['team_ID']
            msg += "\n\nPreviously, this issue was caused because a game against an NAIA team was getting into the faceoffs data. The problem was resolved by changing the query to exclude faceoffs from non-division games."
                            
            #msg += get_game_crash_info(lg)
            zc.send_crash(msg, bot_token)
            print (msg)
            zc.exit("Missing FOGOs")
        
        f['won_by_primary_draw_taker'] = 1 if f['winner_ID'] == primary_fogos_by_team[f['team_ID']] else 0
        
    if "Women" in team_rec['league']:
        n_wins = sum([1. for z in my_fos if z['won']])
        n_total = sum([1. for z in my_fos])
        team_rec['draw_winners'] = [z for z in team_players if z['faceoff_wins'] not in [None, 0]]
        for p in team_rec['draw_winners']:
            p['wins'] = p['faceoff_wins']
            p['pct_of_team_wins'] = None if n_wins == 0 else (p['wins'] / n_wins)
            p['pct_of_draws'] = None if n_total == 0 else (p['wins'] / n_total)
            if n_wins == 0:
                msg = "How does team ID %d have n_wins==0 when a player has more than 0 wins?\n\n%s" % (team_rec['ID'], zc.print_dict(p))
                zc.send_telegram(msg, bot_token)
        
    sp = {'tag': 'winning', 'seq': len(team_rec['fogo_splits']), 'header': 'Winning/Losing', 'options': []}
    sp['options'].append({'label': 'Ahead', 'd': lambda x: sum([1. for z in x if z['winning']]), 'n': lambda x: sum([1. for z in x if z['won'] and z['winning']]) })
    sp['options'].append({'label': 'Tied', 'd': lambda x: sum([1. for z in x if z['game_state'] == 0]), 'n': lambda x: sum([1. for z in x if z['won'] and z['game_state'] == 0]) })
    sp['options'].append({'label': 'Losing', 'd': lambda x: sum([1. for z in x if not z['winning']]), 'n': lambda x: sum([1. for z in x if z['won'] and not z['winning']]) })
    team_rec['fogo_splits'].append(sp)

    sp = {'tag': 'following', 'seq': len(team_rec['fogo_splits']), 'header': 'Following', 'options': []}
    sp['options'].append({'label': 'Our Goal', 'd': lambda x: sum([1. for z in x if z['following'] == "myGoal"]), 'n': lambda x: sum([1. for z in x if z['won'] and z['following'] == "myGoal"]) })
    sp['options'].append({'label': 'Their Goal', 'd': lambda x: sum([1. for z in x if z['following'] == "theirGoal"]), 'n': lambda x: sum([1. for z in x if z['won'] and z['following'] == "theirGoal"]) })
    sp['options'].append({'label': 'Other', 'd': lambda x: sum([1. for z in x if z['following'] not in ['theirGoal', "myGoal"]]), 'n': lambda x: sum([1. for z in x if z['won'] and z['following'] not in ['theirGoal', "myGoal"]]) })
    team_rec['fogo_splits'].append(sp)

    sp = {'tag': 'fogo_pickup', 'seq': len(team_rec['fogo_splits']), 'header': 'FOGO Pickup', 'options': []}
    sp['options'].append({'label': 'FOGO Pickup', 'd': lambda x: sum([1. for z in x if z['picked_up_by_ID'] is None]), 'n': lambda x: sum([1. for z in x if z['won'] and z['picked_up_by_ID'] is None]) })
    sp['options'].append({'label': 'Other GB', 'd': lambda x: sum([1. for z in x if z['picked_up_by_ID'] is not None]), 'n': lambda x: sum([1. for z in x if z['won'] and z['picked_up_by_ID'] is not None]) })
    team_rec['fogo_splits'].append(sp)

    sp = {'tag': 'primary_taker', 'seq': len(team_rec['fogo_splits']), 'header': 'Primary Win', 'options': []}
    sp['options'].append({'label': 'Primary Win', 'd': lambda x: sum([1. for z in x if z['won_by_primary_draw_taker']]), 'n': lambda x: sum([1. for z in x if z['won'] and z['won_by_primary_draw_taker']]) })
    sp['options'].append({'label': 'Other Win', 'd': lambda x: sum([1. for z in x if not z['won_by_primary_draw_taker']]), 'n': lambda x: sum([1. for z in x if z['won'] and not z['won_by_primary_draw_taker']]) })
    team_rec['fogo_splits'].append(sp)

    sp = {'tag': 'violation', 'seq': len(team_rec['fogo_splits']), 'header': 'Win on Violation', 'options': []}
    sp['options'].append({'label': 'Violation', 'd': lambda x: sum([1. for z in x if not z['won_on_violation']]), 'n': lambda x: sum([1. for z in x if z['won'] and not z['won_on_violation']]) })
    sp['options'].append({'label': 'No Violation', 'd': lambda x: sum([1. for z in x if z['won_on_violation']]), 'n': lambda x: sum([1. for z in x if z['won'] and z['won_on_violation']]) })
    team_rec['fogo_splits'].append(sp)

    for sp in team_rec['fogo_splits']:
        for o in sp['options']:
            o['cnt'] = o['d'](my_fos)
            o['cnt_str'] = "{:,}".format(int(o['cnt']))
            o['pct'] = None if o['cnt'] == 0 else (o['n'](my_fos) / o['cnt'])
            o['pct_str'] = "N/A" if o['pct'] is None else ("%.1f%%" % (100. * o['pct']))

            o['n'] = ""; o['d'] = ""

    #zc.print_dict(specs)
    src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_faceoff_splits_%d_LRP.json" % (team_rec['ID'], specs['year']))
    f = open(src, 'w'); f.write(json.dumps(team_rec['fogo_splits'])); f.close()
    if "Women" in team_rec['league']:
        src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_draw_winners_%d_LRP.json" % (team_rec['ID'], specs['year']))
        f = open(src, 'w'); f.write(json.dumps(team_rec['draw_winners'])); f.close()
    
    return team_rec

def build_stats_completed_game(gm, game_stat_adjustments, possessions, all_statistics, summaries, keys, player_game_summaries, team_rec, specs):
    lg = gm
    start_ms_tmp = time.time()
    team_player_game_summaries = [z for z in player_game_summaries if z['team_ID'] == team_rec['ID']]
    print ("         {:<30}{:<10.0f}ms elapsed".format("retrieved team_player_game_summaries", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    adjustments = [z for z in game_stat_adjustments if z['game_ID'] == lg['ID'] and z['team_ID'] == team_rec['ID']]
    print ("         {:<30}{:<10.0f}ms elapsed".format("retrieved adjustments", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    full_summaries = [z for z in summaries if z['game_ID'] != gm['ID'] and z['team_ID'] == team_rec['ID'] and z['game_year'] == gm['game_year']]
    print ("         {:<30}{:<10.0f}ms elapsed".format("retrieved full_summaries", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    
    no_filter_summaries = [z for z in full_summaries if z['filter'] is None]
    print ("         {:<30}{:<10.0f}ms elapsed".format("retrieved no_filter_summaries", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    
    units = []
    d = {'tag': 'offense', 'offense': 1, 'stat_keys': ['efficiency', 'gb_win_rate', 'shooting_pct', 'turnover_rate']}
    units.append(d)

    d = {'tag': 'defense', 'offense': 0, 'stat_keys': ['efficiency', 'shooting_pct', 'time_of_possession']}
    units.append(d)

    d = {'tag': 'goalkeepers', 'offense': 1, 'stat_keys': ['save_pct']}
    units.append(d)

    d = {'tag': 'faceoffs', 'offense': 1, 'stat_keys': ['faceoff_win_rate', 'modified_possession_margin']}
    units.append(d)

    positional_units = [{'desc': 'Attack', 'tag': 'A', 'tags': ['A']}, {'desc': 'Midfield/FO', 'tag': 'M', 'tags': ['M', 'FO']}, {'desc': 'Defense/GK', 'tag': 'D', 'tags': ['G', 'D']}, {'desc': 'Not Specified', 'tag': '?', 'tags': [None]}]

    lg['adjusted_performance'] = {}
    lg['positional_breakdown'] = []
    lg['key_stretches'] = []
    lg['situational_splits'] = {}




    stat_keys_for_situation_splits = ['efficiency', 'faceoff_win_rate', 'gb_win_rate', 'modified_possession_margin', 'shooting_pct', 'turnover_rate', 'save_pct']

    stat_keys_for_positional_breakdowns = ['shots', 'sog', 'assists', 'goals', 'turnovers', 'gbs']



    for k in all_statistics:


        if k['stat'] in stat_keys_for_positional_breakdowns:
            d = {'values': [], 'value_share': [], 'js_fmt': k['js_fmt'], 'label': k['description']}
            tot = 0.
            for pos in positional_units:
                player_summaries = [z for z in team_player_game_summaries if z['team_listed_role'] in pos['tags']]
                val = sum([z[k['stat']] for z in player_summaries])
                d['values'].append({'value': val, 'tag': pos['tag']})
                tot += val
            for ip, pos in enumerate(positional_units):
                d['value_share'].append({'tag': pos['tag'], 'value': "N/A" if tot == 0 else d['values'][ip]['value']/tot})
            lg['positional_breakdown'].append(d)

    print ("         {:<30}{:<10.0f}ms elapsed".format("pulled stats by all_statistics", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    
    for tu in units:
        lg['adjusted_performance'][tu['tag']] = []
        lg['situational_splits'][tu['tag']] = []

    # Split stats out by garbage/competitive
    situations = []
    situations.append({'label': 'All', 'tag': 'all', 'spec': lambda x:x['filter'] is None})
    situations.append({'label': 'Garbage Time', 'tag': 'garbage_time', 'spec': lambda x:x['filter'] == "WinProb" and x['filter_val'] == "Competitive"})
    situations.append({'label': 'Competitive', 'tag': 'competitive', 'spec': lambda x:x['filter'] == "WinProb" and x['filter_val'] == "NonCompetitive"})

    for unit in units:

        for k in all_statistics:

            if k['stat'] in unit['stat_keys'] and k['stat'] in stat_keys_for_situation_splits:
                d = {'values': [], 'js_fmt': k['js_fmt'], 'label': k['description']}

                for situation in situations:
                    summary_list = [z for z in lg['summaries'] if situation['spec'](z) and (z['data_type'] == 'offense' and unit['offense']) or (z['data_type'] == 'defense' and not unit['offense'])]
                    if len(summary_list) > 0:
                        summary = summary_list[0]
                        val = summary[k['stat']]
                        if k['stat'] == "time_of_possession":
                            val = "%d:%02d" % ((val*3600)/60, int((val*3600))%60)
                    else:
                        val = None
                    d['values'].append({'value': val, 'tag': situation['tag']})
                lg['situational_splits'][unit['tag']].append(d)

    print ("         {:<30}{:<10.0f}ms elapsed".format("Adjust performance by opponent strength", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    
    # Adjust performance by opponent strength
    for unit in units:
        summary = [z for z in lg['summaries'] if z['filter'] is None and ((z['data_type'] == 'offense' and unit['offense']) or (z['data_type'] == 'defense' and not unit['offense']))]
        if summary != []:

            summary = summary[0]
            for k in all_statistics:

                if k['stat'] in unit['stat_keys']:

                    d = {'js_fmt': k['js_fmt'], 'offensive': unit['offense'], 'trend': "?", 'reverse': k['reverse'], 'label': k['description'], 'raw': summary[k['stat']], 'final': summary[k['stat']], 'stat': k['stat'], 'adjustment': ""}
                    if d['raw'] is None:
                        d['final'] = "N/A"
                        d['adjustment'] = "N/A"
                        d['raw'] = "N/A"
                    else:
                        tmp = [z for z in adjustments if z['stat_ID'] == k['ID'] and unit['offense'] == z['offense']]
                        if len(tmp) == 1:
                            d['adjustment'] = tmp[0]['adjustment']

                        if d['adjustment'] not in ["", None]:
                            d['final'] = d['raw'] + d['adjustment']

                        if k['stat'] == "time_of_possession":
                            d['raw'] = "%d:%02d" % ((d['raw']*3600)/60, int((d['raw']*3600))%60)
                            d['adjustment'] = "" if d['adjustment'] == "" else ("%d:%02d" % ((d['adjustment']*3600)/60, int((d['adjustment']*3600))%60))
                            d['final'] = "%d:%02d" % ((d['final']*3600)/60, int((d['final']*3600))%60)
                    lg['adjusted_performance'][unit['tag']].append(d)

    print ("         {:<30}{:<10.0f}ms elapsed".format("captured raw stats", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    lg = build_game_stretches(team_rec, lg, possessions, specs)

    print ("         {:<30}{:<10.0f}ms elapsed".format("build_game_stretches", 1000*(time.time() - start_ms_tmp))); start_ms_tmp = time.time()
    

    return lg

def build_game_stretches(team_rec, lg, possessions, specs):
    lg['stretches'] = []
    debug = False
    if lg['ID'] == 479075: debug = True
    
    

    if debug: print ("\n\nGame %d\n\n" % lg['ID'])

    extended_data = 1 if 'shots' in specs else 0

    #zc.print_dict(possessions[0:5])
    possessions = sorted([z for z in possessions], key=lambda x:x['start_time'])
    n_poss = float(len(possessions))
    
    team_goals = len([1 for z in possessions if z['team_ID'] == team_rec['ID'] and z['goal']])
    opp_goals = len([1 for z in possessions if z['team_ID'] != team_rec['ID'] and z['goal']])
    team_rec_won = 1 if team_goals > opp_goals else 0
    is_tied = 1 if team_goals == opp_goals else 0
    
    if n_poss > 0:
        if debug: print ("\n\nProcessing %d possessions for split stretches in game %d" % (len(possessions), lg['ID']))
        for ip, p in enumerate(possessions):
            p['seq'] = ip
            p['mine'] = 1 if p['team_ID'] == team_rec['ID'] else 0
            p['my_odds'] = p['team_odds'] if p['mine'] else (1.0 - p['team_odds'])
            p['end_time'] = p['start_time'] + p['duration']
            p['shots'] = None; p['faceoffs'] = None
            if 'shots' in specs:
                #print(sorted(specs['shots'][0].keys()))
                p['shots'] = [{'shooter_ID': z['shooter_ID']
                , 'goalie_ID': z['goalie_ID']
                , 'assister_ID': z['assister_ID']
                , 'goal': z['goal']
                } for z in specs['shots'] if p['team_ID'] == z['team_ID'] and p['start_time'] < z['time_elapsed'] <= p['end_time']]
            if 'faceoffs' in specs:
                #zc.exit(sorted(specs['faceoffs'][0].keys()))
                p['faceoffs'] = [{'winner_ID': z['winner_ID']
                , 'team_ID': z['team_ID']
                , 'picked_up_by_ID': z['picked_up_by_ID']
                , 'loser_ID': z['loser_ID']
                }  for z in specs['faceoffs'] if p['team_ID'] == z['team_ID'] and p['start_time'] < z['time_elapsed'] <= p['end_time']]
        if '--show-stretch-possessions' in sys.argv:
            print ("{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}{:<10}".format("Seq", "TeamID", "Mine", "Start", "End", "TeamOdds", "Start WP", "End WP"))
            print ("-" * 120)
        for ip, p in enumerate(possessions):
            p['my_end_odds'] = None
            if ip < len(possessions) - 1:
                next_p = possessions[ip+1]
                mine = 1 if next_p['team_ID'] == team_rec['ID'] else 0
                p['my_end_odds'] = next_p['team_odds'] if mine else (1.0 - next_p['team_odds'])
                
            else:
                if is_tied or p['end_time'] < 3600:
                    p['my_end_odds'] = p['my_odds']
                else:
                    if team_rec_won:
                        p['my_end_odds'] = 1.0 if p['team_ID'] == team_rec['ID'] else 0.0
                    else:
                        p['my_end_odds'] = 1.0 if p['team_ID'] != team_rec['ID'] else 0.0
            if '--show-stretch-possessions' in sys.argv:
                    print ("{:<10}{:<10}{:<10}{:<10}{:<10}{:<10.3f}{:<10.3f}{:<10.3f}".format(ip+1, p['team_ID'], "Mine=%d" % p['mine']
                    , convert_pct_complete_to_time_str(p['start_time']/3600., lg['game_year'], team_rec['league'])
                    , convert_pct_complete_to_time_str(p['end_time']/3600., lg['game_year'], team_rec['league'])
                    , p['team_odds']
                    , p['my_odds']
                    , p['my_end_odds']
                    ))
        """
        1. Start with quarters; if you can't find anything better to show, just break down performance by quarter
        1a. Find 3 local mins/ local maxs for win probability and show the 4 stretches that way

        1. Start with 3 and go up to 5 local min/max for win probability, the measure of a good split is the sum of the abs difference between the locals
        2. Go up to 5 locals, but only if the increase in variation among the local min/max is worth adding another stretch (i.e. increases the variation by more than a certain amount

        """
        dist_range = 9; min_distance_required = 0; max_distance_allowed = len(possessions)/2
        results = []
        min_maxes = []
        for z in range(2,7):
            min_maxes.append({'best_result': None,  'best_result_list': None, 'n': float(z)})

        for i, min_max in enumerate(min_maxes):
            if debug: print ("{:>30}{}".format(" Min Max with %d stretches" % min_max['n'], ""))
            #dist = min_max['distance']
            split_length = int(n_poss/(min_max['n']+1.0))
            if debug: print ("{:>30}{}".format("   poss lengths are %d" % split_length, ""))

            split_points = [{'results': [], 'midpoint': int((float(z)+.5) * float(split_length)), 'start': z * split_length, 'end': min(len(possessions)-1, (z+1)*split_length)} for z in range(0, int(min_max['n'] + 1.0))]
            if debug: print ("{:>30}{}".format("   which means breaks at %s" % ", ".join([str(z) for z in split_points]), ""))
            for j, s in enumerate(split_points):
                for dist in range(1, dist_range+1):
                    if j == 0:
                        cur_loc = 0
                    elif j == len(split_points)-1:
                        cur_loc = len(possessions)-1
                        
                    else:
                        
                        s['start_win_prob'] = possessions[s['start']]['my_odds']
                        s['end_win_prob'] = possessions[s['end']]['my_odds']
                        s['midpoint_win_prob'] = possessions[s['midpoint']]['my_odds']
                        s['win_prob_change'] = s['end_win_prob'] - s['start_win_prob']
                        if debug: print ("            {:<30}{:<30}".format("midpoint: %d" % s['midpoint'], 'dist: %d' % dist))
                        s['cap_previous_win_prob'] = None; s['cap_next_win_prob'] = None
                        if s['start'] - dist > -1:
                            s['cap_previous_win_prob'] = possessions[s['start'] - dist]['my_odds']
                        if s['end'] + dist < n_poss:
                            s['cap_next_win_prob'] = possessions[s['end'] + dist]['my_odds']

                        if s['midpoint'] - dist < 0 or s['midpoint'] + dist > len(possessions)-1:
                            s['results'].append({'final_loc': None, 'final_odds': None, 'dist': dist})
                            continue
                        s['midpoint_previous_win_prob'] = possessions[s['midpoint'] - dist]['my_odds']
                        s['midpoint_next_win_prob'] = possessions[s['midpoint'] + dist]['my_odds']
                        use_midpoint = True

                        # If this is the first one, check and see whether the change in win prob is steeper going forward or back, pick the steeper one
                        if use_midpoint:
                            s['back_change'] = s['midpoint_win_prob'] - s['midpoint_previous_win_prob']
                            s['ahead_change'] =  s['midpoint_next_win_prob'] - s['midpoint_win_prob']
                            s['abs_back_change'] = abs(s['back_change'])
                            s['abs_ahead_change'] = abs(s['ahead_change'])
                            direction = "back" if s['abs_back_change'] > s['abs_ahead_change'] else "ahead"
                        else:
                            if s['cap_previous_win_prob']  is None: # This is the very beginning of the game
                                direction = "ahead"
                                s['ahead_change'] =  s['cap_next_win_prob'] - s['end_win_prob']

                            elif s['cap_next_win_prob'] is None: # This is the very end of the game
                                direction = "back"
                                s['back_change'] = s['start_win_prob'] - s['cap_previous_win_prob']
                            else:
                                s['back_change'] = s['start_win_prob'] - s['cap_previous_win_prob']
                                s['ahead_change'] =  s['cap_next_win_prob'] - s['end_win_prob']
                                s['abs_back_change'] = abs(s['back_change'])
                                s['abs_ahead_change'] = abs(s['ahead_change'])
                                direction = "back" if s['abs_back_change'] > s['abs_ahead_change'] else "ahead"




                        s['direction'] = direction
                        s['direction_val'] = dist if s['direction'] == "ahead" else (-1*dist)
                        if use_midpoint:
                            s['relevant_odds'] = s['midpoint_win_prob']
                            cur_loc = s['midpoint']
                        else:
                            s['relevant_odds'] = s['start_win_prob'] if s['direction'] == "back" else s['end_win_prob']
                            cur_loc = s['start'] if s['direction'] == "back" else s['end']
                        # Go until the trend stops

                        cur_loc += s['direction_val']
                        #print "{:>30}{}".format("     Relevant odds at pos %d=%.3f" % (cur_loc - s['direction_val'], s['relevant_odds']), "")
                        #print "{:>30}{}".format("     Dir=%s so we are going to start at poss %d" % (s['direction'], cur_loc), "")
                        change = s['relevant_odds'] - possessions[cur_loc]['my_odds']
                        #print "{:>30}{}".format("     Initial change: %.3f - %.3f = %.3f" % (s['relevant_odds'], possessions[cur_loc]['my_odds'], change), "")
                        s['trend'] = -1.0 if s['%s_change' % direction] > 0 else 1.0
                        last = possessions[cur_loc]['my_odds']
                        moves = 0;
                        while change*s['trend'] >= 0 and moves < max_distance_allowed and moves >= min_distance_required:
                            moves += 1
                            cur_loc += s['direction_val']
                            if cur_loc <= -1:

                                break
                            elif cur_loc >= len(possessions):

                                break
                            else:
                                change = last - possessions[cur_loc]['my_odds']
                                #print "{:>30}{}".format("       Subsequent change: %.3f - %.3f = %.3f" % (last, possessions[cur_loc]['my_odds'], change), "")
                                last = possessions[cur_loc]['my_odds']
                                if change*s['trend'] < 0: cur_loc -= s['direction_val']
                        cur_loc = max(min(cur_loc, len(possessions)-1), 0)
                        #print "{:>30}{}".format("     Search has stopped at cur_loc %d\n" % (cur_loc), "")
                    s['results'].append({'final_loc': cur_loc, 'final_odds': possessions[cur_loc]['my_odds'], 'final_start_time': possessions[s['start']]['start_time'], 'final_end_time': possessions[cur_loc]['start_time'] + possessions[cur_loc]['duration'], 'dist': dist})





            abs_diff_sum = 0.
            split_points[-1]['max_final_loc'] = len(possessions)
            split_points[-1]['max_final_odds'] = possessions[-1]['my_odds']
            split_points[-1]['max_final_start_time'] = possessions[split_points[-1]['start']]['start_time']
            split_points[-1]['max_final_end_time'] = possessions[-1]['start_time'] + possessions[-1]['duration']

            for i, s in enumerate(split_points[0:-1]):

                s['max_final_loc'] = None; s['max_final_odds'] = None
                s['max_final_start_time'] = None; s['max_final_end_time'] = None
            for i, s in enumerate(split_points[0:-1]):

                #print "\nSplit Point #%d" % i
                max_diff = None;
                for j in range(dist_range):
                    for k in range(dist_range):
                        if None not in [s['results'][j]['final_odds'], split_points[i+1]['results'][k]['final_odds']]:
                            abs_val = abs(s['results'][j]['final_odds'] - split_points[i+1]['results'][k]['final_odds'])
                            #print "j %d, k %d" % (j, k), s['results'][j]['final_loc'], split_points[i+1]['results'][k]['final_loc'], s['results'][j]['final_loc'] < split_points[i+1]['results'][k]['final_loc']
                            #print "{:<15}{:<10.4f}{:<10.4f}{:<10.4f}{:<10.4f}{:<10.4f}{:>10}{:>10}".format("j: %d,  k: %d" % (j, k), s['results'][j]['final_odds'], s['results'][j]['final_loc'], split_points[i+1]['results'][k]['final_odds'], split_points[i+1]['results'][k]['final_loc'], abs_val, s['results'][j]['final_loc'] < split_points[i+1]['results'][k]['final_loc'], max_diff is None or max_diff < abs_val)
                            if s['results'][j]['final_loc'] < split_points[i+1]['results'][k]['final_loc']:
                                if max_diff is None or max_diff < abs_val:
                                    max_diff = abs_val
                                    s['max_final_loc'] = s['results'][j]['final_loc']
                                    s['max_final_odds'] = s['results'][j]['final_odds']
                                    s['max_final_start_time'] = s['results'][j]['final_start_time']
                                    s['max_final_end_time'] = s['results'][j]['final_end_time']
                                    s['max_final_other_dist'] = i+1
                            #raw_input ("")
                if max_diff is None:
                    #print "\nMax Diff was not set for split point"
                    #zc.print_dict(s)
                    break
                abs_diff_sum += max_diff
                if s['max_final_loc'] is None:
                    s['max_final_loc'] = -1
                    s['max_final_odds'] = -1
                    s['max_final_start_time'] = -1
                    s['max_final_end_time'] = -1
                    s['max_final_other_dist'] = -1

            if debug: print ("Check 1", None not in [z['max_final_loc'] for z in split_points], (min_max['best_result'] is None or min_max['best_result'] < abs_diff_sum))
            #if None not in [z['max_final_loc'] for z in split_points] and (min_max['best_result'] is None or min_max['best_result'] < abs_diff_sum):
            if len([1 for z in split_points if z['max_final_loc'] is not None]) > 0 and (min_max['best_result'] is None or min_max['best_result'] < abs_diff_sum):
                valid_split_points = [z for z in split_points if z['max_final_loc'] is not None]
                
                min_max['best_result'] = abs_diff_sum
                min_max['best_result_list'] = [z['max_final_loc'] for z in valid_split_points]
                min_max['best_result_odds'] = ["%.3f" % z['max_final_odds'] for z in valid_split_points]
                min_max['best_result_start_time'] = [z['max_final_start_time'] for z in valid_split_points]
                min_max['best_result_end_time'] = [z['max_final_end_time'] for z in valid_split_points]
                min_max['dups'] = []
                for il, loc in enumerate(min_max['best_result_list']):
                    if len([1 for z in min_max['best_result_list'] if z==loc]) > 1:
                        min_max['dups'] += [il2 for il2, z in enumerate(min_max['best_result_list']) if il < il2 and z==loc]

                if min_max['dups'] != []:
                    #print "\n\nDups: %s\n\n" % str(min_max['dups'])
                    min_max['best_result_list_deduped'] = []
                    min_max['best_result_end_time_deduped'] = []
                    min_max['best_result_start_time_deduped'] = []
                    min_max['best_result_odds_deduped'] = []
                    for i, (loc, odds, start_tm, end_tm) in enumerate(zip(min_max['best_result_list'], min_max['best_result_odds'], min_max['best_result_start_time'], min_max['best_result_end_time'])):
                        if i not in min_max['dups']:
                            min_max['best_result_list_deduped'].append(loc)
                            min_max['best_result_start_time_deduped'].append(start_tm)
                            min_max['best_result_end_time_deduped'].append(end_tm)
                            min_max['best_result_odds_deduped'].append(odds)
                else:
                    min_max['best_result_start_time_deduped'] = [z for z in min_max['best_result_start_time']]
                    min_max['best_result_end_time_deduped'] = [z for z in min_max['best_result_end_time']]
                    min_max['best_result_list_deduped'] = [z for z in min_max['best_result_list']]
                    min_max['best_result_odds_deduped'] = [z for z in min_max['best_result_odds']]

                min_max['best_result_deduped'] = 0.
                for i, s in enumerate(valid_split_points[0:-1]):
                    min_max['best_result_deduped'] += abs(s['max_final_odds'] - valid_split_points[s['max_final_other_dist']]['max_final_odds'])


                min_max['result_per_split'] = min_max['best_result_deduped']/float(len(min_max['best_result_list_deduped']))
        if debug: print("\n\npre min_maxes")
        if debug: zc.print_dict(min_maxes)
        min_maxes = [z for z in min_maxes if 'best_result_list_deduped' in z]
        for m in min_maxes:

            m['orig'] = "|".join(["%d" % z for z in m['best_result_list_deduped']])
            m['sorted'] = "|".join(["%d" % z for z in sorted(m['best_result_list_deduped'])])
            m['valid_after_sort'] = 1 if m['orig'] == m['sorted'] else 0
            
            
        if debug: print("\n\npost min_maxes")
        if debug: zc.print_dict(min_maxes)
        min_maxes = [z for z in min_maxes if 'result_per_split' in z and z['valid_after_sort']]
        min_maxes = sorted(min_maxes, key=lambda x:x['result_per_split'], reverse=True)
        if debug: print ("\n\n{:<30}".format("Min Maxes"))
        if debug: print ("{:<10}{:>20}{:>20}{:>50}{:>50}".format("Splits", "Best Result", "Result Per", "Splits", "Odds at Splits") + "\n" + ("-"*150))
        if debug: print (("\n".join(["{:<10.0f}{:>20.3f}{:>20.3f}{:>50}{:>50}".format(z['n'], z['best_result_deduped'], z['result_per_split'], ", ".join(map(str, z['best_result_list_deduped'])), ", ".join(z['best_result_odds_deduped'])) for z in min_maxes])))

        #if len(min_maxes[0]['best_result_list_deduped']) > 0:
        #    print("list: %s" % min_maxes[0]['best_result_list_deduped'][0])
        #if len(min_maxes[0]['best_result_start_time_deduped']) > 0:
        #    print("start time: %s" % min_maxes[0]['best_result_start_time_deduped'][0])
        #if len(min_maxes[0]['best_result_end_time_deduped']) > 0:
        #    print("end time: %s" % min_maxes[0]['best_result_end_time_deduped'][0])

        lg['stretches'] = [{
        'start': z
        , 'end': min_maxes[0]['best_result_list_deduped'][i+1]
        }
        for i, z in enumerate(min_maxes[0]['best_result_list_deduped'][0:-1]) if len(min_maxes[0]['best_result_list_deduped']) > 0]

        for ij, s in enumerate(lg['stretches']):
            #zc.print_dict(s); zc.exit("ADD TIME")
            poss = [z for z in possessions if s['start'] <= z['seq'] < s['end']]
            #poss = [z for z in possessions if s['start_time'] <= z['start_time'] < s['end_time']]
            
            if debug:
                print ("\n\nStretch %d" % (1+ij))
                print ("-" * 175)
                print (sorted(poss[0].keys()))
                print ("\n".join(["{:<5}{:<5}{:<20}{:<20}{:<10}{:<10}".format(z['ID'], z['team_ID'], z["start_time"], z['end_time'], z['seq'], z['goal']) for z in poss]))

            s['covers'] = s['end'] - s['start']
            s['splits'] = {'mine': {}, 'theirs': {}}
            start_t = poss[0]['start_time']; end_t = poss[-1]['end_time'];
            #s['start_time'] = start_t; s['end_time'] = end_t;

            if ij == len(lg['stretches']) - 1:
                s['end_clock'] = "END"
            else:
                s['end_clock'] = convert_pct_complete_to_time_str(end_t/3600., lg['game_year'], team_rec['league'])
            if ij == 0:
                s['start_clock'] = "START"
            else:
                s['start_clock'] = convert_pct_complete_to_time_str(start_t/3600., lg['game_year'], team_rec['league'])
            s['start_pct_complete'] = start_t/3600.
            s['end_pct_complete'] = end_t/3600.
            
            for k in s['splits']:
                mine = 1 if k == "mine" else 0
                my_poss = [z for z in poss if z['mine'] == mine]
                their_poss = [z for z in poss if z['mine'] != mine]
                
                if len(my_poss) > 0 and len(their_poss) > 0:
                    mine_is_first = 1 if min([z['seq'] for z in my_poss]) < min([z['seq'] for z in their_poss]) else 0
                elif len(my_poss) > 0:
                    mine_is_first = 1
                elif len(their_poss) > 0:
                    mine_is_first = 0
                    
                #if my_poss[-1]['my_end_odds'] is None:
                #    zc.exit(zc.print_dict(my_poss[-1]))
                
                sp = s['splits'][k]
      
                if len(my_poss) > 0:
                    sp['team_ID'] = my_poss[0]['team_ID']
                    #print ("\n\nlg")
                    #zc.print_dict (lg)
                    sp['team_code'] = lg['home_team'] if my_poss[0]['team_ID'] == lg['home_ID'] else lg['away_team']
                else:
                    sp['team_code'] = lg['home_team'] if their_poss[0]['team_ID'] != lg['home_ID'] else lg['away_team']
                    sp['team_ID'] = lg['home_ID'] if their_poss[0]['team_ID'] != lg['home_ID'] else lg['away_ID']
                    
                end_wp_code = "??"
                if s['end_clock'] == "END":
                    # It should be 100% or 0% even if the team's last possession wasn't actually the end of the game
                    if mine and team_rec_won:
                        sp['end_wp'] = 1.
                        end_wp_code = "A"
                    elif not mine and not team_rec_won:
                        sp['end_wp'] = 1.
                        end_wp_code = "B"
                    elif mine and not team_rec_won:
                        sp['end_wp'] = 0.
                        end_wp_code = "C"
                    elif not mine and team_rec_won:
                        sp['end_wp'] = 0.
                        end_wp_code = "D"
                        
                else:
                    if mine:
                        if len(my_poss) > 0:
                            sp['end_wp'] =  my_poss[-1]['my_end_odds']
                            end_wp_code = "E"
                        else:
                            sp['end_wp'] = None if len(their_poss) == 0 else (1.0 - their_poss[-1]['my_end_odds']) 
                            end_wp_code = "F"
                    else:
                        if len(their_poss) == 0:
                            sp['end_wp'] = (1.0 - my_poss[-1]['my_end_odds'])
                            end_wp_code = "G"
                        else:
                            sp['end_wp'] = (1.0 - their_poss[-1]['my_end_odds'])
                            end_wp_code = "H"
                if mine:
                    if len(my_poss) > 0:
                        sp['start_wp'] = my_poss[0]['my_odds']
                    else:
                        #zc.print_dict(their_poss[0]);# zc.exit("THEIR P")
                        
                        sp['start_wp'] = None if len(their_poss) == 0 else (1.0 - their_poss[0]['team_odds']) 
                        
                else:
                    if len(their_poss) == 0:
                        sp['start_wp'] = (1.0 - my_poss[0]['my_odds'])
                    else:
                        sp['start_wp'] = (1.0 - their_poss[0]['my_odds'])
                        
                    
                
                #sp['start_wp'] = None if len(my_poss) == 0 else my_poss[0]['my_odds']
                #sp['end_wp'] = None if len(my_poss) == 0 else my_poss[-1]['my_end_odds']
                #print (s['start_clock'], s['end_clock'], k, "mine=%d" % mine, sp['start_wp'], sp['end_wp'], len(my_poss), len(their_poss))
                #sp['all_possessions'] = my_poss
                sp['all_shots'] = []
                sp['faceoffs'] = []
                
                # In some cases, we may send shots with the specs dict so that the full description of the stretch can be created (i.e. for a single game processing); if we are just running update_team_summary_stats_LRP, we don't send that extra data, so this step should be skipped
                if 'shots' in specs:
                    for tmp_poss in my_poss:
                        if sp['all_shots'] is None:
                        
                            msg = "[Fatal Stretches] In laxref game update process (game ID %d), I was adding shots to a stretch.all_shots object, but it was None" % lg['ID']
                            
                            msg += get_game_crash_info(lg)
                            zc.send_crash(msg, bot_token)
                            zc.exit("Stretches Error")
                        if tmp_poss['shots'] is None:
                        
                            msg = "[Fatal Stretches] In laxref game update process (game ID %d), I was adding shots to an stretch.all_shots object, but the tmp_poss.shots data was None" % lg['ID']
                            
                            msg += get_game_crash_info(lg)
                            zc.send_crash(msg, bot_token)
                            zc.exit("Stretches Error")
                        sp['all_shots'] += tmp_poss['shots']
                        sp['faceoffs'] += tmp_poss['faceoffs']

                sp['n'] = float(len(my_poss))

                sp['gbs'] = sum([1. for z in my_poss if z['started_with'] == "Ground Ball"])
                
                tmp_sum = sum([z['adj_before_shot'] for z in my_poss if z['adj_before_shot'] is not None and z['adj_before_shot'] > 0])
                tmp_denom = sum([1. for z in my_poss if z['adj_before_shot'] is not None and z['adj_before_shot'] > 0])
                if tmp_denom == 0:
                    sp['1st_shot'] = None
                    sp['time_to_first_shot'] = None
                else:
                    
                    sp['1st_shot'] = "%.1fs" % (tmp_sum/tmp_denom)
                    sp['time_to_first_shot'] = (tmp_sum/tmp_denom)
                
                sp['turnovers'] = sum([1. for z in my_poss if z['turnover']])
                sp['goals'] = sum([1. for z in my_poss if z['goal']])
                
                if extended_data:
                    sp['assists'] = sum([1. for z in my_poss if z['assisted_goal']])
                sp['shots'] = sum([z['num_shots'] for z in my_poss])
                sp['sog'] = sum([z['shots_on_goal'] for z in my_poss])
                sp['total_time'] = sum([z['duration'] for z in my_poss]) + sum([z['duration'] for z in their_poss])
                sp['possession_pct'] = 0. if sp['total_time'] == 0 else sum([z['duration'] for z in my_poss]) / sp['total_time']
                if sp['total_time'] == 0:
                    print ("{:>80}{:<50}{:<30}{:<30}".format("", "Weird stretch calc in game %d" % lg['ID'], s['start_clock'], s['end_clock']))

                sp['efficiency'] = None if sp['n'] == 0 else (sp['goals']/sp['n'])
                sp['turnover_rate'] = None if sp['n'] == 0 else (sp['turnovers']/sp['n'])
                sp['shots_per_possession'] = None if sp['n'] == 0 else (sp['shots']/sp['n'])
                sp['pct_of_possessions'] = None if sum([1. for z in my_poss]) + sum([1. for z in their_poss]) == 0 else (sum([1. for z in my_poss]) / (sum([1. for z in my_poss]) + sum([1. for z in their_poss])))
                sp['shooting_pct'] = None if sp['shots'] == 0 else (sp['goals']/sp['shots'])
                sp['sog_rate'] = None if sp['shots'] == 0 else (sp['sog']/sp['shots'])
                sp['on_goal_shooting_pct'] = None if sp['sog'] == 0 else (sp['goals']/sp['sog'])
                sp['total_poss_duration'] = sum([z['duration'] for z in my_poss])
                sp['avg_poss_duration'] = None if sp['n'] == 0 else ( "%.1fs" % (sp['total_poss_duration']/sp['n']))
                
                if '--print-stretches' in sys.argv or '--show-stretches' in sys.argv:
                    print ("rwefds {:<20}{:<20}{:<10}{:<10}{:<10.3f}{:<10.3f}{:<20}{:<10}{:<10}{:<10}".format(
                    "%s to %s" % (s['start_clock'], s['end_clock'])
                    , "%d to %d" % (s['start_time'], s['end_time'])
                    , k
                    , sp['team_code']
                    , sp['start_wp']
                    , sp['end_wp']
                    , "End wp code: %s" % end_wp_code
                    , "poss=%d" % sp['n']
                    , "goals=%d" % sp['goals']
                    , "shots=%d" % sp['shots']))
                
        #zc.print_dict(lg['stretches'])

        #print ("{:<40} @ {}".format ("  completed build_game_stretches", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        f = open(os.path.join(lr_fldr, "Logs", "GameStretches", "team%04d_game%06d.json" % (team_rec['ID'], lg['ID'])), 'w')
        f.write(json.dumps(lg['stretches']))
        f.close()

    return lg

def build_betting(sg, over_under_settings, margin_of_victory_settings):
    sg['betting_info'] = {}
    
    return sg
    
def build_matchup_advantages(team_rec, sg, poss_list, this_year_weight, last_year_weight, specs):
    sg['matchup_advantages_alt'] = {'shooting': {'offense': {}, 'defense': {}}, 'pacing': {'offense': {}, 'defense': {}}}
    ma = sg['matchup_advantages_alt']['shooting']
    tmp_tags = [{'tag': 'offense', 'opp': 'defense'}, {'tag': 'defense', 'opp': 'offense'}]
    for tmp in tmp_tags:

        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (sg['opponentID'], sg['game_year'], tmp['opp']))
        ma[tmp['tag']]['opp_shots_analysis_this_year'] = None
        if os.path.isfile(path):
            ma[tmp['tag']]['opp_shots_analysis_this_year'] = json.loads(open(path, 'r').read())

        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (sg['opponentID'], sg['game_year']-1, tmp['opp']))
        ma[tmp['tag']]['opp_shots_analysis_last_year'] = None
        if os.path.isfile(path):
            ma[tmp['tag']]['opp_shots_analysis_last_year'] = json.loads(open(path, 'r').read())




        ttags = ['this_year', 'last_year']

        for tag in ttags:
            if None not in [team_rec['full_shooting_profile_%s' % ( tmp['tag'])][tag], ma[tmp['tag']]['opp_shots_analysis_%s' % tag]]:
                me_shot_clock = team_rec['full_shooting_profile_%s' % ( tmp['tag'])][tag][ [z['tag'] for z in team_rec['full_shooting_profile_%s' % ( tmp['tag'])][tag]].index("shot_clock_remaining_bucket") ]
                them_shot_clock = ma[tmp['tag']]['opp_shots_analysis_%s' % tag][ [z['tag'] for z in ma[tmp['tag']]['opp_shots_analysis_%s' % tag]].index("shot_clock_remaining_bucket") ]

                for me, them in zip(me_shot_clock['buckets'], them_shot_clock['buckets']):

                    me['share_effect'] = 0. if None in [me['share'], them['excess_shooting_pct'], me['excess_shooting_pct'], them['share_diff']] else them['excess_shooting_pct'] * them['share_diff']

                    me['pct_effect'] = 0. if them['excess_shooting_pct'] is None else them['excess_shooting_pct']

        ty_list = team_rec['full_shooting_profile_%s' % ( tmp['tag'])]["this_year"]
        sc_ty = {} if ty_list is None else ty_list[ [z['tag'] for z in ty_list].index("shot_clock_remaining_bucket") ]['buckets']
        ly_list = team_rec['full_shooting_profile_%s' % ( tmp['tag'])]["last_year"]
        sc_ly = {} if ly_list is None else ly_list[ [z['tag'] for z in ly_list].index("shot_clock_remaining_bucket") ]['buckets']
        for ty, ly in zip(sc_ty, sc_ly):
            if 'share_effect' in ly and 'share_effect' in ty:
                ty['share_effect_weighted'] = ty['share_effect'] * this_year_weight + ly['share_effect'] * last_year_weight
                ty['pct_effect_weighted'] = ty['pct_effect'] * this_year_weight + ly['pct_effect'] * last_year_weight
            elif 'share_effect' in ly and 'share_effect' not in ty:
                ty['share_effect_weighted'] = ly['share_effect']
                ty['pct_effect_weighted'] = ly['pct_effect']
            elif 'share_effect' not in ly and 'share_effect' in ty:
                ty['share_effect_weighted'] = ty['share_effect']
                ty['pct_effect_weighted'] = ty['pct_effect']
            else:
                if sg['opponentID'] == 935:
                    ty['share_effect_weighted'] = None
                    ty['pct_effect_weighted'] = None
                    pass # It's ok; Youngstown State is a new program and this should be failing here.
                else:
                    msg = "In build_stats_future_games (%s vs ID %d), could not find either a this_year or last_year shots analysis." % (team_rec['display_name'], sg['opponentID'])
                    print (msg)
                    zc.send_crash(msg, bot_token)
                    zc.exit("laxref0007")

    # Handle the pacing profile stuff

    ma = sg['matchup_advantages_alt']['pacing']

    for ttag in [{'tag': 'offense', 'desc': 'offensive', 'opp': 'defense'}, {'tag': 'defense', 'desc': 'defensive', 'opp': 'offense'}]:
        specs['game_year'] = sg['game_year']
        ma[ttag['tag']] = build_pacing_profile(sg['opponentID'], poss_list[team_rec['league']], ttag['tag'], specs)
        specs['game_year'] = None

    for unit_tag in [{'tag': 'offense', 'desc': 'offensive', 'opp': 'defense'}, {'tag': 'defense', 'desc': 'defensive', 'opp': 'offense'}]:
        #print("team_rec.%s_pace_profile.length_data" % ttag['desc'])
        #zc.print_dict(team_rec["%s_pace_profile" % ttag['desc']]['length_data'])

        for tag in ttags:
            if ma[unit_tag['opp']] is not None:
                them = ma[unit_tag['opp']]['length_data']
                for ib, me in enumerate(team_rec["%s_pace_profile" % (unit_tag['desc'])]['length_data']):

                    #print "{:<30}{:<30}{:<30}{:<30}{:<30}".format(me['share_%s' % tag], me['efficiency_diff_%s' % tag], them[ib]['share_diff_%s' % tag], them[ib]['efficiency_diff_%s' % tag], them[ib]['share_diff_%s' % tag])

                    me['share_effect_%s' % tag] = None
                    if 'efficiency_diff_%s' % tag in them[ib] and None not in [them[ib]['efficiency_diff_%s' % tag], me['share_%s' % tag], me['efficiency_diff_%s' % tag], them[ib]['share_diff_%s' % tag]]:
                        them[ib]['efficiency_diff_%s' % tag] * them[ib]['share_diff_%s' % tag]

                    me['pct_effect_%s' % tag] = None
                    if 'efficiency_diff_%s' % tag in them[ib] and them[ib]['efficiency_diff_%s' % tag] is not None:
                        them[ib]['efficiency_diff_%s' % tag]

        for ib, me in enumerate(team_rec["%s_pace_profile" % unit_tag['desc']]['length_data']):
            if 'share_effect_this_year' in me:
                if me['share_effect_this_year'] is not None and me['share_effect_last_year'] is not None:
                    me['share_effect'] = me['share_effect_this_year'] * this_year_weight + me['share_effect_last_year'] * last_year_weight
                    me['pct_effect'] = me['pct_effect_this_year'] * this_year_weight + me['pct_effect_last_year'] * last_year_weight
                elif me['share_effect_this_year'] is None and me['share_effect_last_year'] is not None:
                    me['share_effect'] =  me['share_effect_last_year']
                    me['pct_effect'] = me['pct_effect_last_year']
                elif me['share_effect_this_year'] is not None and me['share_effect_last_year'] is None:
                    me['share_effect'] =  me['share_effect_this_year']
                    me['pct_effect'] = me['pct_effect_this_year']
                elif me['share_effect_this_year'] is not None and me['share_effect_last_year'] is None:
                    me['share_effect'] =  me['share_effect_this_year']
                    me['pct_effect'] = me['pct_effect_this_year']
                else:
                    me['share_effect'] = None
                    me['pct_effect'] = None
            else:
                me['share_effect'] = None
                me['pct_effect'] = None

    return sg
        
def build_opponent_time_based_profiles(team_rec, sg, poss_list, this_year_weight, last_year_weight, specs):
    sg['opp_time_based_splits'] = {'shooting': {'offense': {}, 'defense': {}}, 'pacing': {'offense': {}, 'defense': {}}}
    ma = sg['opp_time_based_splits']['shooting']
    tmp_tags = [{'tag': 'offense', 'opp': 'defense'}, {'tag': 'defense', 'opp': 'offense'}]
    for tmp in tmp_tags:

        
        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (sg['opponentID'], sg['game_year'], tmp['tag']))
        #print  "Get %s build_opponent_time_based_profiles from %s" % (tmp['tag'], path)
        
        ma[tmp['tag']]['opp_shots_analysis_this_year'] = None
        if os.path.isfile(path):
            ma[tmp['tag']]['opp_shots_analysis_this_year'] = json.loads(open(path, 'r').read())
        
        
        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (sg['opponentID'], sg['game_year']-1, tmp['tag'])) 
        
        ma[tmp['tag']]['opp_shots_analysis_last_year'] = None
        if os.path.isfile(path):
            ma[tmp['tag']]['opp_shots_analysis_last_year'] = json.loads(open(path, 'r').read())
    #zc.print_dict(ma['defense']['opp_shots_analysis_this_year'][-1]['buckets']); 
    
    #print "\n{:<30}{:>30}{:>30}{:>30}".format("Quarter", "Goals", "Shots", "Pct")
    #print ("-" * 120)
    #print ("\n").join(["{:<30}{:>30.0f}{:>30.0f}{:>30.3f}".format(z['bucket'], z['goals'], z['shots'], z['pct']) for z in ma['defense']['opp_shots_analysis_this_year'][-1]['buckets']])
      
        
        
    # Handle the pacing profile stuff

    ma = sg['opp_time_based_splits']['pacing']

    for ttag in [{'tag': 'offense', 'desc': 'offensive', 'opp': 'defense'}, {'tag': 'defense', 'desc': 'defensive', 'opp': 'offense'}]:
        specs['game_year'] = sg['game_year']
        ma[ttag['tag']] = build_pacing_profile(sg['opponentID'], poss_list[team_rec['league']], ttag['tag'], specs)
        specs['game_year'] = None
    
    return sg
        
def build_opponent_player_outcome_splits(team_rec, sg, specs):
    sg['opp_player_outcome_splits'] = None
    sg['opp_player_outcome_splits_this_year'] = 1
    sg['opp_team_outcome_splits'] = None
    sg['opp_team_outcome_splits_this_year'] = 1
    
    tmp_yr = specs['year'] if 'game_year' not in specs or specs['game_year'] is None else specs['game_year']
    
    team_src = os.path.join(lr_fldr, "Logs", "TeamOutcomeSplits", "team%04d_%d.json" % (sg['opponentID'], tmp_yr))
    src = os.path.join(lr_fldr, "Logs", "PlayerOutcomeSplits", "team%04d_%d.json" % (sg['opponentID'], tmp_yr))
    
    if os.path.isfile(team_src):
        sg['opp_team_outcome_splits'] = json.loads(open(team_src, 'r').read())
    if os.path.isfile(src):
        sg['opp_player_outcome_splits'] = json.loads(open(src, 'r').read())
    
    if sg['opp_player_outcome_splits'] is None or len(sg['opp_player_outcome_splits']['player_outcome_splits_all'][0]['top_splits']) == 0:
        src = os.path.join(lr_fldr, "Logs", "PlayerOutcomeSplits", "team%04d_%d.json" % (sg['opponentID'], tmp_yr-1))
        
        if os.path.isfile(src):
            sg['opp_player_outcome_splits'] = json.loads(open(src, 'r').read())
            if not (sg['opp_player_outcome_splits'] is None or len(sg['opp_player_outcome_splits']) == 0):
                sg['opp_player_outcome_splits_this_year'] = 0
    
    if sg['opp_team_outcome_splits'] is None or len(sg['opp_team_outcome_splits']['team_outcome_splits_all'][0]['top_splits']) == 0:
        team_src = os.path.join(lr_fldr, "Logs", "TeamOutcomeSplits", "team%04d_%d.json" % (sg['opponentID'], tmp_yr-1))
        
        if os.path.isfile(team_src):
            sg['opp_team_outcome_splits'] = json.loads(open(team_src, 'r').read())
            if not (sg['opp_team_outcome_splits'] is None or len(sg['opp_team_outcome_splits']) == 0):
                sg['opp_team_outcome_splits_this_year'] = 0
    
        
    return sg
        

def build_shooting_profiles(team_rec, specs):
    # Pull in the shooting profile from shots_analyzer.py
    tmp_tags = ['offense', 'defense']
    for ttag in tmp_tags:

        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (team_rec['ID'], specs['last_year'], ttag))
        team_rec['full_shooting_profile_%s' % (ttag)] = {"last_year": json.loads(open(path, 'r').read()) if os.path.isfile(path) else None}

        path = os.path.join(".", "Logs", "shots_analysis", "HeatMaps", "team%04d_%d_%s" % (team_rec['ID'], specs['year'], ttag))
        shots_analysis = None
        team_rec['full_shooting_profile_%s' % (ttag)]["this_year"] = None
        team_rec['goalkeepers_adjusted_shooting'] = None
        if os.path.isfile(path):
            shots_analysis = json.loads(open(path, 'r').read())
            team_rec['full_shooting_profile_%s' % (ttag)]["this_year"] = shots_analysis

            shot_clock = shots_analysis[ [z['tag'] for z in shots_analysis].index('shot_clock_remaining_bucket')]
            #zc.print_dict(shot_clock['buckets']);
            team_rec["%s_shooting_profile" % ttag.replace("ense", "ensive")] = {'data': []}
            for ic, bucket in enumerate(shot_clock['buckets']):
                d = {'label': "" if ic % 2 == 1 else ("%d-%ds" % (bucket['bucket'], bucket['bucket']+9)),  'x': len(shot_clock['buckets']) - ic + 1, 'y': bucket['pct'], 'team_share': bucket['share'], 'team_pct': bucket['pct'], 'cnt': bucket['shots'], 'league_share': bucket['league_share'], 'league_pct': bucket['league_avg']}
                team_rec["%s_shooting_profile" % ttag.replace("ense", "ensive")]['data'].append(d)
            if ttag == "defense":
                team_rec['goalkeepers_adjusted_shooting'] = shots_analysis
    return team_rec

def build_elapsed_time_profiles(team_rec, all_possessions, specs):
    # Pull in the shooting profile from shots_analyzer.py
    tmp_tags = ['offense', 'defense']
    for ttag in tmp_tags:

        pass
    return team_rec

def store_values_in_model_outputs_database_table(teams, val_tag, model_ID, specs):
    """
    This function stores the output of a model in the database so that we have a timestamped record of where each team was.
    """
    
    dt = datetime.now()
    insert_query = "INSERT INTO LaxRef_Model_Outputs (datestamp, active, team_ID, model_ID, val, rank) VALUES (%s, %s, %s, %s, %s, %s)"
    insert_params = []
    for i, t in enumerate(teams):
        tmp_ID = t['team_ID'] if 'team_ID' in t else t['ID']
        param = [dt, 1, tmp_ID, model_ID, t[val_tag], i+1]
        insert_params.append(param)
    
    cursor = zc.zcursor("LR")
    cursor.executemany(insert_query, insert_params)
    cursor.commit(); cursor.close()
    if '--notify-db-store' in sys.argv:
        zc.send_telegram("%d LR ranking records stored in the DB for %s" % (len(insert_params), sys.argv[sys.argv.index('-league') + 1]), bot_token)
        
     
                        

def assign_player_role(player_data, off_val, def_val, fogo_val, shots_faced, faceoff_wins, team_listed_role):
    """
    This function takes in a players stats (EGA, shots_faced and faceoff wins) and assigns them a role based on their statistical profile. It has a twin in laxref_dot_py that should be kept the same for consistency's sake.
    """
    is_women = 0
    if 'league' in player_data and "Women" in player_data['league']:
        is_women = 1
        
    role = None

    if team_listed_role == "D":
        role = "defensive"
    elif None not in [off_val, def_val, fogo_val] and (off_val + def_val + fogo_val) > 0 and (shots_faced is None or shots_faced < 5):
        tot = off_val + def_val + fogo_val

        off_pct = off_val/tot
        def_pct = def_val/tot
        fogo_pct = fogo_val/tot
        if is_women:
            if def_pct > .5:
                role = "defensive"
            else:
                role = "offensive"
        else:
            if fogo_pct > .5 and faceoff_wins is not None and faceoff_wins > 0:
                role = "faceoff"
            elif def_pct > .5:
                role = "defensive"
            else:
                role = "offensive"
    elif not is_women and faceoff_wins is not None and faceoff_wins > 100:
        role = "faceoff"
    elif shots_faced is not None and shots_faced > 0:
        role = "goalkeeper"
    else:
        if team_listed_role == "G":
            role = "goalkeeper"
        elif team_listed_role == "A":
            role = "offensive"
        elif team_listed_role == "M":
            role = "offensive"
        elif team_listed_role == "D":
            role = "defensive"
        else:
            role = "offensive"
            
    return role

def upload_season_team_list_query_data(year):
    """
    This function creates and uploads a JSON file that contains the data required to display a league stats ranking page.
    """
    conn, cursor = zc.mysql_connect('LR')
    cursor.execute("SELECT ID, team_ID, team, league, adjusted_off_efficiency, adjusted_def_efficiency, adjusted_faceoff_win_rate, elo_rating, off_expected_shooting_pct, off_excess_shooting_pct, possession_margin, elo_rating 'orig_elo_rating' from LaxRef_Team_Seasons where year=%s and active", [year])
    team_seasons = zc.dict_query_results(cursor)
    cursor.close(); conn.close()
    
    error_msg = None
    if len(team_seasons) == 0:
        error_msg = "Database query returned 0 records. Do not upload a blank file"
    else:
    
        # Create JSON object
        if error_msg is None:
            try:
                json_data = json.dumps(team_seasons)
                fname = "dbLaxRef_TeamSeasons_{}.json" .format (year)
                src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GeneralData", fname)
            except Exception:
                error_msg = "JSON object creation failed: %s" % traceback.format_exc()
            
        
        # Write JSON object to file
        if error_msg is None:    
            try:
                
                f = open(src, 'w')
                f.write(json_data)
                f.close()
            except Exception:
                error_msg = "Writing JSON object to file failed: %s" % traceback.format_exc()
        
            
        # Upload file to LRP Bucket
        if error_msg is None:
            try:
                upload_file({'src': src, 'fname': fname, 'target_folder': 'GeneralData'})
            except Exception:
                
                error_msg = "Upload-to-LRP storage failed: %s" % traceback.format_exc()
        
        if error_msg is not None:
            error_msg = "The following error caused the current season teams Storage upload to fail. Until this is resolved, the LRP site will have inaccurate data when displaying a league stats table.\n\n%s" % error_msg
            zc.send_email(error_msg, {'subject': "LRP Storage Upload Failed", 'from': 'UploadSeasonTeamListQueryData'})
            print (error_msg)
        else:
            print ("\n\nLRP Storage Upload Succeeded: UploadSeasonTeamListQueryData\n\n")

    return 1 if error_msg is not None else 0
    
REMOVE_RANKS_FROM_LAXREF_PLAYER_SEASONS=1
  
# Called via the upload_season_data.py script    
def upload_player_seasons_query_data(league, year):
    """
    When creating the data to display a player's detail page on LRP, we need to have the universe of player seasons for that league/year combination. This function pulls the relevant data from the database and uploads it to a Storage bucket so that it can be used without requiring a costly query to be executed for every player load.
    """
    cursor = zc.zcursor("LR")
    
    # This was a first cut of the query that appears to include superfluous fields that can be removed to cut down on data transfers and load times.
    #query = "SELECT a.player_ID, a.shots_taken, a.shots_faced, a.goals_scored, a.goals_allowed, a.expected_goals_scored, a.expected_goals_allowed, a.EGA, a.team_ID, a.faceoff_wins, a.faceoff_losses, a.faceoff_win_rate, a.team_play_shares, a.role, a.team_listed_role, a.turnovers, a.gbs, a.sog, a.assists, a.sog_faced, a.sog_rate_faced, a.save_pct, a.shooting_pct, a.offensive_EGA, a.defensive_EGA, a.faceoff_EGA, a.sog_rate, a.excess_goals_scored, a.excess_saves, a.turnovers_rank, a.shooting_pct_rank, a.EGA_rank, a.offensive_EGA_rank, a.defensive_EGA_rank, a.faceoff_EGA_rank, a.sog_rate_rank, a.save_pct_rank, a.excess_goals_scored_rank, a.excess_saves_rank, a.EGA_per_game, a.EGA_per_game_rank, a.games_appeared_in, a.caused_turnovers, a.penalties, a.num_faceoffs_taken_last_team_game, a.excess_goals_per_shot, a.excess_goals_per_shot_rank, a.usage_adjusted_EGA, a.excess_saves_per_sog, a.excess_saves_per_sog_rank, a.on_keeper_sog_faced, a.on_keeper_rate_faced, a.devittes, a.weighted_team_play_shares, a.turnover_rate, a.turnover_rate_rank, a.faceoff_win_rate_rank, a.faceoffs_taken, a.share_of_team_assists, a.tewaaraton, a.assist_to_turnover_ratio, a.share_adjusted_assist_rate, a.goals, a.shots, a.usage_adjusted_EGA_rank, a.assist_to_turnover_ratio_rank, a.excess_shooting_pct, a.excess_shooting_pct_rank, a.points, a.points_per_game, a.points_per_game_rank, a.points_rank, a.is_primary_fogo, a.pct_of_shots, a.share_of_team_shots, a.caused_turnover_to_penalty_ratio,  a.share_adjusted_assist_rate_rank, a.faceoff_conversion_rate_rank, a.usage_adjusted_EGA_percentile, a.EGA_per_game_percentile, a.EGA_percentile, a.offensive_EGA_percentile, a.defensive_EGA_percentile, a.faceoff_EGA_percentile, a.excess_goals_scored_percentile, a.excess_goals_per_shot_percentile, a.excess_saves_percentile, a.shooting_pct_percentile, a.share_adjusted_assist_rate_percentile, a.sog_rate_percentile, a.turnover_rate_percentile, a.save_pct_percentile, a.assist_to_turnover_ratio_percentile, a.points_per_game_percentile, a.caused_turnovers_rank, a.caused_turnovers_percentile, a.caused_turnover_to_penalty_ratio_rank, a.caused_turnover_to_penalty_ratio_percentile, a.saved_shot_pct, a.saved_shot_pct_rank, a.saved_shot_pct_percentile, a.fp_shots, a.fp_goals, a.fp_shooting_pct, a.offensive_EGA_per_game, a.offensive_EGA_per_game_rank, a.offensive_EGA_per_game_percentile, a.defensive_EGA_per_game, a.defensive_EGA_per_game_rank, a.defensive_EGA_per_game_percentile, a.faceoff_EGA_per_game, a.faceoff_EGA_per_game_rank, a.faceoff_EGA_per_game_percentile, a.weighted_team_play_shares_percentile, a.weighted_team_play_shares_rank, CASE WHEN NOT ISNULL(a.shooting_pct_rank) THEN 1 ELSE 0 END 'offensive_qualified', CASE WHEN NOT ISNULL(a.faceoff_win_rate_rank) THEN 1 ELSE 0 END 'faceoff_qualified', CASE WHEN NOT ISNULL(a.excess_saves_per_sog_rank) THEN 1 ELSE 0 END 'goalkeeper_qualified' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Team_Seasons c where c.active and c.team_ID=a.team_ID and c.year=a.year and c.league=%s and a.team_ID=b.ID and b.active and a.active and a.year=%s"
    
    # This appears to be the minimum set of fields required to generate the required visuals
    if REMOVE_RANKS_FROM_LAXREF_PLAYER_SEASONS:
        query = "SELECT a.excess_saves, a.faceoff_ELO, a.excess_saves_per_sog, a.EGA_per_game, a.usage_adjusted_EGA, a.EGA, a.offensive_EGA, a.defensive_EGA, a.faceoff_EGA, a.excess_goals_scored, a.excess_goals_per_shot, a.save_pct, a.shooting_EGA, a.shooting_efficiency, a.caused_turnovers, a.caused_turnover_to_penalty_ratio, a.shooting_pct, a.sog_rate, a.turnover_rate, a.assist_to_turnover_ratio, a.share_adjusted_assist_rate, a.faceoff_win_rate, CASE WHEN IFNULL(a.shots, 0) > 10 THEN 1 ELSE 0 END 'offensive_qualified', CASE WHEN IFNULL(a.faceoff_wins, 0) > 10 THEN 1 ELSE 0 END 'faceoff_qualified', CASE WHEN IFNULL(a.on_keeper_sog_faced, 0) > 10 THEN 1 ELSE 0 END 'goalkeeper_qualified' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Team_Seasons c where c.active and c.team_ID=a.team_ID and c.year=a.year and c.league=%s and a.team_ID=b.ID and b.active and a.active and a.year=%s"
    
    else:
        query = "SELECT a.excess_saves, a.faceoff_ELO, a.excess_saves_per_sog, a.EGA_per_game, a.usage_adjusted_EGA, a.EGA, a.offensive_EGA, a.defensive_EGA, a.faceoff_EGA, a.excess_goals_scored, a.excess_goals_per_shot, a.save_pct, a.shooting_EGA, a.shooting_efficiency, a.caused_turnovers, a.caused_turnover_to_penalty_ratio, a.shooting_pct, a.sog_rate, a.turnover_rate, a.assist_to_turnover_ratio, a.share_adjusted_assist_rate, a.faceoff_win_rate, CASE WHEN NOT ISNULL(a.shooting_pct_rank) THEN 1 ELSE 0 END 'offensive_qualified', CASE WHEN NOT ISNULL(a.faceoff_win_rate_rank) THEN 1 ELSE 0 END 'faceoff_qualified', CASE WHEN NOT ISNULL(a.excess_saves_per_sog_rank) THEN 1 ELSE 0 END 'goalkeeper_qualified' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Team_Seasons c where c.active and c.team_ID=a.team_ID and c.year=a.year and c.league=%s and a.team_ID=b.ID and b.active and a.active and a.year=%s"
    param = [league, year]
    cursor.execute(query, param)
    cur_year_player_seasons = zc.dict_query_results(cursor)
    cursor.close()
    for pc in cur_year_player_seasons:
        pc['defensive_qualified'] = pc['offensive_qualified']
        
    error_msg = None
    if len(cur_year_player_seasons) == 0:
        error_msg = "Database query returned 0 records. Do not upload a blank file"
    else:
    
        # Create JSON object
        if error_msg is None:
            try:
                json_data = json.dumps(cur_year_player_seasons)
                fname = "dbLaxRef_PlayerSeasons_{}_{}.json" .format (year, league.replace(" ", ""))
                src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GeneralData", fname)
            except Exception:
                error_msg = "JSON object creation failed: %s" % traceback.format_exc()
            
        
        # Write JSON object to file
        if error_msg is None:    
            try:
                
                f = open(src, 'w')
                f.write(json_data)
                f.close()
            except Exception:
                error_msg = "Writing JSON object to file failed: %s" % traceback.format_exc()
        
            
        # Upload file to LRP Bucket
        if error_msg is None:
            try:
                upload_file({'src': src, 'fname': fname, 'target_folder': 'GeneralData'})
            except Exception:
                
                error_msg = "Upload-to-LRP storage failed: %s" % traceback.format_exc()
        
        if error_msg is not None:
            error_msg = "The following error caused the player seasons Storage upload to fail. Until this is resolved, the LRP site will have inaccurate data for player detail pages when calculating a player's percentiles.\n\n%s" % error_msg
            zc.send_email(error_msg, {'subject': "LRP Storage Upload Failed", 'from': 'UploadPlayerSeasonsQueryData'})
            print (error_msg)
        else:
            print ("\n\nLRP Storage Upload Succeeded: UploadPlayerSeasonsQueryData\n\n")

    return 1 if error_msg is not None else 0
    
    
def build_roster(team_rec, team_players, all_league_players, specs):
    
    team_rec['roster'] = [z for z in team_players if " " in z['player'] and z['is_individual'] and z['player'].upper() not in ['TEAM', 'OWN GOAL', 'EMPTY NET']]
    
    qualifying_FOGOs = [z for z in all_league_players if None not in [z['faceoff_ELO'], z['faceoff_wins'], z['faceoff_losses']] and z['faceoff_wins'] + z['faceoff_losses'] > 0]
    n = len(qualifying_FOGOs)
    qualifying_pct = .4
        
    team_rec['rosters'] = []
    for i in range(3):
        
        src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_roster_%d_LRP.json" % (team_rec['ID'], specs['year'] - i - 1))
        if os.path.isfile(src):
            try:
                d = {'year': specs['year'] - i - 1}
                d['roster'] = json.loads(open(src, 'r').read())
                team_rec['rosters'].append(d)
            except Exception:
                pass
                
    
    stat_tags = [{'tag': ''}, {'tag': ''}, {'tag': ''}, {'tag': ''}, {'tag': ''}]
    team_caused_turnovers = sum([z['caused_turnovers'] for z in team_rec['roster'] if z['caused_turnovers'] is not None])
    for p in team_rec['roster']:
        p['play_shares_rank'] = None; p['play_shares_rank_str'] = "N/A"
        if p['team_play_shares'] is not None:
            p['play_shares_rank'] = len([1 for z in team_rec['roster'] if z['team_play_shares'] is not None and z['team_play_shares'] > p['team_play_shares']]) + 1
            p['play_shares_rank_str'] = "%d%s" % (p['play_shares_rank'], zc.get_number_suffix(p['play_shares_rank']))

        p['weighted_play_shares_rank'] = None; p['weighted_play_shares_rank_str'] = "N/A"
        if p['weighted_team_play_shares'] is not None:
            p['weighted_play_shares_rank'] = len([1 for z in team_rec['roster'] if z['weighted_team_play_shares'] is not None and z['weighted_team_play_shares'] > p['weighted_team_play_shares']]) + 1
            p['weighted_play_shares_rank_str'] = "%d%s" % (p['weighted_play_shares_rank'], zc.get_number_suffix(p['weighted_play_shares_rank']))

        p['season_faceoff_ELO_rank_str'] = "N/A"
        p['season_faceoff_ELO_rank'] = None
        p['faceoff_EGA_rank_str'] = "N/A" if 'faceoff_EGA_rank' not in p or p['faceoff_EGA_rank'] is None else ("%d%s" % (p['faceoff_EGA_rank'], zc.get_number_suffix(p['faceoff_EGA_rank'])))
        p['defensive_EGA_rank_str'] = "N/A" if 'defensive_EGA_rank' not in p or p['defensive_EGA_rank'] is None else ("%d%s" % (p['defensive_EGA_rank'], zc.get_number_suffix(p['defensive_EGA_rank'])))
        p['save_pct_rank_str'] = "N/A" if 'save_pct_rank' not in p or p['save_pct_rank'] is None else ("%d%s" % (p['save_pct_rank'], zc.get_number_suffix(p['save_pct_rank'])))
        p['excess_saves_rank_str'] = "N/A" if 'excess_saves_rank' not in p or p['excess_saves_rank'] is None else ("%d%s" % (p['excess_saves_rank'], zc.get_number_suffix(p['excess_saves_rank'])))
        p['saves'] = "N/A" if None in [p['sog_faced'], p['goals_allowed']] else  p['sog_faced'] - p['goals_allowed']

        p['caused_turnover_share'] = None if team_caused_turnovers == 0 or p['caused_turnovers'] is None else (p['caused_turnovers']/team_caused_turnovers)
        
        
        
        if None not in [p['faceoff_ELO'], p['faceoff_wins'], p['faceoff_losses']] and p['faceoff_wins'] + p['faceoff_losses'] > 0:
            p['season_faceoff_ELO_rank'] = len([1 for z in qualifying_FOGOs if z['faceoff_ELO'] > p['faceoff_ELO']]) + 1
            p['season_faceoff_ELO_rank_str'] = "%d%s" % (p['season_faceoff_ELO_rank'], zc.get_number_suffix(p['season_faceoff_ELO_rank']))
            
        p['role'] = assign_player_role(p, p['offensive_EGA'], p['defensive_EGA'], p['faceoff_EGA'], p['shots_faced'], p['faceoff_wins'], p['team_listed_role'])
        #print p['offensive_EGA'], p['defensive_EGA'], p['faceoff_EGA'], p['shots_faced'], p['faceoff_wins'], p['role']
        #print "{:<30}{:>10}{:>10}{:>10}{:>10}{:>10}".format(p['player'], p['offensive_EGA'], p['defensive_EGA'], p['faceoff_EGA'], p['shots_faced'], p['offensive_EGA'] + p['defensive_EGA'] + p['faceoff_EGA'])
        if p['role'] == "faceoff" and "Women" not in team_rec['league']:
            p = build_fogo_splits(p, specs)



    with_shares = sorted([z for z in team_rec['roster'] if z['team_play_shares'] is not None], key=lambda x:x['team_play_shares'], reverse=True)
    without_shares = [z for z in team_rec['roster'] if z['team_play_shares'] is None]
    team_rec['roster'] = with_shares + without_shares
    
    src = os.path.join(lr_fldr, 'Logs', 'TeamJSONs', "teamstats_%04d_roster_%d_LRP.json" % (team_rec['ID'], specs['year']))
    f = open(src, 'w'); f.write(json.dumps(team_rec['roster'])); f.close()
    
    return team_rec

def add_player_and_team_links(html):
    """
    This function takes an HTML content object and looks for coded player and team names that signifying a link should replace the plain text.
    """
    if html is None: return html
    player_regex = re.compile('(([a-z\-\'\.]+?)\-PRO)[\s\r\n\.\,\;\:\)]', re.IGNORECASE)
    team_regex = re.compile('(([a-z\-\'\.]+?)\-(MLAX|WLAX))', re.IGNORECASE)
    
    player_matches = [{'full': z[0], 'orig': z[1]} for z in list(set(re.findall(player_regex, html)))]
    for m in player_matches:
        m['clean'] = m['orig'].lower().replace("-", "").replace("'", "")
    
    
    team_matches = [{'full': z[0], 'orig': z[1], 'league': z[2]} for z in list(set(re.findall(team_regex, html)))]
    
    for m in team_matches:
    
        m['clean'] = m['orig'].replace("-", " ").upper().strip()
        if m['league'] == "MLAX":
            m['league'] = "NCAA D1 Men"
        elif m['league'] == "WLAX":
            m['league'] = "NCAA D1 Women"
            
    team_matches = [z for z in team_matches if z['clean'] not in ['LIVE WIN PROBABILITIES']]
    
    players = []
    query = ""
    if len(player_matches) > 0:
        
        query = "SELECT LOWER(replace(replace(replace(player, ' ', ''), '-',''), '''','')) lower_player, player, pro_url_tag, ID from LaxRef_Players where active and ("
        query += " or ".join(["LOWER(replace(replace(replace(player, ' ', ''), '-',''), '''',''))='%s'" % z['clean'].replace("'", "") for z in player_matches])
        query += ")"
        
        print (query)
        
        conn, cursor = mysql_connect("LR")
        cursor.execute(query, [])
        players = zc.dict_query_results(cursor)
        cursor.close(); conn.close()
        
    if len(team_matches) > 0:
        conn, cursor = mysql_connect("LR")
        cursor.execute("SELECT * from LaxRef_Teams where active", [])
        teams = zc.dict_query_results(cursor)
        cursor.close(); conn.close()
    
    
    result_msg = "" if len(team_matches) + len(player_matches) == 0  else ("add_player_and_team_links report".replace("_", " ")).title()
    fails = 0
    # Swap out the original player code with the PRO url
    queries = []; params = []
    for m in player_matches:
        if m['clean'] in [z['lower_player'] for z in players]:
            tmp = players[ [z['lower_player'] for z in players].index(m['clean'])]
            m['pro_url_tag'] = tmp['pro_url_tag']
            url = "<a href='https://pro.lacrossereference.com/%s?t=[tracking_tag]'>%s</a>" % (m['pro_url_tag'], tmp['player'])
            html = html.replace(m['full'], url)
            queries.append("UPDATE LaxRef_Players set unlocked=1, relock_date=%s where ID=%s")
            params.append([datetime.now() + timedelta(days=10), tmp['ID']])
        else:
            tmp_all_players = "\n".join([z['lower_player'] for z in players]) 
            result_msg += "\n\nFailed to convert player name: %s (orig = %s) from the %d players that were pulled from the database.\n\nThose player record were\n\n%s" % (m['clean'], m['orig'],len(players), tmp_all_players); fails += 1
    if len(queries) > 0:
        msg1 = "\n".join(map(str, params))
        msg = "Set players to unlocked\n\n%s\n\n%s" % (queries[-1], msg1)
        #zc.send_telegram(msg, bot_token)
        
    
        print ("Execute %d queries." % (len(queries)))
        conn, cursor = mysql_connect("LR")
        for q, p in zip(queries, params):
                
            if '--show-queries' in sys.argv: print ("Query {:<40} {}" .format (q.split("(")[0].strip(), str(p)))
            cursor.execute(q, p)
        
        
        if '--no-commit' not in sys.argv: conn.commit()
        cursor.close(); conn.close()
    

    # Swap out the original team code with the LR Public url
    for m in team_matches:
        league_teams = [z for z in teams if z['league'] == m['league']]
        tmp = None
        if m['clean'] in [z['name'].upper() for z in league_teams]:
            tmp = league_teams[ [z['name'].upper() for z in league_teams].index(m['clean'])]
            m['orig'] = tmp['name']
        elif m['clean'] in [z['display_name'].upper() for z in league_teams]:
            tmp = league_teams[ [z['display_name'].upper() for z in league_teams].index(m['clean'])]
            m['orig'] = tmp['display_name']
        elif m['clean'] in [z['short_code'].upper() for z in league_teams]:
            tmp = league_teams[ [z['short_code'].upper() for z in league_teams].index(m['clean'])]
            m['orig'] = tmp['short_code']
        if tmp is not None:
            url = "<a href='%s'>%s</a>" % (tmp['laxref_team_url'], m['orig'])
            html = html.replace(m['full'], url)
        else:
            result_msg += "\n\nFailed to convert team name: %s" % (m['clean']); fails += 1
    if fails > 0:
        zc.send_telegram(result_msg, bot_token)
        
    return html


def build_team_conference_data(team_rec, conferences, specs):
    
    conference = conferences[ [z['ID'] for z in conferences].index(team_rec['conference_ID']) ]
    conference = conferences[ [z['ID'] for z in conferences].index(team_rec['conference_ID']) ]
    team_rec['conference_name'] = conference['name']
    team_rec['conference_short_code'] = conference['short_code']
    return team_rec

def strip_away(team_rec, misc, specs):

   
    for g in team_rec['season_games']:

        #g['game_date'] = None

        g['opp_def_summaries'] = None
        g['opp_off_summaries'] = None
        #if 'most_recent' in g and not g['most_recent']:
        #    g['summaries'] = None
    #team_rec['season_games'] = json.loads(json.dumps( team_rec['season_games'] ))
    team_rec['last_game_date'] = None
        

    if 'last_game' in team_rec and team_rec['last_game'] is not None:
        team_rec['last_game']['game_date'] = None
        team_rec['last_game']['last_LR_upload'] = None
        team_rec['last_game']['last_updated'] = None
        team_rec['last_game']['opp_def_summaries'] = None
        team_rec['last_game']['opp_off_summaries'] = None
        team_rec['last_game'] = json.loads(json.dumps( team_rec['last_game'] ))

    if 'season_games' in team_rec:
        for ts in team_rec['season_games']:
            ts['opp_team_season'] = None

    if '--check-for-dates' in sys.argv:
        reg = re.compile(r'[\'\"]([a-z_]+)[\'\"]:\sdatetime', re.IGNORECASE)

        for k in team_rec.keys():
            if "datetime" in str(team_rec[k]):

                matches = sorted([z for z in list(set(re.findall(reg, str(team_rec[k]))))])
                print (" Found a datetime in team_rec.%s\n\n - %s" % (k, "\n - ".join(matches)))
        for k in misc.keys():
            if "datetime" in str(misc[k]):
                matches = sorted([z for z in list(set(re.findall(reg, str(misc[k]))))])
                print (" Found a datetime in misc.%s\n\n - %s" % (k, "\n - ".join(matches)))
    
    team_rec['next_game'] = "{REMOVED}"
    return team_rec, misc

def strip_away_new(team_rec, specs):

   
    team_rec['last_game_date'] = None

    if 'last_game' in team_rec and team_rec['last_game'] is not None:
        team_rec['last_game']['game_date'] = None
        team_rec['last_game']['last_LR_upload'] = None
        team_rec['last_game']['last_updated'] = None
        team_rec['last_game']['opp_def_summaries'] = None
        team_rec['last_game']['opp_off_summaries'] = None
        #team_rec['last_game'] = json.loads(json.dumps( team_rec['last_game'] ))

    if 'next_game' in team_rec and team_rec['next_game'] is not None:
        team_rec['next_game']['game_date'] = None
        team_rec['next_game']['last_LR_upload'] = None
        team_rec['next_game']['last_updated'] = None
        team_rec['next_game']['opp_def_summaries'] = None
        team_rec['next_game']['opp_off_summaries'] = None
    
    if 'season_games' in team_rec:
        for ts in team_rec['season_games']:
            ts['opp_team_season'] = None

        for g in team_rec['season_games']:

            #g['game_date'] = None

            g['opp_def_summaries'] = None
            g['opp_off_summaries'] = None
            #if 'most_recent' in g and not g['most_recent']:
            #    g['summaries'] = None
        #team_rec['season_games'] = json.loads(json.dumps( team_rec['season_games'] ))
    
    if '--check-for-dates' in sys.argv:
        reg = re.compile(r'[\'\"]([a-z_]+)[\'\"]:\sdatetime', re.IGNORECASE)

        for k in team_rec.keys():
            if "datetime" in str(team_rec[k]):

                matches = sorted([z for z in list(set(re.findall(reg, str(team_rec[k]))))])
                print (" Found a datetime in team_rec.%s\n\n - %s" % (k, "\n - ".join(matches)))
    return team_rec

def scrape_game_url_from_ncaa_list(url, dt):
    game_url = None
    import urllib3
    link_regexes = []
    link_regexes.append({'regex': re.compile(r'>([0-9]+/[0-9]+/[0-9]+)</td>[\s\S]+?<a[^>]*?href=\"(/game/index/[0-9]+\?org_id=[0-9]+)\"', re.IGNORECASE)})
    link_regexes.append({'regex': re.compile(r'>([0-9]+/[0-9]+/[0-9]+)</td>[\s\S]+?<a[^>]*?href=\"(/contests/[0-9]+/box_score)\"', re.IGNORECASE)})
    
    user_agent = {'user-agent': 'Mozilla/5.0 (Windows NT 6.3; rv:36.1) ..'}

    http = urllib3.PoolManager(10, headers=user_agent); r = http.request('GET', url, timeout=20)
    data = r.data
    if isinstance(data, bytes):
        data = data.decode("utf8")
    
    matches = []
    for link_regex in link_regexes:
        matches += [{'dt': None, 'dt_str': z[0], 'url': 'https://stats.ncaa.org%s' % z[1]} for z in re.findall(link_regex['regex'], data)]
    for m in matches:
        try:
            m['dt'] = datetime.strptime(m['dt_str'], "%m/%d/%Y")
        except Exception:
            pass
            
    missing_dates = [z for z in matches if 'dt' not in z]
    matches = [z for z in matches if 'dt' in z]
    
    for m in matches:
        m['dt_clean'] = m['dt'].strftime("%Y%m%d")
        m['match'] = 0
        if (isinstance(dt, datetime) and dt.strftime("%Y%m%d") == m['dt_clean']) or dt == m['dt_clean']:
            m['match'] = 1
            return m['url']
    
    return None
    
def build_future_games(team_rec, misc, specs):


    scheduled_games = [z for z in misc['games'] if z['status'] in ["scheduled"] and z['game_year'] == specs['year']]
    team_rec['future_games'] = None

    if len(scheduled_games) > 0:
        team_rec['future_games'] = [{'opponentID': z['opponentID'], 'faceoff_win_rate_color': z['faceoff_win_rate_color'], 'def_efficiency_inverted_color': z['def_efficiency_inverted_color'], 'off_efficiency_color': z['off_efficiency_color'], 'date_mmmdd': z['date_mmmdd'], 'ID': z['ID'], 'opp_short_code': z['opp_short_code'], 'avg_RPI_with_loss': z['avg_RPI_with_loss'], 'avg_RPI_with_win': z['avg_RPI_with_win']} for z in sorted(scheduled_games,key=lambda x:x['game_epoch'])][0:6]
        for i, g in enumerate(team_rec['future_games']):
            g['next'] = 1 if i == 0 else 0

    return team_rec

def build_next_game_team_summaries(team_rec, specs):
    if team_rec['next_game'] is not None:
        team_rec['next_game']['history'] = sorted([{'ID': z['game_ID'], 'game_epoch': z['game_epoch'], 'game_date': z['game_date'], 'this_year': z['this_year'], 'opponentID': z['opp_team_ID'], 'opp_short_code': z['opp_short_code'], 'off_efficiency': z['efficiency'], 'faceoff_win_rate': z['faceoff_win_rate']} for z in team_rec['next_game']['opp_off_summaries']], key=lambda x:x['game_epoch'], reverse=True)
        for g in team_rec['next_game']['history']:
            g['date_sequence'] = len([1 for z in team_rec['next_game']['history'] if z['game_epoch'] >= g['game_epoch']])

        for g in team_rec['next_game']['history']:
            tmp = team_rec['next_game']['opp_def_summaries'][ [z['game_epoch'] for z in team_rec['next_game']['opp_def_summaries']].index(g['game_epoch'])]
            g['def_efficiency'] = tmp['efficiency']
            g['def_efficiency_inverted'] = 1. - tmp['efficiency']
            if None in [g['off_efficiency'], g['def_efficiency_inverted'], g['faceoff_win_rate']]:
                g['basic_aggregate'] = None
            else:
                g['basic_aggregate'] = g['off_efficiency'] + g['def_efficiency_inverted'] + g['faceoff_win_rate']



        for g in team_rec['next_game']['history']:
            for tmp in ['off_efficiency', 'def_efficiency_inverted', 'faceoff_win_rate']:
                g['adj_%s' % tmp] = None
                g['pct_%s' % tmp] = None
                g['color_%s' % tmp] = "#777"

                if team_rec['10_90_range_%s' % tmp] is not None:
                    #print team_rec['10_90_range_off_efficiency']
                    inc = (team_rec['10_90_range_%s' % tmp][1] - team_rec['10_90_range_%s' % tmp][0]) * .5
                    rng = (team_rec['10_90_range_%s' % tmp][1] + inc) - (team_rec['10_90_range_%s' % tmp][0] - inc)
                    
                    if team_rec['10_90_range_%s' % tmp][0] is None:
                        msg = "Error in laxref.build_next_game_team_summaries"
                        msg += "\n[what happened?]"
                        msg += "\n[how do i fix it?]"
                        msg += "\n\nExiting..."
                        print (msg)
                        zc.send_telegram(msg, bot_token)
                        zc.exit("laxref0009")
                    elif g[tmp] is None and tmp == "faceoff_win_rate":
   
                        msg = "Error in laxref.build_next_game_team_summaries. We are trying to understand how the next opponent's recent games rank along FO/Draws, but the value of faceoff_win_rate was null"
                        msg += "\nThe value of %s in game %d for %s (%s ID %d) was None" % (tmp, g['ID'], team_rec['next_game']['opponent_display'], team_rec['league'], team_rec['next_game']['opponentID'])
                        msg += "\nThis is often an issue with some of the play by play not being uploaded correctly. Run this: SELECT faceoff_wins, faceoff_losses, faceoff_win_rate from LaxRef_Team_Game_Summaries where ISNULL(filter)  and data_type='offense'  and game_ID=%d and team_ID=%d" % (g['ID'], team_rec['next_game']['opponentID'])
                        msg += "\nIf the are zero/None, then you might try to re-pull the play by play data using this command:\npython get_official_ncaa_game_data.py --replace-plays --game-ID %d -league \"%s\" -u [play by play link for the game] \n" % (g['ID'], team_rec['league'])
                        msg += "\n\nExiting..."
                        print (msg)
                        zc.send_crash(msg, bot_token)
                        zc.exit("laxref0010")
                        
                    elif g[tmp] is None:
                        msg = "Error in laxref.build_next_game_team_summaries. We are trying to understand how the next opponent's recent games rank along FO/Draws and Off/Def Eff, but a value was null"
                        msg += "\nThe value of %s in game %d for %s (%s ID %d) was None" % (tmp, g['ID'], team_rec['next_game']['opponent_display'], team_rec['league'], team_rec['next_game']['opponentID'])
                        msg += "\nThis is often an issue with some of the play by play not being uploaded correctly. Run this: SELECT faceoff_wins, faceoff_losses, faceoff_win_rate from LaxRef_Team_Game_Summaries where ISNULL(filter)  and data_type='offense'  and game_ID=%d and team_ID=%d" % (g['ID'], team_rec['next_game']['opponentID'])
                        msg += "\nIf the are zero/None, then you might try to re-pull the play by play data using this command:\npython get_official_ncaa_game_data.py --replace-plays --game-ID %d -league \"%s\" -u [play by play link for the game] \n" % (g['ID'], team_rec['league'])
                        msg += "\nIf there are no rows at all, then you might try to refresh the game dict and summary tables using this command:\npython view_game_details.py -g %d --refresh-game-dict --use-fast-upload -basic\n" % (g['ID'])
                        msg += "\n\nExiting..."
                        print (msg)
                        zc.send_crash(msg, bot_token)
                        zc.exit("laxref0011")
                        
                        
                    g['adj_%s' % tmp] = g[tmp] - (team_rec['10_90_range_%s' % tmp][0] - inc)
                    g['pct_%s' % tmp] = min(max(0., .5 if rng == 0 else g['adj_%s' % tmp]/rng), 1.)
                    g['color_%s' % tmp] = zc.pct_to_red_green_scale(g['pct_%s' % tmp])

        team_rec['next_game']['history_num_this_year'] = len([1 for z in team_rec['next_game']['history'] if z['this_year'] == 1])

    return team_rec

def build_league_averages(team_rec, summaries, all_summaries, specs):
    off_summaries_exclusive = [z for z in summaries if z['game_ID'] != team_rec['last_game_ID'] and z['data_type']=='offense' and z['team_ID'] == team_rec['ID']]
    def_summaries_exclusive = [z for z in summaries if z['game_ID'] != team_rec['last_game_ID'] and z['data_type']=='defense' and z['team_ID'] == team_rec['ID']]

    league_off_summaries = [z for z in all_summaries if z['filter'] is None and z['league'] == team_rec['league'] and z['data_type']=='offense']
    league_def_summaries = [z for z in all_summaries if z['filter'] is None and z['league'] == team_rec['league'] and z['data_type']=='defense']

    team_rec['faceoff_win_rate_exclusive'] = None
    total_wins = sum([z['faceoff_wins'] for z in off_summaries_exclusive])
    total_faceoffs = sum([z['faceoff_wins']+z['faceoff_losses'] for z in off_summaries_exclusive])
    if total_faceoffs > 0:
        team_rec['faceoff_win_rate_exclusive'] = total_wins/total_faceoffs


    team_off_posss = sum([z['possessions'] for z in off_summaries_exclusive])
    team_rec['off_efficiency_exclusive'] = None; team_rec['def_efficiency_exclusive'] = None; team_rec['def_efficiency_inverted_exclusive'] = None
    if team_off_posss > 0:
        team_rec['off_efficiency_exclusive'] = sum([z['goals'] for z in off_summaries_exclusive])/team_off_posss

    team_def_poss = sum([z['possessions'] for z in def_summaries_exclusive])
    if team_def_poss > 0:
        team_rec['def_efficiency_exclusive'] = sum([z['goals'] for z in def_summaries_exclusive])/team_def_poss
        team_rec['def_efficiency_inverted_exclusive'] = 1. - team_rec['def_efficiency_exclusive']


    total_league_faceoffs = sum([z['faceoff_wins']+z['faceoff_losses'] for z in league_off_summaries])
    team_rec['league_faceoff_win_rate'] = None
    if total_league_faceoffs > 0:
        team_rec['league_faceoff_win_rate'] = sum([z['faceoff_wins'] for z in league_off_summaries])/total_league_faceoffs

    league_off_poss = sum([z['possessions'] for z in league_off_summaries])
    league_def_poss = sum([z['possessions'] for z in league_def_summaries])
    team_rec['league_off_efficiency'] = None; team_rec['league_def_efficiency'] = None; team_rec['league_def_efficiency_inverted'] = None
    if league_off_poss > 0:
        team_rec['league_off_efficiency'] = sum([z['goals'] for z in league_off_summaries])/league_off_poss

    if league_def_poss > 0:
        team_rec['league_def_efficiency'] = sum([z['goals'] for z in league_def_summaries])/league_def_poss
        team_rec['league_def_efficiency_inverted'] = 1. - team_rec['league_def_efficiency'];

    return team_rec

def build_film_guide(team_ID, poss_list, all_games, teams, specs):

    res = {'offense': {}, 'offense_good': {}, 'defense': {}, 'defense_good': {}}
    for unit_tag in [
    {'tag': 'offense', 'reverse': False, 'data_type': 'offense', 'desc': 'offensive', 'opp': 'defense'}
    , {'tag': 'defense', 'reverse': True, 'data_type': 'defense', 'desc': 'defensive', 'opp': 'offense'}
    , {'tag': 'offense_good', 'reverse': True, 'data_type': 'offense', 'desc': 'offensive', 'opp': 'defense'}
    , {'tag': 'defense_good', 'reverse': False, 'data_type': 'defense', 'desc': 'defensive', 'opp': 'offense'}
    ]:
        poss = []
        if specs['year'] in poss_list:
            poss = [z for z in poss_list[specs['year']] if z['team_ID' if unit_tag['data_type'] == "offense" else "opp_ID"] == team_ID]

        if len(poss) < 250:
            gap = 250 - len(poss)
            poss += [z for z in poss_list[specs['last_year']] if z['team_ID' if unit_tag['data_type'] == "offense" else "opp_ID"] == team_ID][0:gap]


        #print ("{:<40} @ {}".format ("     I have %d possessions to analyze" % len(poss), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

        for ip, p in enumerate(poss):
            p['seq'] = ip + 1

        for ip, p in enumerate(poss):


            #if ip % 10 == 0: print ("{:<40} @ {}".format ("        Find end-points  %d/%d" % (ip+1, len(poss)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            p['game_poss'] = [z for z in poss if z['game_ID'] == p['game_ID'] and z['seq'] != p['seq']]

            for gp in p['game_poss']:
                gp['end_time'] = gp['start_time'] +  gp['duration']
            if len(p['game_poss']) > 0:
                p['stretch_ends'] = []
                for stretch_length in range(10,11):
                    tmp = sorted(p['game_poss'], key=lambda x:(abs((x['start_time'] - stretch_length*60.) - p['start_time'])))[0]
                    if abs((tmp['start_time'] - stretch_length*60.) - p['start_time']) < 180:
                        p['stretch_ends'].append(tmp)
                    else:
                        p['stretch_ends'].append(None)

            else:
                p['stretch_ends'] = None

        #print ("{:<40} @ {}".format ("     completed lax_elo_history", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        # Find the 5 to 10 minute stretches that have the worst relative performance
        # Display the relative efficiencies before and after, so contrast where in the film things change
        stretches = []
        for ip, p in enumerate(poss):

            if p['stretch_ends'] not in [{}, None]:
                for ie, end_point in enumerate(p['stretch_ends']):
                    if end_point is not None:
                        encompassing = [z for z in p['game_poss'] if  end_point['seq'] < z['seq'] <= p['seq']]

                        if len(encompassing) > 0:
                            n = float(len(encompassing))
                            stretch = {'stretch_length': 11 + ie, 'game_ID': p['game_ID'], 'end_seq': end_point['seq'], 'start_seq': p['seq'], 'start_time': p['start_time'], 'duration': sum([z['duration'] for z in encompassing])}
                            stretch['end_time'] = max([z['end_time'] for z in encompassing])
                            
                            stretch['possessions'] = n
                            stretch['avg_length'] = None if stretch['possessions'] == 0 else sum([z['duration'] for z in encompassing])/stretch['possessions']
                            stretch['goals'] = sum([z['goal'] for z in encompassing])
                            stretch['shots'] = sum([z['num_shots'] for z in encompassing])
                            stretch['shooting_pct'] = None if stretch['shots'] == 0 else stretch['goals']/stretch['shots']
                            stretch['turnovers'] = sum([z['turnover'] for z in encompassing])
                            stretch['turnover_rate'] = None if stretch['possessions'] == 0 else stretch['turnovers']/stretch['possessions']
                            stretch['sog'] = sum([z['shots_on_goal'] for z in encompassing])
                            stretch['efficiency'] = stretch['goals']/stretch['possessions']
                            stretch['seq'] = len(stretches) + 1
                            stretches.append(stretch)

        #print "Found {:,} unique stretches.".format(len(stretches))
        for i, stretch in enumerate(stretches):
            #zc.print_dict(stretch)

            stretch['previous_stretch'] = None; stretch['next_stretch'] = None

            if stretch['start_seq'] in [z['end_seq'] for z in stretches]:
                stretch['previous_stretch'] = stretches[ [z['end_seq'] for z in stretches].index(stretch['start_seq']) ]
            if stretch['end_seq'] in [z['start_seq'] for z in stretches]:
                stretch['next_stretch'] = stretches[ [z['start_seq'] for z in stretches].index(stretch['end_seq']) ]

            stretch['vs_previous'] = None; stretch['vs_next'] = None
            if stretch['next_stretch'] is not None:
                stretch['vs_next'] = stretch['efficiency'] - stretch['next_stretch']['efficiency']
            if stretch['previous_stretch'] is not None:
                stretch['vs_previous'] = stretch['efficiency'] - stretch['previous_stretch']['efficiency']
            if None not in [stretch['vs_next'], stretch['vs_previous']]:
                stretch['agg_diff'] = stretch['vs_next'] * .75 + stretch['vs_previous']
            elif None == stretch['vs_next'] and stretch['vs_previous'] is not None:
                stretch['agg_diff'] = stretch['vs_previous']
            elif None == stretch['vs_previous'] and stretch['vs_next'] is not None:
                stretch['agg_diff'] = stretch['vs_next'] * .75
            else:
                stretch['agg_diff'] = None

        #print "      {:,} are missing a previous stretch.".format(len([z for z in stretches if z['previous_stretch'] is None]))
        #print "      {:,} are missing a next stretch.".format(len([z for z in stretches if z['next_stretch'] is None]))
        for i, stretch in enumerate(stretches):
            stretch['previous_stretch'] = None; stretch['next_stretch'] = None

        stretches = [z for z in stretches if z['agg_diff'] is not None and z['possessions'] > 1]
        #print "      {:,} qualifying stretches (w/ agg diff).".format(len(stretches))

        stretches = sorted(stretches, key=lambda x:x['agg_diff'], reverse=unit_tag['reverse'])

        res[unit_tag['tag']]['key_stretches'] = stretches[0:10]
        for s in res[unit_tag['tag']]['key_stretches']:
            g = all_games[ [z['ID'] for z in all_games].index(s['game_ID']) ]
            s['opponentID'] = g['home_ID'] if g['away_ID'] == team_ID else g['away_ID']
            opp = teams[ [z['ID'] for z in teams].index(s['opponentID']) ]
            s['opponent'] = opp['display_name']
            s['opp_short_code'] = opp['short_code']
            s['game_date_str'] = g['game_date_str']
            s['short_date_str'] = g['short_date_str']
            s['start_timestamp'] = convert_pct_complete_to_time_str(s['start_time']/3600., g['game_year'], g['league'])
            s['end_timestamp'] = convert_pct_complete_to_time_str(s['end_time']/3600., g['game_year'], g['league'])
            s['removed'] = 0
            s['last_year'] = 1 if g['game_year'] == specs['year'] - 1 else 0
            s['next_year'] = 1 if g['game_year'] == specs['year'] + 1 else 0

        for s in res[unit_tag['tag']]['key_stretches']:
            overlaps = [z for z in res[unit_tag['tag']]['key_stretches'] if z['game_ID'] == s['game_ID'] and not z['removed'] and z['end_time'] > s['start_time'] > z['start_time']]
            if len(overlaps) > 0:
                if unit_tag['tag'] == "offense":
                    overlap_seq = [z['seq'] for z in overlaps]
                    if s['agg_diff'] < min([z['agg_diff'] for z in overlaps]):
                        for io, o in enumerate(res[unit_tag['tag']]['key_stretches']):
                            if o['seq'] in overlap_seq: o['removed'] = 1

                    else:
                        s['removed'] = 1
                        for io, o in enumerate(res[unit_tag['tag']]['key_stretches']):
                            if o['seq'] in overlap_seq:
                                s['removed'] = (0 if io == 0 and s['removed'] != 1 else 1)
                else:
                    overlap_seq = [z['seq'] for z in overlaps]
                    if s['agg_diff'] > max([z['agg_diff'] for z in overlaps]):
                        for io, o in enumerate(res[unit_tag['tag']]['key_stretches']):
                            if o['seq'] in overlap_seq: o['removed'] = 1

                    else:
                        s['removed'] = 1
                        for io, o in enumerate(res[unit_tag['tag']]['key_stretches']):
                            if o['seq'] in overlap_seq:
                                s['removed'] = (0 if io == 0 and s['removed'] != 1 else 1)

        #print "\n{:<15}{:<15}{:<15}{:<15}{:>20}{:>20}{:>20}{:>20}{:>20}".format("Game ID", "Opp", "Start Time", "End Time", 'Duration', "# Poss", "Efficiency", "vs Previous/Next", "Agg Diff")
        #print "-" * 145
        res[unit_tag['tag']]['key_stretches'] = [z for z in res[unit_tag['tag']]['key_stretches'] if not z['removed']]
        #for s in res[unit_tag['tag']]['key_stretches']:
        #    print "{:<15}{:<15}{:<15}{:<15}{:>20.0f}{:>20}{:>20.3f}{:>20}{:>20.3f}".format(s['game_ID'], s['opp_short_code'], s['start_timestamp'], s['end_timestamp'], s['duration'], s['possessions'], s['efficiency'], "%s / %s" % ("N/A" if s['vs_previous'] is None else ("%.3f" % (s['vs_previous'])), "N/A" if s['vs_next'] is None else ("%.3f" % (s['vs_next']))), s['agg_diff'])

    #zc.print_dict(res)
    res['offense_bad'] = res['offense']
    res['defense_bad'] = res['defense']
    print ("{:<40} @ {}".format ("  completed build_film_guide", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
    return res

def clean_product_player_data_generic(misc, user_obj):
    return misc, user_obj

def build_product_data_player(user_obj, misc, noauth=0):
    
    """
    This function queries the database to create a profile of a particular player. That also requires pulling all players so that career rankings can be established on the fly (even without an update to all the JSONs). The sub function is separated so that we can calculate the rankings separately from pulling the data required to do so.
    
    misc['year'] or the LRP_User_Settings table specifies which year to use to generate the statistical profile. misc['year'] usually defaults to the current year, but if they have specified that they want to see a different year (via the gear toggle on the front-end), that's when the LRP_User_Settings value would be used.
    """
    
    is_unlocked = 0
            
    misc['meta_tags'] = ""
    def build_product_data_player_stat_rankings_from_percentiles(misc, cur_year_player_percentiles, player_career_percentiles):
        """
        This function calculates, for a given player, their career and season percentile rankings across a range of position-relevant statistics.
        """
        lg(" in build_product_data_player_stat_rankings_from_percentiles...")
        if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Build Player Stat Rankings: Stat Keys/Role', 'start': ms()})
        misc['stat_keys'] = []
        misc['stat_keys'].append({'reverse': 0, 'tag': 'excess_saves', 'display': 'Excess Saves', 'short': 'Saves', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'excess_saves_per_sog', 'display': 'Excess Saves/Att', 'short': 'eSaves/Att', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'EGA_per_game', 'display': 'EGA/game', 'short': 'EGA/gm', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'usage_adjusted_EGA', 'display': 'Usage-Adjusted EGA', 'short': 'uaEGA', 'fmt': '{:.2f}', 'jsfmt': '3'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'weighted_team_play_shares', 'display': 'Play Shares', 'short': 'play%', 'fmt': '{:.1}%', 'jsfmt': '1%'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'EGA', 'display': 'Expected Goals Added', 'short': 'EGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'offensive_EGA', 'display': 'Offensive EGA', 'short': 'oEGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'defensive_EGA', 'display': 'Defensive EGA', 'short': 'dEGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'faceoff_EGA', 'display': 'Faceoff EGA', 'short': 'fEGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'excess_goals_per_shot', 'display': 'eGoals/Shot', 'short': 'eG/sh', 'fmt': '{:.3f}', 'jsfmt': '3'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'save_pct', 'display': 'Save Percentage', 'short': 'Save %', 'fmt': '{:.0f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'caused_turnovers', 'display': 'Caused Turnovers', 'short': 'CT', 'fmt': '{:.0f}', 'jsfmt': '0'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'caused_turnover_to_penalty_ratio', 'display': 'Caused TO:Pen', 'short': 'CT:Pen', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'shooting_pct', 'display': 'Shooting Percentage', 'short': 'Shot%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'shooting_efficiency', 'display': 'Shooting Efficiency', 'short': 'ShEff', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'on_goal_shooting_pct', 'display': 'On-Goal Shot%', 'short': 'ogSh%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'sog_rate', 'display': 'Shot-on-Goal Rate', 'short': 'SOG%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'reverse': 1, 'tag': 'turnover_rate', 'display': 'Turnover Rate', 'short': 'TO%', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'assist_to_turnover_ratio', 'display': 'Assist:TO', 'short': 'Asst:TO', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'share_adjusted_assist_rate', 'display': 'Assist Rate', 'short': 'Asst Rate', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'faceoff_win_rate', 'display': 'Faceoff Win%', 'short': 'FO%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'share_of_all_gbs', 'display': 'GB%', 'short': 'GB Win%', 'fmt': '{:.1f}%', 'jsfmt': '1%'})
        
        if 'league' in misc['player_data'] and misc['player_data']['league'] is not None and "Women" not in misc['player_data']['league']:
            misc['stat_keys'].append({'reverse': 0, 'tag': 'faceoff_ELO', 'display': 'Faceoff Elo', 'short': 'fElo', 'fmt': '{:.0f}', 'jsfmt': '0'})
        
        
        if misc['player_data']['player_career_stats'] is not None:    
            # Assign player role
            if misc['player_data']['current_season'] is not None and misc['player_data']['current_season']['games_appeared_in'] is not None and misc['player_data']['current_season']['games_appeared_in'] > 0 and cur_year_player_percentiles is not None:
                off_val = 0. if misc['player_data']['current_season']['offensive_EGA'] is None else abs(misc['player_data']['current_season']['offensive_EGA'])
                def_val = 0. if misc['player_data']['current_season']['defensive_EGA'] is None else abs(misc['player_data']['current_season']['defensive_EGA'])
                fogo_val = 0. if misc['player_data']['current_season']['faceoff_EGA'] is None else abs(misc['player_data']['current_season']['faceoff_EGA'])
                misc['player_data']['current_season']['role'] = assign_player_role(misc['player_data'], off_val, def_val, fogo_val, misc['player_data']['current_season']['shots_faced'], misc['player_data']['current_season']['faceoff_wins'], misc['player_data']['current_season']['team_listed_role'])
                misc['player_data']['player_career_stats']['role'] = misc['player_data']['current_season']['role']
            else:
                misc['player_data']['player_career_stats']['role'] = assign_player_role(misc['player_data'], 0, 0, 0, misc['player_data']['player_career_stats']['shots_faced'], misc['player_data']['player_career_stats']['faceoff_wins'], None)
            
            
            cur_keys = ['excess_saves', 'excess_saves_per_sog', 'EGA_per_game', 'share_adjusted_assist_rate', 'assist_to_turnover_ratio', 'usage_adjusted_EGA', 'EGA', 'offensive_EGA', 'defensive_EGA', 'faceoff_EGA', 'excess_goals_scored', 'save_pct', 'caused_turnovers','on_goal_shooting_pct', 'shooting_efficiency',  'shooting_pct', 'share_of_all_gbs', 'sog_rate', 'faceoff_win_rate', 'faceoff_ELO']
            
            #lg("Player Role: %s ( also %s)" % (misc['player_data']['player_career_stats']['role'], misc['player_data']['current_season']['role']))
            if misc['player_data']['player_career_stats']['role'] is None:
                keep_key_tags = ['weighted_team_play_shares', 'shooting_efficiency', 'on_goal_shooting_pct', 'usage_adjusted_EGA', 'EGA_per_game', 'EGA', 'offensive_EGA', '', '', 'excess_goals_scored', 'share_of_all_gbs', 'turnover_rate', 'share_of_team_assists', 'shooting_pct', 'sog_rate', 'share_adjusted_assist_rate', 'assist_to_turnover_ratio']
                
            elif misc['player_data']['player_career_stats']['role'] == "offensive":
                keep_key_tags = ['weighted_team_play_shares', 'shooting_efficiency', 'on_goal_shooting_pct', 'usage_adjusted_EGA', 'EGA_per_game', 'EGA', 'offensive_EGA', '', '', 'excess_goals_scored', 'share_of_all_gbs', 'turnover_rate', 'share_of_team_assists', 'shooting_pct', 'sog_rate', 'share_adjusted_assist_rate', 'assist_to_turnover_ratio']
              
            elif misc['player_data']['player_career_stats']['role'] == "defensive":
                keep_key_tags = ['', '', 'EGA_per_game', 'EGA', '', 'share_of_all_gbs', 'defensive_EGA', '', '', 'caused_turnover_to_penalty_ratio', 'caused_turnovers', '', '', '', '']
              
            elif misc['player_data']['player_career_stats']['role'] == "goalkeeper":
                keep_key_tags = ['save_pct', 'excess_saves', 'excess_saves_per_sog']
              
            elif misc['player_data']['player_career_stats']['role'] == "faceoff":
                keep_key_tags = ['weighted_team_play_shares', 'usage_adjusted_EGA', 'share_of_team_assists', 'EGA_per_game', 'EGA', '', '', 'faceoff_EGA', 'excess_goals_scored', '', 'on_goal_shooting_pct', 'shooting_pct', 'shooting_efficiency', 'turnover_rate', 'faceoff_win_rate', 'faceoff_ELO']
            
            for sk in misc['stat_keys']:
                sk['exclude'] = 0 if sk['tag'] in keep_key_tags else 1
        else:
            for sk in misc['stat_keys']:
                sk['exclude'] = 1
        
        # Calculate Season Stats
        check1 = 1 or app.config['ON_SERVER']
        check2 = misc['player_data']['current_season'] is not None
        check3 = cur_year_player_percentiles is not None
        lg("Checks: %s" % ", ".join(map(str, [check1, check2, check3])))
        
        if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Build Player Stat Rankings: Calc Season Percentiles', 'start': ms()})
        
        if check1 and check2 and check3:
            tmp_role = misc['player_data']['player_career_stats']['role']
            for i, sk in enumerate(misc['stat_keys']):
                
     
                sk['seq'] = i
                if 'label_fmt' not in sk: sk['label_fmt'] = sk['fmt']
            
                sk['points'] = None
                if not sk['exclude']:
                    sk['me_str'] = "N/A"
                    if misc['player_data']['current_season'][sk['tag']] is not None:
                        if "%" in sk['fmt']:
                            sk['me_str'] = sk['fmt'].format(100. * misc['player_data']['current_season'][sk['tag']]); 
                        else:
                            sk['me_str'] = sk['fmt'].format(misc['player_data']['current_season'][sk['tag']]); 
                    
                        percentiles = cur_year_player_percentiles[sk['tag']][tmp_role]['percentiles']

                        if percentiles is None or len(percentiles) == 0:
                            sk['insufficient_data'] = 1
                            sk['percentile'] = None
                        else:
                            if sk['reverse']:
                                tmp_list = [z[0] for z in percentiles if misc['player_data']['current_season'][sk['tag']] <= z[1]]
                                if len(tmp_list) == 0:
                                    sk['percentile'] = 1
                                else:
                                    sk['percentile'] = max(tmp_list) - 1
                            else:
                                tmp_list = [z[0] for z in percentiles if misc['player_data']['current_season'][sk['tag']] >= z[1]]
                                if len(tmp_list) == 0:
                                    sk['percentile'] = 1
                                else:
                                    sk['percentile'] = max(tmp_list)
                            
            
                        if sk['percentile'] is not None:
                            sk['percentile_str'] = "%d%s" % (sk['percentile'], zc.get_number_suffix(sk['percentile']))
                            misc['player_data']['current_season']["%s_percentile" % sk['tag']] = sk['percentile']/100.
                        else:
                            sk['percentile_str'] = "N/A"
                            misc['player_data']['current_season']["%s_percentile" % sk['tag']] = None
                        #input("%s %s %s" % (sk['tag'], sk['percentile'], sk['percentile_str']))
                        
                    else:
                        sk['insufficient_data'] = 0

                
            
        
        # Calculate Career Ranks
        if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Build Player Stat Rankings: Calc Career Percentiles/Ranks', 'start': ms()})
        
        if misc['player_data']['player_career_stats'] is not None and player_career_percentiles is not None:
            off_val = 0. if misc['player_data']['player_career_stats']['offensive_EGA'] is None else abs(misc['player_data']['player_career_stats']['offensive_EGA'])
            def_val = 0. if misc['player_data']['player_career_stats']['defensive_EGA'] is None else abs(misc['player_data']['player_career_stats']['defensive_EGA'])
            fogo_val = 0. if misc['player_data']['player_career_stats']['faceoff_EGA'] is None else abs(misc['player_data']['player_career_stats']['faceoff_EGA'])
            
            
            tmp_role = misc['player_data']['player_career_stats']['role']
            for sk in misc['stat_keys']:
                
                if not sk['exclude']:
                    
                    #lg("A count: {:,}".format(len(player_careers)))
                    #stat_vals = sorted([z[sk['tag']] for z in player_careers if z[sk['tag']] not in [None]])
                    
                    if misc['player_data']['player_career_stats'][sk['tag']] is None:
                        sk['insufficient_data'] = 1
                        sk['career_percentile'] = None
                        sk['career_percentile_str'] = "N/A"
                    else:
                        percentiles = None if sk['tag'] in ["share_of_all_gbs"] else player_career_percentiles[sk['tag']][tmp_role]['percentiles']
                        
                        if percentiles is None or len(percentiles) == 0:
                            sk['insufficient_data'] = 1
                            sk['career_percentile'] = None
                            sk['career_percentile_str'] = "N/A"
                        else:
                            if sk['reverse']:
                                tmp_list = [z[0] for z in percentiles if misc['player_data']['player_career_stats'][sk['tag']] < z[1]]
                                if len(tmp_list) == 0:
                                    sk['career_percentile'] = 1
                                else:
                                    sk['career_percentile'] = max(tmp_list)
                            else:
                                tmp_list = [z[0] for z in percentiles if misc['player_data']['player_career_stats'][sk['tag']] > z[1]]
                                if len(tmp_list) == 0:
                                    sk['career_percentile'] = 1
                                else:
                                    sk['career_percentile'] = max(tmp_list)
                            sk['career_percentile_str'] = "%d%s" % (sk['career_percentile'], zc.get_number_suffix(sk['career_percentile']))    
                    
        return misc
        
    if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Query misc.player_data', 'start': ms()})
            
    if 'year' not in misc or misc['year'] is None:
        misc['year'] = datetime.now().year
    

    if misc['target_template'] not in ["basic_home.html", "team_home.html"] and user_obj is not None and 'settings' in user_obj and 'player_focus_year' in user_obj['settings'] and user_obj['settings']['player_focus_year'] is not None:
        misc['year'] = int(user_obj['settings']['player_focus_year']['val'])
  
    
    now = datetime.now()

        
    data = None
    #lg("Building product data (player)...")
    tmp = {}
    misc['player_data'] = None
    embed_obj = {'year': misc['year']}
    if 'extra_data' not in misc or misc['extra_data'] is None:
        misc['extra_data'] = {}
    view_is_bot = 1 if 'flagged_as_robot' in misc and misc['flagged_as_robot'] else 0

    
    if 'ID' in misc and misc['ID'] not in [None, '']:
        misc['ID'] = int(misc['ID'])
        embed_obj['player_ID'] = misc['ID']
        misc['player_data'] = {'current_season': None, 'unlocked': 0, 'last_game': None, 'last_team_ID': None, 'last_team_display_name': None, 'league': None}
        on_server = 0
        try:
            
            conn, cursor = mysql_connect('LR')
            
            cursor.execute("SELECT ID, player, position, unlocked, hometown, active, faceoff_ELO, faceoff_ELO_rank, seasons_played, pro_url_tag, is_individual from LaxRef_Players where active and ID=%s", [misc['ID']])
            misc['player_data'] = zc.dict_query_results(cursor)[0]
            
            if user_obj['is_admin']:
                query = "SELECT a.ID, a.article_ID, a.tags, a.content, IFNULL(b.description, a.content_type) content_type from LaxRef_Content a LEFT JOIN LaxRef_Articles b ON a.article_ID=b.ID where a.player_ID=%s order by a.created_at desc"
                param = [misc['ID']]
                cursor.execute(query, param)
                misc['player_data']['content'] = zc.dict_query_results(cursor)
                # Run custom tag parser to remove characters that will mess up the parsing of the misc object
                for c in misc['player_data']['content']:
                    if c['content'] is not None:
                        c['content'] = escape_script_tags(c['content'])
        
            
            
            # Set this so that we can process the check as to whether this key is populated later on
            misc['player_data']['current_season'] = None

            
            tmp = []
            tmp.append("<meta property='twitter:card' content=\"summary\"/>")
            tmp.append("<meta property='twitter:site' content=\"https://pro.lacrossereference.com\" />")
            tmp.append("<meta property='twitter:title' content=\"%s: PRO View\" />" % (misc['player_data']['player']))
            tmp.append("<meta property='twitter:description' content=\"You won't really understand a player's career until you see it through the PRO lens. Deep stats tell richer stories.\" />")
            tmp.append("<meta property='twitter:image' content=\"https://pro.lacrossereference.com/static/img/LRP_Skype_profile.jpg\" />")
            misc['meta_tags'] = "".join(tmp)
            
            if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Query misc.player.game_log', 'start': ms()})
            cursor.execute("""SELECT a.*, b.game_date, YEAR(b.game_date) 'game_year', c.display_name, c.ID 'opponentID', c.short_code, 
            CASE WHEN a.team_ID = b.home_ID THEN
               CASE WHEN b.home_score > b.away_score THEN 1 else 0 END
            ELSE
                CASE WHEN b.home_score < b.away_score THEN 1 else 0 END
            END win
            
            from LaxRef_Player_Game_Summaries a, LaxRef_Games b, LaxRef_Teams c where IFNULL(b.game_type, '')='' and b.active and a.active and c.active and ((a.team_ID=b.home_ID and b.away_ID=c.ID) or (a.team_ID=b.away_ID and b.home_ID=c.ID)) and a.player_ID=%s and b.ID=a.game_ID""", [misc['ID']])
            misc['player_data']['game_log'] = zc.dict_query_results(cursor)
                
                
            if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Query misc.player_data.season_log', 'start': ms()})
            query = "SELECT a.*, c.league, b.display_name 'team_display_name' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Team_Seasons c where a.team_ID=b.ID and c.active and c.year=a.year and c.team_ID=a.team_ID and b.active and a.active and a.player_ID=%s order by a.year asc"
            param = [misc['ID']]
            lg("SEASONLOGQUERY: %s /w %s" % (query, param))
            cursor.execute(query, param)
            misc['player_data']['season_log'] = zc.dict_query_results(cursor)
            n_season_logs = len(misc['player_data']['season_log'])
            if n_season_logs == 0:
                sys.stderr.write("Error in build_product_data_player: No player season data found for ID=%s" % misc['ID'])
            
            misc['player_data']['last_team_ID'] = None
            misc['player_data']['last_team_display_name'] = None
            misc['player_data']['league'] = None
            if len(misc['player_data']['season_log']) > 0:

                
                misc['player_data']['last_team_ID'] = misc['player_data']['season_log'][-1]['team_ID']
                misc['player_data']['last_team_display_name'] = misc['player_data']['season_log'][-1]['team_display_name']
                misc['player_data']['league'] = misc['player_data']['season_log'][-1]['league']
                if misc['year'] not in [z['year'] for z in misc['player_data']['season_log']]:
                    misc['year'] = misc['player_data']['season_log'][-1]['year']
            embed_obj['league'] = misc['player_data']['league']
            
            
            # Add variables and context to the game log information
            for g in misc['player_data']['game_log']:
                g['game_epoch'] = (g['game_date'] - datetime(1970, 1, 1)).total_seconds();
                g['game_date'] = g['game_date'].strftime("%b %d, %Y").replace(" 0", " ")
                g['this_year'] = 1 if misc['year'] == g['game_year'] else 0
                
                
                g['faceoff_record'] = "%d - %d" % (g['faceoff_wins'], g['faceoffs_taken'] - g['faceoff_wins'])
                g['faceoff_win_rate'] = None if g['faceoffs_taken'] in [None, 0] else g['faceoff_wins']/g['faceoffs_taken']
                g['assist_to_turnover_ratio'] = None if g['turnovers'] in [None, 0] else g['assists']/g['turnovers']
                g['on_goal_shooting_pct'] = None if g['on_keeper_shots'] in [None, 0] else g['goals']/g['on_keeper_shots']
                g['shooting_pct'] = None if g['shots'] in [None, 0] else g['goals']/g['shots']
                
                g['sog_rate'] = None if g['shots'] in [None, 0] else g['sog']/g['shots']


            # Create a series of splits that describe performance based on things like wins vs losses
            misc['player_data']['splits'] = {}
            tmp_this_year = [z for z in misc['player_data']['game_log'] if z['this_year']]
            #1. W/L
            misc['player_data']['splits']['w_vs_l'] = []
            scenarios = [{'win': 1}, {'win': 0}]
            for g in scenarios:
                
                scenario_tmp_this_year = [z for z in tmp_this_year if z['win'] == g['win']]
                n = len(scenario_tmp_this_year)
                g['display'] = "In %d %s%s" % (n, "win" if g['win'] else "loss", "" if n == 1 else ("s" if g['win'] else "es"))
                g['faceoff_wins'] = sum([z['faceoff_wins'] for z in scenario_tmp_this_year])
                g['faceoffs_taken'] = sum([z['faceoffs_taken'] for z in scenario_tmp_this_year])
                g['faceoff_wins_vs_primary'] = sum([z['faceoff_wins_vs_primary'] for z in scenario_tmp_this_year if z['faceoff_wins_vs_primary'] is not None])
                g['faceoffs_taken_vs_primary'] = sum([z['faceoffs_taken_vs_primary'] for z in scenario_tmp_this_year if z['faceoffs_taken_vs_primary'] is not None])
                g['faceoff_wins_vs_secondary'] = sum([z['faceoff_wins_vs_secondary'] for z in scenario_tmp_this_year if z['faceoff_wins_vs_secondary'] is not None])
                g['faceoffs_taken_vs_secondary'] = sum([z['faceoffs_taken_vs_secondary'] for z in scenario_tmp_this_year if z['faceoffs_taken_vs_secondary'] is not None])
                g['turnovers'] = sum([z['turnovers'] for z in scenario_tmp_this_year])
                g['assists'] = sum([z['assists'] for z in scenario_tmp_this_year])
                g['caused_turnovers'] = sum([z['caused_turnovers'] for z in scenario_tmp_this_year])
                g['gbs'] = sum([z['gbs'] for z in scenario_tmp_this_year])
                g['penalties'] = sum([z['penalties'] for z in scenario_tmp_this_year])
                g['on_keeper_shots'] = sum([z['on_keeper_shots'] for z in scenario_tmp_this_year])
                g['goals'] = sum([z['goals'] for z in scenario_tmp_this_year])
                g['shots'] = sum([z['shots'] for z in scenario_tmp_this_year])
                g['sog'] = sum([z['sog'] for z in scenario_tmp_this_year])
                g['shooting_EGA'] = sum([z['shooting_EGA'] for z in scenario_tmp_this_year if z['shots'] > 0])
                
                g['on_keeper_faced'] = sum([0. if z['on_keeper_faced'] is None else z['on_keeper_faced'] for z in scenario_tmp_this_year])
                g['saves'] = sum([0. if z['saves'] is None else z['saves'] for z in scenario_tmp_this_year])
                g['goals_allowed'] = g['on_keeper_faced'] - g['saves']
                g['save_pct'] = None if g['on_keeper_faced'] in [None, 0] else (g['saves'] / g['on_keeper_faced'])
                
                g['faceoff_EGA'] = sum([z['faceoff_EGA'] for z in scenario_tmp_this_year])
                g['defensive_EGA'] = sum([z['defensive_EGA'] for z in scenario_tmp_this_year])
                g['EGA'] = sum([z['EGA'] for z in scenario_tmp_this_year])
                g['weighted_play_share'] = sum([z['weighted_play_share'] for z in scenario_tmp_this_year])
                g['team_play_shares'] = sum([z['team_play_shares'] for z in scenario_tmp_this_year])
                
                g['usage_adjusted_EGA'] = None if g['team_play_shares'] == 0 else (g['EGA'])/(g['team_play_shares'])*.05
                g['on_goal_shooting_pct'] = None if g['on_keeper_shots'] in [None, 0] else g['goals']/g['on_keeper_shots']
                g['assist_to_turnover_ratio'] = None if g['turnovers'] in [None, 0] else g['assists']/g['turnovers']
                g['shooting_pct'] = None if g['shots'] in [None, 0] else g['goals']/g['shots']
                lg(sorted(g.keys()))
                g['shooting_efficiency'] = None if g['shots'] in [None, 0] else g['shooting_EGA']/g['shots']
                g['sog_rate'] = None if g['shots'] in [None, 0] else g['sog']/g['shots']
                
                if n > 0:
                    g['weighted_play_share'] /= n
                    g['team_play_shares'] /= n
                    g['EGA'] /= n
                    g['faceoff_EGA'] /= n
                    g['defensive_EGA'] /= n
                    g['shooting_EGA'] /= n
                    g['saves'] /= n
                    g['shots'] /= n
                    g['goals'] /= n
                    g['assists'] /= n
                    g['sog'] /= n
                    g['turnovers'] /= n
                    g['gbs'] /= n
                    g['on_keeper_faced'] /= n
                    
                    
                
                
                g['faceoff_record'] = "%d - %d" % (g['faceoff_wins'], g['faceoffs_taken'] - g['faceoff_wins'])
                g['faceoff_win_rate'] = None if g['faceoffs_taken'] in [None, 0] else g['faceoff_wins']/g['faceoffs_taken']
                
                g['faceoff_win_rate_vs_primary'] = None if g['faceoffs_taken_vs_primary'] in [None, 0] else g['faceoff_wins_vs_primary']/g['faceoffs_taken_vs_primary']
                g['faceoff_win_rate_vs_secondary'] = None if g['faceoffs_taken_vs_secondary'] in [None, 0] else g['faceoff_wins_vs_secondary']/g['faceoffs_taken_vs_secondary']
                
                
                misc['player_data']['splits']['w_vs_l'].append(g)
            
            misc['player_data']['last_game'] = None
            if len(misc['player_data']['game_log']) > 0:
                 
                misc['player_data']['last_game'] = sorted(misc['player_data']['game_log'], key=lambda x:x['game_date'], reverse=True)[0]
            
            
            is_unlocked = 1
                
            cur_year_player_percentiles = None; cur_year_player_seasons = None; player_career_percentiles = None; player_careers = None; misc['player_data']['current_season'] = None
            
            while misc['year'] > 2014 and misc['year'] not in [z['year'] for z in misc['player_data']['season_log']]:
                misc['year'] -= 1

            if misc['year'] in [z['year'] for z in misc['player_data']['season_log']]:
                misc['player_data']['current_season'] = misc['player_data']['season_log'][ [z['year'] for z in misc['player_data']['season_log']].index(misc['year']) ]
                misc['player_data']['current_season']['on_goal_shooting_pct_percentile'] = None
                if view_is_bot:
                    cur_year_player_seasons = []
                else:
                    if not misc['flagged_as_robot'] and (user_obj['auth'] or is_unlocked):
                        if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Query cur_year_player_seasons', 'start': ms()})
                        
 
                        #tmp_data = storage_read(app.config['ON_SERVER'], storage_path(app.config['ON_SERVER'], os.path.join('GeneralData', "dbLaxRef_PlayerSeasonPercentiles_%d_%s.json" % (misc['year'], misc['player_data']['season_log'][-1]['league'].replace(" ", "")))))
                        tmp_src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", 'GeneralData', "dbLaxRef_PlayerSeasonPercentiles_%d_%s.json" % (misc['year'], misc['player_data']['season_log'][-1]['league'].replace(" ", "")))
                        #lg("Get player percentiles from %s" % (tmp_src))
                        tmp_data = open(tmp_src, 'r').read()
                        if tmp_data is None and datetime.now().month in [2, 3]:
                            # It may be necessary to use last year's data
                            lg("\n\nA) USE LAST YEAR's DATA!!!!\n\n")
                            # tmp_data = storage_read(app.config['ON_SERVER'], storage_path(app.config['ON_SERVER'], os.path.join('GeneralData', "dbLaxRef_PlayerSeasonPercentiles_%d_%s.json" % (misc['year'] - 1, misc['player_data']['season_log'][-1]['league'].replace(" ", "")))))
                            tmp_src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", 'GeneralData', "dbLaxRef_PlayerSeasonPercentiles_%d_%s.json" % (misc['year'] - 1, misc['player_data']['season_log'][-1]['league'].replace(" ", "")))
                            tmp_data = open(tmp_src, 'r').read()
                        cur_year_player_percentiles = json.loads(tmp_data)
                   
            player_careers = []
            #lg("bpd.misc.target_template: %s" % misc['target_template'])
            
            misc['player_data']['player_career_stats'] = None
            
            
            if not misc['flagged_as_robot'] and (user_obj['auth'] or is_unlocked):
                
                if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Load/Query player_careers', 'start': ms()})
                # player_career_percentiles = json.loads(storage_read(app.config['ON_SERVER'], storage_path(app.config['ON_SERVER'], os.path.join('GeneralData', "dbLaxRef_PlayerCareerPercentiles_%s.json" % (misc['player_data']['season_log'][-1]['league'].replace(" ", ""))))))
                player_career_percentiles = json.loads(open(os.path.join(lr_fldr, "LRP", 'LRP_flask', 'LocalDocs', 'GeneralData', "dbLaxRef_PlayerCareerPercentiles_%s.json" % (misc['player_data']['season_log'][-1]['league'].replace(" ", ""))), 'r').read())
                
                if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Query player career stats', 'start': ms()})
                if REMOVE_RANKS_FROM_LAXREF_PLAYER_SEASONS:
                    query = "SELECT data.*, data.offensive_qualified defensive_qualified from (SELECT c.faceoff_ELO, sum(CASE WHEN NOT IFNULL(a.shots, 0) > 10 THEN 1 ELSE 0 END) 'offensive_qualified', sum(CASE WHEN IFNULL(a.faceoff_wins, 0) > 10 THEN 1 ELSE 0 END) 'faceoff_qualified', sum(CASE WHEN IFNULL(a.on_keeper_sog_faced, 0) > 10 THEN 1 ELSE 0 END) 'goalkeeper_qualified', a.player_ID, sum(a.caused_turnovers) 'caused_turnovers', sum(a.shots) 'shots', sum(a.shots_faced) 'shots_faced', CASE WHEN sum(a.on_keeper_shots) > 0 THEN sum(a.goals)/sum(a.on_keeper_shots) ELSE NULL END on_goal_shooting_pct, CASE WHEN sum(a.shots) > 0 THEN sum(a.shooting_EGA)/sum(a.shots) ELSE NULL END shooting_efficiency, CASE WHEN sum(a.shots) > 0 THEN sum(a.sog)/sum(a.shots) ELSE NULL END sog_rate, CASE WHEN sum(a.shots) > 0 THEN sum(a.goals)/sum(a.shots) ELSE NULL END shooting_pct, sum(a.goals) 'goals', sum(a.goals_allowed) 'goals_allowed', sum(a.expected_goals_scored) 'expected_goals_scored', sum(a.expected_goals_allowed) 'expected_goals_allowed', CASE WHEN IFNULL(sum(a.games_appeared_in), 0) = 0 THEN NULL ELSE sum(a.EGA)/sum(a.games_appeared_in) END 'EGA_per_game', sum(a.EGA) 'EGA', sum(a.faceoff_wins) 'faceoff_wins', sum(a.faceoff_losses) 'faceoff_losses', sum(a.turnovers) 'turnovers', sum(a.gbs) 'gbs', sum(a.sog) 'sog', sum(a.assists) 'assists', CASE WHEN sum(faceoff_wins) + sum(faceoff_losses) > 0 THEN sum(faceoff_wins) / (sum(faceoff_wins) + sum(faceoff_losses)) ELSE NULL END faceoff_win_rate, CASE WHEN sum(a.sog_faced) > 0 THEN (sum(a.sog_faced) - sum(a.goals_allowed))/(sum(a.sog_faced)) ELSE NULL END 'save_pct', sum(a.sog_faced) 'sog_faced', sum(a.share_of_team_assists*a.games_appeared_in)/sum(a.games_appeared_in) 'share_of_team_assists', sum(a.share_of_all_gbs*a.games_appeared_in)/sum(a.games_appeared_in) 'share_of_all_gbs', sum(a.turnover_rate*a.games_appeared_in)/sum(a.games_appeared_in) 'turnover_rate', sum(a.offensive_EGA) 'offensive_EGA', sum(a.defensive_EGA) 'defensive_EGA', sum(a.faceoff_EGA) 'faceoff_EGA', sum(a.excess_goals_scored) 'excess_goals_scored', CASE WHEN sum(a.shots) > 0 THEN sum(a.excess_goals_scored)/sum(a.shots) ELSE NULL END 'excess_goals_per_shot', sum(a.excess_saves) 'excess_saves', CASE WHEN sum(a.on_keeper_sog_faced)>0 THEN sum(a.excess_saves)/sum(a.on_keeper_sog_faced) ELSE NULL END 'excess_saves_per_sog', CASE WHEN sum(penalties)=0 THEN NULL ELSE sum(caused_turnovers)/sum(penalties) END caused_turnover_to_penalty_ratio, CASE WHEN sum(turnovers)=0 THEN NULL ELSE sum(assists)/sum(turnovers) END assist_to_turnover_ratio, avg(a.share_adjusted_assist_rate) 'share_adjusted_assist_rate', avg(a.usage_adjusted_EGA) 'usage_adjusted_EGA', avg(a.weighted_team_play_shares) 'weighted_team_play_shares' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Players c where c.ID=%s and c.active and c.ID=a.player_ID and a.team_ID=b.ID and b.active and a.active group by a.player_ID, c.faceoff_ELO) data"
                
                else:
                    query = "SELECT data.*, data.offensive_qualified defensive_qualified from (SELECT c.faceoff_ELO, sum(CASE WHEN NOT ISNULL(a.shooting_pct_rank) THEN 1 ELSE 0 END) 'offensive_qualified', sum(CASE WHEN NOT ISNULL(a.faceoff_win_rate_rank) THEN 1 ELSE 0 END) 'faceoff_qualified', sum(CASE WHEN NOT ISNULL(a.excess_saves_per_sog_rank) THEN 1 ELSE 0 END) 'goalkeeper_qualified', a.player_ID, sum(a.caused_turnovers) 'caused_turnovers', sum(a.shots) 'shots', sum(a.shots_faced) 'shots_faced', CASE WHEN sum(a.on_keeper_shots) > 0 THEN sum(a.goals)/sum(a.on_keeper_shots) ELSE NULL END on_goal_shooting_pct, CASE WHEN sum(a.shots) > 0 THEN sum(a.shooting_EGA)/sum(a.shots) ELSE NULL END shooting_efficiency, CASE WHEN sum(a.shots) > 0 THEN sum(a.sog)/sum(a.shots) ELSE NULL END sog_rate, CASE WHEN sum(a.shots) > 0 THEN sum(a.goals)/sum(a.shots) ELSE NULL END shooting_pct, sum(a.goals) 'goals', sum(a.goals_allowed) 'goals_allowed', sum(a.expected_goals_scored) 'expected_goals_scored', sum(a.expected_goals_allowed) 'expected_goals_allowed', CASE WHEN IFNULL(sum(a.games_appeared_in), 0) = 0 THEN NULL ELSE sum(a.EGA)/sum(a.games_appeared_in) END 'EGA_per_game', sum(a.EGA) 'EGA', sum(a.faceoff_wins) 'faceoff_wins', sum(a.faceoff_losses) 'faceoff_losses', sum(a.turnovers) 'turnovers', sum(a.gbs) 'gbs', sum(a.sog) 'sog', sum(a.assists) 'assists', CASE WHEN sum(faceoff_wins) + sum(faceoff_losses) > 0 THEN sum(faceoff_wins) / (sum(faceoff_wins) + sum(faceoff_losses)) ELSE NULL END faceoff_win_rate, CASE WHEN sum(a.sog_faced) > 0 THEN (sum(a.sog_faced) - sum(a.goals_allowed))/(sum(a.sog_faced)) ELSE NULL END 'save_pct', sum(a.sog_faced) 'sog_faced', sum(a.share_of_team_assists*a.games_appeared_in)/sum(a.games_appeared_in) 'share_of_team_assists', sum(a.share_of_all_gbs*a.games_appeared_in)/sum(a.games_appeared_in) 'share_of_all_gbs', sum(a.turnover_rate*a.games_appeared_in)/sum(a.games_appeared_in) 'turnover_rate', sum(a.offensive_EGA) 'offensive_EGA', sum(a.defensive_EGA) 'defensive_EGA', sum(a.faceoff_EGA) 'faceoff_EGA', sum(a.excess_goals_scored) 'excess_goals_scored', CASE WHEN sum(a.shots) > 0 THEN sum(a.excess_goals_scored)/sum(a.shots) ELSE NULL END 'excess_goals_per_shot', sum(a.excess_saves) 'excess_saves', CASE WHEN sum(a.on_keeper_sog_faced)>0 THEN sum(a.excess_saves)/sum(a.on_keeper_sog_faced) ELSE NULL END 'excess_saves_per_sog', CASE WHEN sum(penalties)=0 THEN NULL ELSE sum(caused_turnovers)/sum(penalties) END caused_turnover_to_penalty_ratio, CASE WHEN sum(turnovers)=0 THEN NULL ELSE sum(assists)/sum(turnovers) END assist_to_turnover_ratio, avg(a.share_adjusted_assist_rate) 'share_adjusted_assist_rate', avg(a.usage_adjusted_EGA) 'usage_adjusted_EGA', avg(a.weighted_team_play_shares) 'weighted_team_play_shares' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Players c where c.ID=%s and c.active and c.ID=a.player_ID and a.team_ID=b.ID and b.active and a.active group by a.player_ID, c.faceoff_ELO) data"
                param = [misc['player_data']['ID']]
                cursor.execute(query, param)
                tmp = zc.dict_query_results(cursor)
                if len(tmp) > 0:
                    misc['player_data']['player_career_stats'] = tmp[0]
            else:
                
                player_careers = None
            cursor.close(); conn.close()
            
            
            
            if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Process data to this point', 'start': ms()})
            
            
            if 'season_log' in misc['player_data'] and misc['player_data']['season_log'] is not None:
                for i, pc in enumerate(misc['player_data']['season_log']):
                    pc['faceoffs_taken'] = 0 if None in [pc['faceoff_wins'], pc['faceoff_losses']] else  float(pc['faceoff_wins'] + pc['faceoff_losses'])
                    pc['faceoff_win_rate'] = float(pc['faceoff_wins'])/pc['faceoffs_taken'] if pc['faceoffs_taken'] not in [0, None] else None
                    pc['faceoff_ELO'] = None if pc['faceoff_ELO_history'] in [None, ''] else json.loads(pc['faceoff_ELO_history'])[-1]['y']
            if player_careers is not None:
                for pc in player_careers:
                    pc['defensive_qualified'] = pc['offensive_qualified']
                    
                    pc['shooting_pct'] = pc['goals']/pc['shots'] if pc['shots'] not in [0, None] else None
                    pc['shooting_efficiency'] = pc['shooting_EGA']/pc['shots'] if pc['shots'] not in [0, None] else None
                    pc['faceoffs_taken'] = 0 if None in [pc['faceoff_wins'], pc['faceoff_losses']] else  float(pc['faceoff_wins'] + pc['faceoff_losses'])
                    pc['faceoff_win_rate'] = float(pc['faceoff_wins'])/pc['faceoffs_taken'] if pc['faceoffs_taken'] not in [0, None] else None
                    pc['sog_rate'] = pc['sog']/pc['shots'] if pc['shots'] not in [0, None] and pc['sog'] not in [0, None] else None
                



            pcs = misc['player_data']['player_career_stats']
            if pcs is not None:
                pcs['excess_goals_per_shot'] = None; pcs['faceoff_wins'] = None; pcs['faceoff_losses'] = None; pcs['goalkeeper_qualified'] = 0; pcs['faceoff_qualified'] = 0; pcs['offensive_qualified'] = 0; pcs['defensive_qualified'] = 0;
                
                if pcs is not None:
                    pcs['excess_goals_per_shot'] = None if pcs['excess_goals_per_shot'] is None else float(pcs['excess_goals_per_shot'])
                    pcs['shooting_efficiency'] = None if pcs['shooting_efficiency'] is None else float(pcs['shooting_efficiency'])
                    pcs['faceoff_wins'] = None if pcs['faceoff_wins'] is None else float(pcs['faceoff_wins'])
                    pcs['faceoff_losses'] = None if pcs['faceoff_losses'] is None else float(pcs['faceoff_losses'])
                    pcs['goalkeeper_qualified'] = int(pcs['goalkeeper_qualified'])
                    pcs['faceoff_qualified'] = int(pcs['faceoff_qualified'])
                    pcs['offensive_qualified'] = int(pcs['offensive_qualified'])
                    pcs['defensive_qualified'] = int(pcs['defensive_qualified'])

            
            
            if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Load misc.extra_data.db_statistics', 'start': ms()})
            misc['extra_data']['db_statistics'] = json.loads(open(os.path.join(lr_fldr, 'LRP', 'LRP_flask', 'LocalDocs', 'GeneralData', "dbLaxRef_Statistics.json"), 'r').read())
            
            misc = build_product_data_player_stat_rankings_from_percentiles(misc, cur_year_player_percentiles, player_career_percentiles)

            fogo_json_path = None
            shooting_json_path = None
            goalie_json_path = None
            
            
                    
            
                
        except Exception as e:
            sys.stderr.write("The %s data Player ID %d could not be read from the DB or from the storage bucket\n\n%s" % ("server" if on_server else "local", misc['ID'], traceback.format_exc()))
        
        
        misc['player_data']['roster_record'] = None   

            
        # For FOGOs, we are pulling a value from the team roster record for the associate player, for some reason.
        if misc['player_data']['current_season'] is not None and 'player_career_stats' in misc['player_data'] and misc['player_data']['player_career_stats'] is not None and misc['player_data']['player_career_stats']['role'] == "faceoff":
            if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Set roster record', 'start': ms()})
        
            try:
                data = get_team_json(misc['player_data']['current_season']['team_ID'],misc['player_data']['current_season']['year'])
                if data is not None:
                    if misc['player_data']['ID'] in [z['player_ID'] for z in data['roster']]:
                        misc['player_data']['roster_record'] = data['roster'][ [z['player_ID'] for z in data['roster']].index(misc['player_data']['ID']) ]
          
            except Exception as e:
                sys.stderr.write("In build_product_data_player, we tried to load the %s team JSON for team ID %d but it could not be read\n\n%s" % ("server" if on_server else "local", misc['player_data']['current_season']['team_ID'], traceback.format_exc()))
    
    misc['extra_data']['players'] = None
    
    show_stat_nuggets = 1
    if misc['target_template'] in ['team_player_detail.html']:
        show_stat_nuggets = 0
        
    if misc['player_data'] not in [None, {}]:
        if not misc['flagged_as_robot'] and (user_obj['auth'] or is_unlocked):
            misc['stat_nuggets'] = []
            
            if show_stat_nuggets:
                if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Build stat nuggets', 'start': ms()})
                # Check if the player has a player stat nugget graphic to display
                query = "SELECT * from LRP_Marketing_Stat_Nuggets where active and player_ID=%s and date_added >= STR_TO_DATE(%s, '%%Y-%%m-%%d')"
                param = [misc['ID'], (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d")]
                conn, cursor = zc.db("LRP")
                cursor.execute(query, param)
                misc['stat_nuggets'] = zc.dict_query_results(cursor)
                cursor.close(); conn.close()
            
                for s in misc['stat_nuggets']:
                    s = find_graphic_in_storage(s)
            if misc['target_template'] not in ['basic_player_detail.html']:
                #if 'league' in misc['data'] and ('league' not in misc['player_data'] or misc['player_data'] is None):
                #     misc['player_data']['league'] = misc['data']['league']
                tmp_data_src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", 'GeneralData', "dbLaxRef_PlayerList_%d_%s.json" % (misc['year'], misc['player_data']['league'].replace(" ", "")))
                lg("A) Load from tmp_data_src: %s" % tmp_data_src)
                if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Load misc.extra_data.players', 'start': ms()})
                #tmp_data = storage_read(app.config['ON_SERVER'], storage_path(app.config['ON_SERVER'], tmp_data_src))
                tmp_data = open(tmp_data_src, 'r').read()
                if tmp_data is None and datetime.now().month < 3:
                    # It may be necessary to use last year's data
                    #lg("\n\nB) USE LAST YEAR's DATA!!!!\n\n")
                    lg("A) PlayerHandlerExtraData: loading misc['extra_data']['players'] from %s" % os.path.join('GeneralData', "dbLaxRef_PlayerList_%d_%s.json" % (misc['year'] - 1, misc['player_data']['league'].replace(" ", ""))))
                    tmp_data = open(os.path.join(lr_fldr, 'LRP', 'LRP_flask', 'LocalDocs', 'GeneralData', "dbLaxRef_PlayerList_%d_%s.json" % (misc['year'] - 1, misc['player_data']['league'].replace(" ", ""))), 'r').read()
                if tmp_data is None:
                    misc['extra_data']['players'] = []
                else:
                    misc['extra_data']['players'] = json.loads(tmp_data)
           

            misc['player_ID'] = misc['ID']
            
            
        # For breadcrumb purposes
        if 'player_detail' in misc['handler']:
            misc['came_from'] += "|%s~%s~%d~%s" % (misc['handler'], 'ID', misc['ID'], misc['player_data']['player'])
    else:
        misc['error'] = "There was an error loading data."; 
        if not app.config['ON_SERVER']: misc['error'] += " (fn=%s)" % "build_product_data_player"
    
    misc, user_obj = clean_product_player_data_generic(misc, user_obj)
    
    
    if isinstance(misc['time_log'], list): misc['time_log'].append({'tag': 'Build Embed Code', 'start': ms()})
    
    
    return misc, user_obj, tmp



def build_product_data_player_old(user_obj, misc):
    """
    This function queries the database to create a profile of a particular player. That also requires pulling all players so that career rankings can be established on the fly (even without an update to all the JSONs). The sub function is separated so that we can calculate the rankings separately from pulling the data required to do so.
    
    misc['year'] or the LRP_User_Settings table specifies which year to use to generate the statistical profile. misc['year'] usually defaults to the current year, but if they have specified that they want to see a different year (via the gear toggle on the front-end), that's when the LRP_User_Settings value would be used.
    """
    def build_product_data_player_stat_rankings(misc, cur_year_player_seasons, player_careers):
        misc['stat_keys'] = []
        misc['stat_keys'].append({'tag': 'excess_saves', 'display': 'Excess Saves', 'short': 'Saves', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'excess_saves_per_sog', 'display': 'Excess Saves/Att', 'short': 'eSaves/Att', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'EGA_per_game', 'display': 'EGA/game', 'short': 'EGA/gm', 'fmt': '{:.2f}', 'jsfmt': '3'})
        misc['stat_keys'].append({'tag': 'usage_adjusted_EGA', 'display': 'uaEGA', 'short': 'uaEGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'EGA', 'display': 'Total EGA', 'short': 'EGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'offensive_EGA', 'display': 'Offensive EGA', 'short': 'oEGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'defensive_EGA', 'display': 'Defensive EGA', 'short': 'dEGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'faceoff_EGA', 'display': 'Faceoff EGA', 'short': 'fEGA', 'fmt': '{:.1f}', 'jsfmt': '2'})
        #misc['stat_keys'].append({'tag': 'excess_goals_scored', 'display': 'Excess Goals', 'short': 'eGoals', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'excess_goals_per_shot', 'display': 'eGoals/Shot', 'short': 'eG/sh', 'fmt': '{:.3f}', 'jsfmt': '3'})
        misc['stat_keys'].append({'tag': 'save_pct', 'display': 'Save Percentage', 'short': 'Save %', 'fmt': '{:.0f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'tag': 'caused_turnovers', 'display': 'Caused Turnovers', 'short': 'CT', 'fmt': '{:.0f}', 'jsfmt': '0'})
        misc['stat_keys'].append({'tag': 'shooting_efficiency', 'display': 'Shooting Efficiency', 'short': 'ShEff', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'reverse': 1, 'tag': 'turnover_rate', 'display': 'Turnover Rate', 'short': 'TO%', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'assist_to_turnover_ratio', 'display': 'Assist:TO', 'short': 'Asst:TO', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'reverse': 0, 'tag': 'share_adjusted_assist_rate', 'display': 'Assist Rate', 'short': 'Asst Rate', 'fmt': '{:.2f}', 'jsfmt': '2'})
        misc['stat_keys'].append({'tag': 'on_goal_shooting_pct', 'display': 'On-Goal Shooting Percentage', 'short': 'ogSh%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'tag': 'shooting_pct', 'display': 'Shooting Percentage', 'short': 'Shot%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'tag': 'shooting_efficiency', 'display': 'Shooting Efficiency', 'short': 'ShEff', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'tag': 'sog_rate', 'display': 'Shot-on-Goal Rate', 'short': 'SOG%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'tag': 'faceoff_win_rate', 'display': 'Faceoff Win%', 'short': 'FO%', 'fmt': '{:.1f}%', 'jsfmt': '0%'})
        misc['stat_keys'].append({'tag': 'faceoff_ELO', 'display': 'Faceoff Elo', 'short': 'fElo', 'fmt': '{:.0f}', 'jsfmt': '0'})
        misc['stat_keys'].append({'tag': 'weighted_team_play_shares', 'display': 'Play Shares', 'short': 'Play%', 'fmt': '{:.1f}%', 'jsfmt': '1%'})
        
            
        # Assign player role
        if misc['player_data']['current_season'] is not None and misc['player_data']['current_season']['games_appeared_in'] > 0 and cur_year_player_seasons is not None:
            off_val = 0. if misc['player_data']['current_season']['offensive_EGA'] is None else abs(misc['player_data']['current_season']['offensive_EGA'])
            def_val = 0. if misc['player_data']['current_season']['defensive_EGA'] is None else abs(misc['player_data']['current_season']['defensive_EGA'])
            fogo_val = 0. if misc['player_data']['current_season']['faceoff_EGA'] is None else abs(misc['player_data']['current_season']['faceoff_EGA'])
            misc['player_data']['current_season']['role'] = assign_player_role(misc['player_data'], off_val, def_val, fogo_val, misc['player_data']['current_season']['shots_faced'], misc['player_data']['current_season']['faceoff_wins'], misc['player_data']['current_season']['team_listed_role'])
            misc['player_data']['player_career_stats']['role'] = misc['player_data']['current_season']['role']
        else:
            misc['player_data']['player_career_stats']['role'] = assign_player_role(misc['player_data'], 0, 0, 0, misc['player_data']['player_career_stats']['shots_faced'], misc['player_data']['player_career_stats']['faceoff_wins'], None)
        
        
        cur_keys = ['excess_saves', 'excess_saves_per_sog', 'usage_adjusted_EGA', 'EGA_per_game', 'EGA', 'offensive_EGA', 'defensive_EGA', 'faceoff_EGA', 'excess_goals_scored', 'save_pct', 'on_goal_shooting_pct', 'caused_turnovers','excess_goals_per_shot', 'shooting_efficiency', 'shooting_pct', 'sog_rate', 'faceoff_win_rate', 'faceoff_ELO', 'turnover_rate', 'assist_to_turnover_ratio', 'share_adjusted_assist_rate']
        
            
        if misc['player_data']['player_career_stats']['role'] is None:
            keep_key_tags = ['', 'weighted_team_play_shares', 'usage_adjusted_EGA', 'EGA_per_game', 'EGA', 'offensive_EGA', 'defensive_EGA', 'faceoff_EGA', '', '', '', '', '', '', '']
            
        elif misc['player_data']['player_career_stats']['role'] == "offensive":
            keep_key_tags = ['weighted_team_play_shares', 'excess_goals_per_shot', 'EGA_per_game', 'EGA', 'offensive_EGA', '', '', 'excess_goals_scored', 'on_goal_shooting_pct', 'shooting_efficiency', 'usage_adjusted_EGA', 'shooting_pct', 'sog_rate', 'turnover_rate', 'assist_to_turnover_ratio', 'share_adjusted_assist_rate']
          
        elif misc['player_data']['player_career_stats']['role'] == "defensive":
            keep_key_tags = ['', '', 'EGA_per_game', 'EGA', '', 'defensive_EGA', '', '', '', 'caused_turnovers', '', '', '', '']
          
        elif misc['player_data']['player_career_stats']['role'] == "goalkeeper":
            keep_key_tags = ['save_pct', 'excess_saves', 'excess_saves_per_sog']
          
        elif misc['player_data']['player_career_stats']['role'] == "faceoff":
            keep_key_tags = ['weighted_team_play_shares', '', 'EGA_per_game', 'EGA', '', '', 'faceoff_EGA', 'excess_goals_scored', '', '', 'shooting_pct', '', 'faceoff_win_rate', 'faceoff_ELO']
         
        for sk in misc['stat_keys']:
            sk['exclude'] = 0 if sk['tag'] in keep_key_tags else 1
            
        # Calculate Season Stats
        if misc['player_data']['current_season'] is not None and cur_year_player_seasons is not None:
            tmp_role = misc['player_data']['current_season']['role']
            for i, sk in enumerate(misc['stat_keys']):
     
                sk['seq'] = i
                if 'label_fmt' not in sk: sk['label_fmt'] = sk['fmt']
            
                sk['points'] = None
                if not sk['exclude']:
                    sk['me_str'] = "N/A"
                    if misc['player_data']['current_season'][sk['tag']] is not None:
                        if "%" in sk['fmt']:
                            sk['me_str'] = sk['fmt'].format(100. * misc['player_data']['current_season'][sk['tag']]); 
                        else:
                            sk['me_str'] = sk['fmt'].format(misc['player_data']['current_season'][sk['tag']]); 
                    else:
                        sk['insufficient_data'] = 0
                    stat_vals = sorted([z[sk['tag']] for z in cur_year_player_seasons if (tmp_role is not None and z["%s_qualified" % tmp_role]) and z[sk['tag']] not in [None]])

                    
                    sk['percentile'] = None
                    if len(stat_vals) > 50:
                        sk['insufficient_data'] = 0
                        low_val = stat_vals[0]
                        high_val = stat_vals[-1] + .000001
                        if None in [low_val, high_val]:
                            sk['insufficient_data'] = 1
                        else:
                            nbuckets = 6
                            rng = high_val-low_val
                            inc = rng/float(nbuckets)
                            sk['points'] = [{'x': i} for i in range(nbuckets)]
                            sk['percentile'] = 100. * (1.0 - (float(len([1 for z in stat_vals if z > misc['player_data']['current_season'][sk['tag']]]))/float(len(stat_vals))))
                            sk['percentile_str'] = "%d%s" % (sk['percentile'], zc.get_number_suffix(sk['percentile']))
                            
                            for i, point in enumerate(sk['points']):
                                l = low_val + (inc*i); h = low_val + (inc * (i+1))
                                point['y'] = len([1 for z in stat_vals if l <= z < h])
                                point['label'] = sk['label_fmt'].format((l+h)/2.) if ('%' not in sk['fmt']) else sk['label_fmt'].format(100.*((l+h)/2.))
                                point['highlight'] = 1 if l <= misc['player_data']['current_season'][sk['tag']] < h else 0
                    else:
                        sk['insufficient_data'] = 1
        

            
                
            
        
        # Calculate Career Ranks

        if misc['player_data']['player_career_stats'] is not None and player_careers is not None:
            off_val = 0. if misc['player_data']['player_career_stats']['offensive_EGA'] is None else abs(misc['player_data']['player_career_stats']['offensive_EGA'])
            def_val = 0. if misc['player_data']['player_career_stats']['defensive_EGA'] is None else abs(misc['player_data']['player_career_stats']['defensive_EGA'])
            fogo_val = 0. if misc['player_data']['player_career_stats']['faceoff_EGA'] is None else abs(misc['player_data']['player_career_stats']['faceoff_EGA'])
            
            
            tmp_role = misc['player_data']['player_career_stats']['role']
            for sk in misc['stat_keys']:
                if not sk['exclude']:
                    
                    #stat_vals = sorted([z[sk['tag']] for z in player_careers if z[sk['tag']] not in [None]])
                    stat_vals = sorted([z[sk['tag']] for z in player_careers if (tmp_role is not None and z["%s_qualified" % tmp_role]) and z[sk['tag']] not in [None]])
                    comp_n = len(stat_vals)
                    qualified_comp_n = len([z[sk['tag']] for z in player_careers if (tmp_role is not None and z["%s_qualified" % tmp_role]) and z[sk['tag']] not in [None]])
                    sk['career_percentile'] = None; sk['career_percentile_str'] = "N/A"; sk['career_rank'] = None; sk['career_rank_str'] = "N/A"
                    if len(stat_vals) > 50:
                    
                        sk['career_insufficient_data'] = 0
                        low_val = stat_vals[0]
                        high_val = stat_vals[-1] + .000001
                        if None in [low_val, high_val]:
                            sk['career_insufficient_data'] = 1
                            
                        else:
                            nbuckets = 6
                            rng = high_val-low_val
                            inc = rng/float(nbuckets)
                            sk['career_points'] = [{'x': i} for i in range(nbuckets)]
                            sk['career_rank'] = float(len([1 for z in stat_vals if z > misc['player_data']['player_career_stats'][sk['tag']]])) + 1
                            sk['career_percentile'] = 100. * (1.0 - (sk['career_rank']/float(len(stat_vals))))
                            sk['career_rank_str'] = ""
                            if sk['career_percentile'] >= 99.:
                                sk['career_rank_str'] = "%d%s" % (sk['career_rank'], zc.get_number_suffix(sk['career_rank']))
                            sk['career_percentile_str'] = "%d%s" % (sk['career_percentile'], zc.get_number_suffix(sk['career_percentile']))
                        
                            
                            for i, point in enumerate(sk['career_points']):
                                l = low_val + (inc*i); h = low_val + (inc * (i+1))
                                point['y'] = len([1 for z in stat_vals if l <= z < h])
                                point['label'] = sk['fmt'].format((l+h)/2.) if ('%' not in sk['fmt']) else sk['fmt'].format(100.*((l+h)/2.))
                                point['highlight'] = 1 if l <= misc['player_data']['player_career_stats'][sk['tag']] < h else 0
                    else:
                        sk['career_insufficient_data'] = 1
        

        return misc
        
    misc['time_log'].append({'tag': 'Build Player Data', 'start': ms()})
    
    if 'year' not in misc or misc['year'] is None:
        misc['year'] = datetime.now().year
    

    if misc['target_template'] not in ["basic_home.html", "team_home.html"] and user_obj is not None and 'settings' in user_obj and 'player_focus_year' in user_obj['settings'] and user_obj['settings']['player_focus_year'] is not None:
        misc['year'] = int(user_obj['settings']['player_focus_year']['val'])

    now = datetime.now()
        
    data = None
    lg("Building product data (player)...")
    tmp = {}
    misc['player_data'] = None
    
    if 'ID' in misc and misc['ID'] not in [None, '']:
        misc['ID'] = int(misc['ID'])
        misc['player_data'] = {'last_game': None, 'last_team_ID': None, 'league': None}
        on_server = None # os.getenv('SERVER_SOFTWARE').startswith('Google App Engine/')
        try:
        
            conn, cursor = zc.mysql_connect('LR')
            cursor.execute("SELECT * from LaxRef_Players where active and ID=%s", [misc['ID']])
            misc['player_data'] = zc.dict_query_results(cursor)[0]
            cursor.execute("SELECT a.*, b.game_date, YEAR(b.game_date) 'game_year', c.display_name, c.ID 'opponentID', c.short_code from LaxRef_Player_Game_Summaries a, LaxRef_Games b, LaxRef_Teams c where b.active and a.active and c.active and ((a.team_ID=b.home_ID and b.away_ID=c.ID) or (a.team_ID=b.away_ID and b.home_ID=c.ID)) and a.player_ID=%s and b.ID=a.game_ID", [misc['ID']])
            misc['player_data']['game_log'] = zc.dict_query_results(cursor)
            if len(misc['player_data']['game_log']) > 0:
                misc['player_data']['last_game'] = sorted(misc['player_data']['game_log'], key=lambda x:x['game_date'], reverse=True)[0]
            cursor.execute("SELECT a.*, b.league from LaxRef_Player_Seasons a, LaxRef_Teams b where a.team_ID=b.ID and b.active and a.active and a.player_ID=%s order by a.year asc", [misc['ID']])
            misc['player_data']['season_log'] = zc.dict_query_results(cursor)
            misc['player_data']['last_team_ID'] = misc['player_data']['season_log'][-1]['team_ID']
            misc['player_data']['league'] = misc['player_data']['season_log'][-1]['league']
            
            cur_year_player_seasons = None; player_careers = None; misc['player_data']['current_season'] = None
            if misc['year'] in [z['year'] for z in misc['player_data']['season_log']]:
                misc['player_data']['current_season'] = misc['player_data']['season_log'][ [z['year'] for z in misc['player_data']['season_log']].index(misc['year']) ]
                cursor.execute("SELECT a.*, CASE WHEN NOT ISNULL(a.shooting_pct_rank) THEN 1 ELSE 0 END 'offensive_qualified', CASE WHEN NOT ISNULL(a.faceoff_win_rate_rank) THEN 1 ELSE 0 END 'faceoff_qualified', CASE WHEN NOT ISNULL(a.excess_saves_per_sog_rank) THEN 1 ELSE 0 END 'goalkeeper_qualified', a.weighted_team_play_shares from LaxRef_Player_Seasons a, LaxRef_Teams b where b.league=%s and a.team_ID=b.ID and b.active and a.active and a.year=%s", [misc['player_data']['season_log'][-1]['league'], misc['year']])
                cur_year_player_seasons = zc.dict_query_results(cursor)
                
            if REMOVE_RANKS_FROM_LAXREF_PLAYER_SEASONS:
                cursor.execute("SELECT c.faceoff_ELO, sum(CASE WHEN IFNULL(a.shots, 0) > 10 THEN 1 ELSE 0 END) 'offensive_qualified', sum(CASE WHEN IFNULL(a.faceoff_wins, 0) > 10 THEN 1 ELSE 0 END) 'faceoff_qualified', sum(CASE WHEN IFNULL(a.on_keeper_shots_faced > 10) THEN 1 ELSE 0 END) 'goalkeeper_qualified', a.player_ID, sum(a.caused_turnovers) 'caused_turnovers', sum(a.shots) 'shots', sum(a.shots_faced) 'shots_faced', sum(a.goals) 'goals', sum(CASE WHEN ISNULL(a.shooting_EGA) THEN 0 ELSE a.shooting_EGA END) 'shooting_EGA', sum(a.goals_allowed) 'goals_allowed', sum(a.expected_goals_scored) 'expected_goals_scored', sum(a.expected_goals_allowed) 'expected_goals_allowed', CASE WHEN IFNULL(sum(a.games_appeared_in), 0) = 0 THEN NULL ELSE sum(a.EGA)/sum(a.games_appeared_in) END 'EGA_per_game', sum(a.EGA) 'EGA', sum(a.faceoff_wins) 'faceoff_wins', sum(a.faceoff_losses) 'faceoff_losses', sum(a.turnovers) 'turnovers', sum(a.gbs) 'gbs', sum(a.sog) 'sog', sum(a.assists) 'assists', CASE WHEN sum(a.turnovers) > 0 THEN sum(a.assists)/sum(a.turnovers) ELSE NULL END 'assist_to_turnover_ratio', sum(a.turnover_rate*a.games_appeared_in)/sum(a.games_appeared_in) 'turnover_rate', sum(a.share_adjusted_assist_rate*a.games_appeared_in)/sum(a.games_appeared_in) 'share_adjusted_assist_rate', CASE WHEN sum(a.penalties) > 0 THEN sum(a.caused_turnovers)/sum(a.penalties) ELSE NULL END 'caused_turnover_to_penalty_ratio', CASE WHEN sum(a.sog_faced) > 0 THEN (sum(a.sog_faced) - sum(a.goals_allowed))/(sum(a.sog_faced)) ELSE NULL END 'save_pct', sum(a.sog_faced) 'sog_faced', sum(a.offensive_EGA) 'offensive_EGA', sum(a.defensive_EGA) 'defensive_EGA', sum(a.faceoff_EGA) 'faceoff_EGA', sum(a.excess_goals_scored) 'excess_goals_scored', CASE WHEN sum(a.shots) > 0 THEN sum(a.excess_goals_scored)/sum(a.shots) ELSE NULL END 'excess_goals_per_shot', sum(a.excess_saves) 'excess_saves', CASE WHEN sum(a.on_keeper_sog_faced)>0 THEN sum(a.excess_saves)/sum(a.on_keeper_sog_faced) ELSE NULL END 'excess_saves_per_sog', avg(a.usage_adjusted_EGA) usage_adjusted_EGA, avg(a.weighted_team_play_shares) 'weighted_team_play_shares' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Players c where c.active and c.ID=a.player_ID and b.league=%s and a.team_ID=b.ID and b.active and a.active group by a.player_ID, c.faceoff_ELO", [misc['player_data']['season_log'][-1]['league']])
            
            else:
                cursor.execute("SELECT c.faceoff_ELO, sum(CASE WHEN NOT ISNULL(a.shooting_pct_rank) THEN 1 ELSE 0 END) 'offensive_qualified', sum(CASE WHEN NOT ISNULL(a.faceoff_win_rate_rank) THEN 1 ELSE 0 END) 'faceoff_qualified', sum(CASE WHEN NOT ISNULL(a.excess_saves_per_sog_rank) THEN 1 ELSE 0 END) 'goalkeeper_qualified', a.player_ID, sum(a.caused_turnovers) 'caused_turnovers', sum(a.shots) 'shots', sum(a.shots_faced) 'shots_faced', sum(a.goals) 'goals', sum(CASE WHEN ISNULL(a.shooting_EGA) THEN 0 ELSE a.shooting_EGA END) 'shooting_EGA', sum(a.goals_allowed) 'goals_allowed', sum(a.expected_goals_scored) 'expected_goals_scored', sum(a.expected_goals_allowed) 'expected_goals_allowed', CASE WHEN IFNULL(sum(a.games_appeared_in), 0) = 0 THEN NULL ELSE sum(a.EGA)/sum(a.games_appeared_in) END 'EGA_per_game', sum(a.EGA) 'EGA', sum(a.faceoff_wins) 'faceoff_wins', sum(a.faceoff_losses) 'faceoff_losses', sum(a.turnovers) 'turnovers', sum(a.gbs) 'gbs', sum(a.sog) 'sog', sum(a.assists) 'assists', CASE WHEN sum(a.turnovers) > 0 THEN sum(a.assists)/sum(a.turnovers) ELSE NULL END 'assist_to_turnover_ratio', sum(a.turnover_rate*a.games_appeared_in)/sum(a.games_appeared_in) 'turnover_rate', sum(a.share_adjusted_assist_rate*a.games_appeared_in)/sum(a.games_appeared_in) 'share_adjusted_assist_rate', CASE WHEN sum(a.penalties) > 0 THEN sum(a.caused_turnovers)/sum(a.penalties) ELSE NULL END 'caused_turnover_to_penalty_ratio', CASE WHEN sum(a.sog_faced) > 0 THEN (sum(a.sog_faced) - sum(a.goals_allowed))/(sum(a.sog_faced)) ELSE NULL END 'save_pct', sum(a.sog_faced) 'sog_faced', sum(a.offensive_EGA) 'offensive_EGA', sum(a.defensive_EGA) 'defensive_EGA', sum(a.faceoff_EGA) 'faceoff_EGA', sum(a.excess_goals_scored) 'excess_goals_scored', CASE WHEN sum(a.shots) > 0 THEN sum(a.excess_goals_scored)/sum(a.shots) ELSE NULL END 'excess_goals_per_shot', sum(a.excess_saves) 'excess_saves', CASE WHEN sum(a.on_keeper_sog_faced)>0 THEN sum(a.excess_saves)/sum(a.on_keeper_sog_faced) ELSE NULL END 'excess_saves_per_sog', avg(a.usage_adjusted_EGA) usage_adjusted_EGA, avg(a.weighted_team_play_shares) 'weighted_team_play_shares' from LaxRef_Player_Seasons a, LaxRef_Teams b, LaxRef_Players c where c.active and c.ID=a.player_ID and b.league=%s and a.team_ID=b.ID and b.active and a.active group by a.player_ID, c.faceoff_ELO", [misc['player_data']['season_log'][-1]['league']])
            player_careers = zc.dict_query_results(cursor)
                
            
            cursor.close(); conn.close()
            
            
            
            misc['player_data']['player_career_stats'] = None
            
            if 'season_log' in misc['player_data'] and misc['player_data']['season_log'] is not None:
                for i, pc in enumerate(misc['player_data']['season_log']):
                    pc['faceoffs_taken'] = 0 if None in [pc['faceoff_wins'], pc['faceoff_losses']] else  float(pc['faceoff_wins'] + pc['faceoff_losses'])
                    pc['faceoff_win_rate'] = float(pc['faceoff_wins'])/pc['faceoffs_taken'] if pc['faceoffs_taken'] not in [0, None] else None
                    pc['faceoff_ELO'] = None if pc['faceoff_ELO_history'] in [None, ''] else json.loads(pc['faceoff_ELO_history'])[-1]['y']
            if cur_year_player_seasons is not None:        
                for pc in cur_year_player_seasons:
                    pc['defensive_qualified'] = pc['offensive_qualified']
                    pc['faceoff_ELO'] = None if pc['faceoff_ELO_history'] in [None, ''] else json.loads(pc['faceoff_ELO_history'])[-1]['y']
            if player_careers is not None:
                for pc in player_careers:
                    pc['defensive_qualified'] = pc['offensive_qualified']
                    
                    pc['shooting_pct'] = pc['goals']/pc['shots'] if pc['shots'] not in [0, None] else None
                    pc['on_goal_shooting_pct'] = pc['goals']/pc['sog'] if pc['sog'] not in [0, None] else None
                    pc['shooting_efficiency'] = pc['shooting_EGA']/pc['shots'] if pc['shots'] not in [0, None] else None
                    pc['faceoffs_taken'] = 0 if None in [pc['faceoff_wins'], pc['faceoff_losses']] else  float(pc['faceoff_wins'] + pc['faceoff_losses'])
                    pc['faceoff_win_rate'] = float(pc['faceoff_wins'])/pc['faceoffs_taken'] if pc['faceoffs_taken'] not in [0, None] else None
                    pc['sog_rate'] = pc['sog']/pc['shots'] if pc['shots'] not in [0, None] and pc['sog'] not in [0, None] else None
                
                lg("Player career is found: %s" % (misc['player_data']['ID'] in [z['player_ID'] for z in player_careers]))
                if misc['player_data']['ID'] in [z['player_ID'] for z in player_careers]:
                    misc['player_data']['player_career_stats'] = player_careers[ [z['player_ID'] for z in player_careers].index(misc['player_data']['ID'])]


            pcs = misc['player_data']['player_career_stats']
            if pcs is not None:
                pcs['excess_goals_per_shot'] = None if pcs['excess_goals_per_shot'] is None else float(pcs['excess_goals_per_shot'])
                pcs['faceoff_wins'] = None if pcs['faceoff_wins'] is None else float(pcs['faceoff_wins'])
                pcs['faceoff_losses'] = None if pcs['faceoff_losses'] is None else float(pcs['faceoff_losses'])
                pcs['goalkeeper_qualified'] = int(pcs['goalkeeper_qualified'])
                pcs['faceoff_qualified'] = int(pcs['faceoff_qualified'])
                pcs['offensive_qualified'] = int(pcs['offensive_qualified'])
                pcs['defensive_qualified'] = int(pcs['defensive_qualified'])

                      
            for g in misc['player_data']['game_log']:
                g['game_epoch'] = (g['game_date'] - datetime(1970, 1, 1)).total_seconds();
                g['game_date'] = g['game_date'].strftime("%b %d, %Y").replace(" 0", " ")
                g['this_year'] = 1 if misc['year'] == g['game_year'] else 0
                g['faceoff_record'] = "%d - %d" % (g['faceoff_wins'], g['faceoffs_taken'] - g['faceoff_wins'])
                g['faceoff_win_rate'] = None if g['faceoffs_taken'] == 0 else g['faceoff_wins']/g['faceoffs_taken']
                g['shooting_pct'] = None if g['shots'] == 0 else g['goals']/g['shots']
                g['sog_rate'] = None if g['shots'] == 0 else g['sog']/g['shots']

            
            misc = build_product_data_player_stat_rankings(misc, cur_year_player_seasons, player_careers)
            
            fogo_json_path = None
            shooting_json_path = None
            goalie_json_path = None
            
            
                
            
                
        except Exception as e:
            msg = (traceback.format_exc())
            print (msg)
            zc.send_crash(msg, bot_token)
            zc.exit("laxref0012")
        
        
        misc['player_data']['roster_record'] = None   

        if on_server is not None:
            if misc['player_data']['current_season'] is not None and misc['player_data']['player_career_stats'] is not None and misc['player_data']['player_career_stats']['role'] == "faceoff":
                try:
                    data = get_team_json(misc['player_data']['current_season']['team_ID'],misc['player_data']['current_season']['year'], on_server)
                    
                    if misc['player_data']['ID'] in [z['player_ID'] for z in data['roster']]:
                        misc['player_data']['roster_record'] = data['roster'][ [z['player_ID'] for z in data['roster']].index(misc['player_data']['ID']) ]
          
                except Exception as e:
                        logging.error("In build_product_data_player, we tried to load the %s team JSON for ID %d could not be read from %s\n\n%s" % ("server" if on_server else "local", load_team_ID, storage_path(on_server, team_path), traceback.format_exc()))
        
    if misc['player_data'] not in [None, {}]:
        pass
        
        
        # For breadcrumb purposes
        if 'player_detail' in misc['handler']:
            misc['came_from'] += "|%s~%s~%d~%s" % (misc['handler'], 'ID', misc['ID'], misc['player_data']['player'])
    else:
        misc['error'] = "There was an error loading data."; 
        if not os.getenv('SERVER_SOFTWARE').startswith('Google App Engine/'): misc['error'] += " (fn=%s)" % "build_product_data_player"
    
    misc, user_obj = clean_product_player_data_generic(misc, user_obj)
    misc['time_log'][-1]['end'] = ms()
    return misc, user_obj, tmp

def lg(s):
    print (s)
    
def ms(): return time.time()

def create_player_pro_view(player, misc):
    pv = "<div class='' style='padding:5px; border-radius: 3px; border: solid 1px #EEE;'>"
    

    if player['team_is_unlocked']:
        pv += "<div class='flex no-padding'><div class='col-9 no-padding'><span class='font-15 bold light oswald '>%s</span></div><div class='col-3 right no-padding'><a href='%s'><img decoding='async' src='https://lacrossereference.com/wp-content/uploads/2021/03/unlockedPRO.png' class='pro-logo small'></a></div></div>" % (misc['title'] if 'title' in misc else "", misc['pro_url'])
    else:
        pv += "<div class='flex no-padding'><div class='col-9 no-padding'><span class='font-15 bold light oswald'>%s</span></div><div class='col-3 right no-padding'><a href='%s'><img decoding='async' src='https://lacrossereference.com/wp-content/uploads/2021/02/PRO.png' class='pro-logo small'></a></div></div>" % (misc['title'] if 'title' in misc else "", misc['pro_url'])
    
    if misc['view_type'] == "career":
        pv += "<div class='flex bbottom no-padding'><div class='col-7 no-padding'><span class='font-12 light'>Career</span></div><div class='col-5 right no-padding'><span class='font-12'>Percentile</span></div></div>"
        for k in misc['stat_keys']:
        
        
            pv += "<div class='flex table-row no-padding'><div class='col-7 no-padding'><span class='font-12 light'>%s</span></div><div class='col-5 right no-padding'><span class='font-12'>%s</span></div></div>" % (k['display'], k['career_percentile_str'])
            
    pv += "<div class='centered'><a style='text-decoration: underline;' href='https://pro.lacrossereference.com/basic_glossary?t=%s'><span class='font-15'>PRO Definitions</span></a></div>" % misc['code']
    
    pv += "</div>"

    
    
    return pv
    
def build_matchup_history(team_rec, all_games, game_stat_adjustments, summaries, specs):
    games = None
    if team_rec['next_game'] is not None:
        team_IDs = [team_rec['next_game']['opponentID'], team_rec['ID']]
        games = [{'ID': z['ID'], 'away_ID': z['away_ID'], 'home_ID': z['home_ID'], 'away_score': z['away_score'], 'home_score': z['home_score'], 'game_date_str': z['game_date_str'], 'game_epoch': z['game_epoch']} for z in all_games if "complete" in z['status'] and z['game_year'] >=2015 and z['home_ID'] in team_IDs and z['away_ID'] in team_IDs]
        games = sorted(games, key=lambda x:x['game_epoch'], reverse=True)
        for g in games:

            tmp_stat_adjustments = [z for z in game_stat_adjustments if z['game_ID'] == g['ID']]
            g['offense_stat_adjustments'] = [z for z in tmp_stat_adjustments if z['offense'] and z['team_ID'] == team_rec['ID']]
            g['defense_stat_adjustments'] = [z for z in tmp_stat_adjustments if not z['offense'] and z['team_ID'] == team_rec['ID']]

            tmp_summaries = [z for z in summaries if z['game_ID'] == g['ID']]
            g['offense_summaries'] = [z for z in tmp_summaries if z['data_type'] == "offense" and z['team_ID'] == team_rec['ID']]
            g['defense_summaries'] = [z for z in tmp_summaries if z['data_type'] == "defense" and z['team_ID'] == team_rec['ID']]

            g['total_possessions'] = ""; g['man_up'] = ""
            if len(tmp_summaries) > 0:
                g['total_possessions'] = sum([z['possessions'] for z in tmp_summaries if z['filter'] is None and z['data_type'] == "offense"])

            for unit in ['offense', 'defense']:
                if len(g['%s_summaries' % unit]) > 0:
                    unfiltered = [z for z in g['%s_summaries' % unit] if z['filter'] is None][0]
                    g['efficiency_%s' % unit] = unfiltered['efficiency']
                    g['man_up_%s' % unit] = "%d / %d" % (unfiltered['man_up_goals'], unfiltered['man_up_chances'])
                    if unit == "offense":
                        g['fo_win_rate'] = unfiltered['faceoff_win_rate']
                        g['save_pct'] = unfiltered['save_pct']
                        g['gb_win_rate'] = unfiltered['gb_win_rate']


                    if 1 in [z['stat_ID'] for z in g['%s_stat_adjustments' % unit]]:
                        g['adj_efficiency_%s' % unit] = g['efficiency_%s' % unit] + g['%s_stat_adjustments' % unit][ [z['stat_ID'] for z in g['%s_stat_adjustments' % unit]].index(1) ]['adjustment']
                    else:
                        g['adj_efficiency_%s' % unit] = g['efficiency_%s' % unit]
                else:
                    for k in ['fo_win_rate', 'man_up_offense', 'man_up_defense', 'adj_efficiency_offense', 'adj_efficiency_defense', 'save_pct', 'gb_win_rate']:
                        g[k] = ""
            #for s in g['offense_summaries']:
            #    s['game_date'] = None; s['date_added'] = None
            #for s in g['defense_summaries']:
            #    s['game_date'] = None; s['date_added'] = None

            my_score = g['home_score'] if team_rec['ID'] == g['home_ID'] else g['away_score']
            their_score = g['home_score'] if team_rec['ID'] != g['home_ID'] else g['away_score']
            g['result_str'] = "%s %d-%d" % (("W" if my_score > their_score else "L"), my_score, their_score)

            #g['game_date'] = None

    print ("{:<40} @ {}".format ("  completed build_matchup_history", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
    return games

def build_RPI_factors(team_rec, this_year_team_seasons, team_season, conferences, specs):
    

    team_rec['RPI_factors'] = []
    team_rec['RPI_factors'].append({'y': 1, 'desc': "My Team", 'RPI': team_season['selection_sunday_RPI'], 'RPI1': team_season['RPI_factor1'], 'RPI2': team_season['RPI_factor2'], 'RPI3': team_season['RPI_factor3']})
    tmp = {'y': 2, 'desc': '%s Avg.' % team_season['conf_short_code'].replace(" (W)", "").replace(" (M)", ""), 'RPI1': None, 'RPI2': None, 'RPI3': None}
    conf_team_seasons = [z for z in this_year_team_seasons if z['RPI_factor1'] is not None and z['conference_ID'] == team_rec['conference_ID']]
    n = float(len(conf_team_seasons))
    if n > 1:
        tmp['RPI1'] = sum([z['RPI_factor1'] for z in conf_team_seasons])/n
        tmp['RPI2'] = sum([z['RPI_factor2'] for z in conf_team_seasons])/n
        tmp['RPI3'] = sum([z['RPI_factor3'] for z in conf_team_seasons])/n
        tmp['RPI'] = .25 * tmp['RPI1'] + .5 * tmp['RPI2'] + .25 * tmp['RPI3']
        team_rec['RPI_factors'].append(tmp)
    crf = []
    for c in [z for z in conferences if not z['independent'] and z['league'] == team_rec['league'] and z['ID'] != team_rec['conference_ID']]:
        tmp = {'y': 2, 'desc': '%s Avg.' % c['short_code'].replace(" (W)", "").replace(" (M)", ""), 'RPI1': None, 'RPI2': None, 'RPI3': None}
        conf_team_seasons = [z for z in this_year_team_seasons if z['RPI_factor1'] is not None and z['conference_ID'] == c['ID']]
        n = float(len(conf_team_seasons))
        if n > 1:
            tmp['RPI1'] = sum([z['RPI_factor1'] for z in conf_team_seasons])/n
            tmp['RPI2'] = sum([z['RPI_factor2'] for z in conf_team_seasons])/n
            tmp['RPI3'] = sum([z['RPI_factor3'] for z in conf_team_seasons])/n
            tmp['RPI'] = .25 * tmp['RPI1'] + .5 * tmp['RPI2'] + .25 * tmp['RPI3']
            crf.append(tmp)


    crf = sorted(crf, key=lambda x:x['RPI'], reverse=True)
    team_rec['RPI_factors'] += crf
    for tmp in team_rec['RPI_factors']:
        for ij in range(1, 4):
            tmp['RPI%d_str' % ij] = "N/A" if tmp['RPI%d' % ij] is None else "%.3f" % (tmp['RPI%d' % ij])

        tmp['RPI_str'] = "N/A" if tmp['RPI'] is None else "%.3f" % (tmp['RPI'])

    team_rec['RPI_factors'] = construct_js_RPI_factors(team_rec['RPI_factors'])
    #print (team_rec['RPI_factors']);
    #raw_input("\n\nThose are the team_rec.RPI_factors; Click to go on\n\n")
    return team_rec

def build_laxelo_history(team_rec, misc, specs):
    team_rec['lax_elo_history'] = None
    

    USEELOHISTORY=0
    if USEELOHISTORY:
        path = os.path.join(lr_fldr, "Post_021", "Teams", "team%04d_ELO_History.csv" % (team_rec['ID']))
        team_rec['lax_elo_history'] = [{'dt': datetime.strptime(z[0], "%Y-%m-%d %H:%M:%S"), 'orig_x': (datetime.strptime(z[0], "%Y-%m-%d %H:%M:%S") - datetime(1970, 1, 1)).total_seconds(), 'Start ELO': int(z[1]), 'y': int(z[5])} for z in [y.split(",") for y in list(filter(None, open(path, 'r').read().split("\n")))[1:]]]
    else:
        try:
            team_rec['lax_elo_history'] = [{'elo_transfer': z['elo_transfer'], 'game_epoch': z['game_epoch'], 'year': z['game_year'], 'home_ID': z['home_ID'], 'away_ID': z['away_ID'], 'home_won': 1 if z['home_score'] > z['away_score'] else 0, 'orig_x': z['game_epoch'], 'Start ELO': z['home_elo'] if z['home_ID'] == team_rec['ID'] else z['away_elo']} for z in misc['games'] if (z['status'] == "manualFinal" or "comp" in z['status']) and z['home_score'] is not None]
            team_rec['lax_elo_history'] = sorted(team_rec['lax_elo_history'], key=lambda x:x['game_epoch'])
        except Exception:
            
            zc.print_dict(misc['games'][0])
            print ("Dates")
            print (str([z['date_YYYYmmdd'] for z in misc['games']]))
            print ("elo_transfer")
            print (str([z['elo_transfer'] for z in misc['games']]))
            print (traceback.format_exc())
            msg = "Error in loading team_rec['lax_elo_history']"
            msg += "\n\n%s" % traceback.format_exc()
            
            print (msg)
            zc.send_crash(msg, bot_token)
            zc.exit("RLO")
        team_rec['lax_elo_history'] = [z for z in team_rec['lax_elo_history'] if z['elo_transfer'] is not None]
        for game_obj in team_rec['lax_elo_history']:
            if game_obj['home_won'] and team_rec['ID'] == game_obj['home_ID']:
                game_obj['y'] = game_obj['Start ELO'] + game_obj['elo_transfer']
            elif game_obj['home_won'] and team_rec['ID'] == game_obj['away_ID']:
                game_obj['y'] = game_obj['Start ELO'] - game_obj['elo_transfer']
            elif not game_obj['home_won'] and team_rec['ID'] == game_obj['home_ID']:
                game_obj['y'] = game_obj['Start ELO'] - game_obj['elo_transfer']
            elif not game_obj['home_won'] and team_rec['ID'] == game_obj['away_ID']:
                game_obj['y'] = game_obj['Start ELO'] + game_obj['elo_transfer']
    

    tmp_last_year = None; cum_offset = 0

    last = None; min_x = None
    for k, s in enumerate(team_rec['lax_elo_history']):
        s['label'] = ""
        if s['year'] != tmp_last_year:
            s['label'] = "%d" % s['year']
            diff = None
            if tmp_last_year is not None and last is not None:
                
                diff = s['orig_x'] - last['orig_x']
                
                cum_offset += (diff - 14*3600*24)
            tmp_last_year = s['year']

            # Make the gaps between seasons smaller
        s['x'] = s['orig_x'] - cum_offset
        if min_x is None or min_x > s['x']:
            min_x = s['x']

           
        if k > 0:
            last = team_rec['lax_elo_history'][k-1]
    print ("{:<40} @ {}".format ("  completed lax_elo_history", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
    
    team_rec['elo_years'] = sorted([{'year': z} for z in list(set([y['year'] for y in team_rec['lax_elo_history']]))], key=lambda x:x['year'])
    for y in team_rec['elo_years']:
        y['data'] = [z for z in team_rec['lax_elo_history'] if z['year'] == y['year']]
            
        #print "Year: %d; %d data points" % (y['year'], len(y['data']))
        #if len(y['data']) > 0:
        #    print "   first: %s (x=%d)" % (y['data'][0]['dt'].strftime("%Y-%m-%d"),  (y['data'][0]['x']  - min_x))
        #    print "   last:  %s (x=%d)" % (y['data'][-1]['dt'].strftime("%Y-%m-%d"), (y['data'][-1]['x'] - min_x))


    for k, s in enumerate(team_rec['lax_elo_history']):
        s['dt'] = None

    return team_rec


def build_team_ranks_new(misc, team_rec, team_season, league_seasons, all_statistics, specs):
    team_rec['alt_ranks'] = {'stat_keys': misc['keys']}
    
    me_season = league_seasons[ [z['team_ID'] for z in league_seasons].index(team_rec['ID']) ]
    me_conference_ID = me_season['conference_ID']
    #zc.print_dict(misc['keys'][0])
    
    subject = "Build Team Ranks New Report: %s" % team_rec['display_name']
    #log = "\n League Seasons: %d\n\n" % len(league_seasons)
    #log += "\nme_season.keys(): %s\n\n" % (str(sorted(me_season.keys())))
    #log += "\nMy Efficiency: %.3f: %.2f goals / %d possessions\n\n" % (me_season['off_efficiency'], me_season['off_possessions'] * me_season['off_efficiency'], me_season['off_possessions'])
    
    rank_tags = []
    n_buckets = 10
    #for i, r in enumerate(rank_tags):
    #    key = misc['keys'] [ [z['tag'] for z in misc['keys']].index(r['stat'])]
    for key in misc['keys']:
        
        #print ("")
        #zc.print_dict(key)
        db_stat = all_statistics[ [z['stat'] for z in all_statistics].index(key['tag']) ]
        #print ("DB Stat"); zc.print_dict(db_stat);
        if db_stat['both_units'] or key['tag'] in ['goals', 'possessions', 'shots']:
            
            units = [{"prefix": 'off_', 'unit': 'offense'}, {'prefix': 'def_', 'unit': 'defense'}]
        else:
            units = [{"prefix": '', 'unit': None}]
            
        
        tmp_stat = db_stat['stat']        
        for unit in units:
            #print("{:<30}{:<30}{:<30}".format("misc.key: %s" % key['tag'], key['display'], me_season[unit['prefix'] + key['tag']]))
            if ("adjusted_%s%s" % (unit['prefix'], tmp_stat)) in league_seasons[0].keys():
                versions = [{"prefix": 'adjusted_'}, {'prefix': ''}]
            else:
                versions = [{"prefix": ''}]
            for version in versions:
                
                
                d = {'stat': db_stat['stat'], 'tag': "%s%s%s" % (version['prefix'], unit['prefix'], tmp_stat), 'unit': unit['unit']}
                d['reverse'] = key['reverse']
                if unit['unit'] == "defense":
                    d['reverse'] = 0 if d['reverse'] else 1
                d['fmt'] = key['fmt']
                d['short'] = key['display']
                d['bucket_fmt'] = key['fmt'].replace(".2f", ".0f").replace(".1f", ".0f")
                d['jsfmt'] = key['jsfmt']
                d['desc'] = key['desc']
                d['multiplier'] = 1.
                
                if key['fmt'].endswith("%"):
                    d['multiplier'] = 100.
                #zc.print_dict(d)
                rank_tags.append(d)
                
    #print "League Seasons Keys:\n\t%s" % a".join(sorted(league_seasons[0].keys()))

    for ir, r in enumerate(rank_tags):
        if 'short' not in r: r['short'] = r['desc']
        if 'bucket_fmt' not in r: r['bucket_fmt'] = r['fmt']
        r['seq'] = ir + 1

    n_league_seasons = len(league_seasons)
    for ir, r in enumerate(rank_tags):
        team_rec['alt_ranks'][r['tag']] = {'desc': r['desc'], 'removetag': r['tag'], 'unit': r['unit']}
        r['has_values'] = 0
        r['values'] = None; r['conf_values'] = None;  r['all_values'] = None; r['buckets'] = None
        
        
        
        n_seasons_with_var = len([1 for z in league_seasons if r['tag'] in z])
        n_seasons_with_non_null = len([1 for z in league_seasons if r['tag'] in z and z[r['tag']] is not None])
        #print ("r['tag']: %s; w var League Seasons: %d / %d (non-null=%d)" % (r['tag'], n_seasons_with_var, n_league_seasons, n_seasons_with_non_null) )
        if n_seasons_with_var == n_league_seasons and n_seasons_with_non_null > 0:
            r['has_values'] = 1
            r['values'] = [{'highlight': 1 if z['team_ID'] == team_rec['ID'] else 0, 'team_ID': z['team_ID'], 'cID': z['conference_ID'], 'label': r['fmt'].format(r['multiplier']* z[r['tag']]), 'stat_val': z[r['tag']]} for z in league_seasons if z[r['tag']] is not None]
            r['values'] = sorted(r['values'], key=lambda x:x['stat_val'], reverse=r['reverse'])
            for iv, v in enumerate(r['values']):
                v['seq'] = iv
                v['rank'] = iv+1
                v['rank_str'] = "%d%s" % (v['rank'], zc.get_number_suffix(v['rank']))
                v['conf_rank_str'] = None
                #if v['team_ID'] == team_rec['ID']:
                #    log += "\n %s: %s (%s)" % (r['tag'], v['stat_val'], v['rank_str'])
                #    log += "\n   league-min: %s; league-max: %s" % (r['values'][0]['stat_val'], r['values'][-1]['stat_val'])
                
            
            r['conf_values'] = [z for z in r['values'] if z['cID'] == me_conference_ID]
            for iv, v in enumerate(r['conf_values']):
                v['seq'] = iv
                #v['conf_rank'] = iv+1
                #v['conf_rank_str'] = "%d%s" % (v['conf_rank'], zc.get_number_suffix(v['conf_rank']))
                conf_rank = iv+1
                v['conf_rank_str'] = "%d%s" % (conf_rank, zc.get_number_suffix(conf_rank))
                
                    

            popd = 1 if len(r['values']) > 0 else 0
            r['buckets'] = None
            if popd:
                min_val = min([z['stat_val'] for z in r['values']])
                max_val = max([z['stat_val'] for z in r['values']])
                if max_val > min_val:
                    diff = max_val - min_val; inc = diff / n_buckets
                    r['buckets'] = [{'x': z, 'min_x': (min_val + float(z)*inc), 'max_x': (min_val + float(z+1)*inc), 'label': r['bucket_fmt'].format(r['multiplier'] * (min_val + float(z)*inc))} for z in range(n_buckets)]
                    for ib, b in enumerate(r['buckets']):
                        if ib == len(r['buckets']) - 1:
                            b['y'] = sum([1. for z in r['values'] if b['min_x'] <= z['stat_val'] <= b['max_x']])
                        else:
                            b['y'] = sum([1. for z in r['values'] if b['min_x'] <= z['stat_val'] < b['max_x']])
                        b['highlight'] = 1 if team_season[r['tag']] is not None and b['min_x'] < team_season[r['tag']] <= b['max_x'] else 0
            
            # To limit the size of the misc object
            if '--keep-all-values' in sys.argv:
                r['all_values'] = [z for z in r['values']]
            r['all_values_list_and_keys'] = zc.list_and_keys(r['values'])
            r['values'] = [z for z in r['values'] if z['team_ID'] == team_rec['ID']]
            
        team_rec['alt_ranks'][r['tag']]['data']= {'has_values': r['has_values'], 'conf_values': r['conf_values'], 'values': r['values'], 'buckets': r['buckets'], 'all_values': r['all_values'], 'all_values_list_and_keys': None if 'all_values_list_and_keys' not in r else r['all_values_list_and_keys'] }

    tmp = ['faceoff_win_rate', 'off_efficiency', 'def_efficiency_inverted']
    for t in tmp:
        tmp_league_seasons = sorted([z for z in league_seasons if z[t] is not None], key=lambda x:x[t])
        team_rec['10_90_range_%s' % t] = None
        team_rec['range_%s' % t] = None

        if len(tmp_league_seasons) >= 10:

            tenth = int(len(tmp_league_seasons)/10)
            ninetieth = int(len(tmp_league_seasons)*9/10)
            team_rec['10_90_range_%s' % t] = (tmp_league_seasons[tenth][t],tmp_league_seasons[ninetieth][t])
            team_rec['range_%s' % t] = (tmp_league_seasons[0][t],tmp_league_seasons[-1][t])

    tmp_tags = []
    tmp_tags.append({'target': 'elo_rank'})
    tmp_tags.append({'target': 'adjusted_off_efficiency_rank'})
    tmp_tags.append({'target': 'RPI_rank', 'src': 'selection_sunday_RPI_rank'})
    for t in tmp_tags:
        if 'src' not in t: t['src'] = t['target']


        team_rec['%s_str' % t['target']] = "N/A"
        team_rec[t['target']] = team_season[t['src']]
        if team_season[t['src']] is not None:
            team_rec['%s_str' % t['target']] = "%d%s" % (team_season[t['src']], zc.get_number_suffix(team_season[t['src']]))

    #zc.exit (log)
    if 0 and team_rec['ID'] == 700:
        zc.send_email(log, {'subject': subject})
    return team_rec

def build_team_ranks(misc, team_rec, team_season, league_seasons, specs):
    team_rec['ranks'] = {'stat_keys': misc['keys']}
    
    rank_tags = []
    
    rank_tags.append({'tag': 'off_efficiency', 'stat': 'efficiency', 'raw': 1, 'desc': 'Efficiency', 'short': 'Eff%', 'unit': 'offense', 'multiplier': 100., 'bucket_fmt': "{:.0f}%", 'fmt': "{:.1f}%", 'jsfmt': "1%", 'reverse': 1, 'nbuckets': 10})
    rank_tags.append({'tag': 'adjusted_off_efficiency', 'stat': 'efficiency', 'raw': 0, 'desc': 'Efficiency', 'short': 'Eff%', 'unit': 'offense', 'multiplier': 100., 'bucket_fmt': "{:.0f}%", 'fmt': "{:.1f}%", 'jsfmt': "1%", 'reverse': 1, 'nbuckets': 10})
    
    rank_tags.append({'tag': 'off_pace', 'desc': 'Pace', 'stat': 'time_to_first_shot', 'unit': 'offense', 'multiplier': 1., 'bucket_fmt': "{:.0f}", 'fmt': "{:.1f}", 'jsfmt': "0", 'reverse': 1, 'nbuckets': 10})

    #print "League Seasons Keys:\n\t%s" % a".join(sorted(league_seasons[0].keys()))

    #zc.print_dict(league_seasons);

    for ir, r in enumerate(rank_tags):
        if 'short' not in r: r['short'] = r['desc']
        if 'bucket_fmt' not in r: r['bucket_fmt'] = r['fmt']
        r['seq'] = ir + 1



    for ir, r in enumerate(rank_tags):
        team_rec['ranks'][r['tag']] = {'desc': r['desc'], 'removetag': r['tag'], 'unit': r['unit']}
        r['values'] = [{'highlight': 1 if z['team_ID'] == team_rec['ID'] else 0, 'team_ID': z['team_ID'], 'label': r['fmt'].format(r['multiplier']* z[r['tag']]), 'stat_val': z[r['tag']]} for z in league_seasons if z[r['tag']] is not None]
        r['values'] = sorted(r['values'], key=lambda x:x['stat_val'], reverse=r['reverse'])
        for iv, v in enumerate(r['values']):
            v['seq'] = iv
            v['rank'] = iv+1
            v['rank_str'] = "%d%s" % (v['rank'], zc.get_number_suffix(v['rank']))

        popd = 1 if len(r['values']) > 0 else 0
        r['buckets'] = None
        if popd:
            min_val = min([z['stat_val'] for z in r['values']])
            max_val = max([z['stat_val'] for z in r['values']])
            if max_val > min_val:
                diff = max_val - min_val; inc = diff / r['nbuckets']
                r['buckets'] = [{'x': z, 'min_x': (min_val + float(z)*inc), 'max_x': (min_val + float(z+1)*inc), 'label': r['bucket_fmt'].format(r['multiplier'] * (min_val + float(z)*inc))} for z in range(r['nbuckets'])]
                for ib, b in enumerate(r['buckets']):
                    if ib == len(r['buckets']) - 1:
                        b['y'] = sum([1. for z in r['values'] if b['min_x'] <= z['stat_val'] <= b['max_x']])
                    else:
                        b['y'] = sum([1. for z in r['values'] if b['min_x'] <= z['stat_val'] < b['max_x']])
                    b['highlight'] = 1 if team_season[r['tag']] is not None and b['min_x'] < team_season[r['tag']] <= b['max_x'] else 0

        team_rec['ranks'][r['tag']]['data']= {'values': r['values'], 'buckets': r['buckets']}

    tmp = ['faceoff_win_rate', 'off_efficiency', 'def_efficiency_inverted']
    for t in tmp:
        tmp_league_seasons = sorted([z for z in league_seasons if z[t] is not None], key=lambda x:x[t])
        team_rec['10_90_range_%s' % t] = None
        team_rec['range_%s' % t] = None

        if len(tmp_league_seasons) >= 10:

            tenth = int(len(tmp_league_seasons)/10)
            ninetieth = int(len(tmp_league_seasons)*9/10)
            team_rec['10_90_range_%s' % t] = (tmp_league_seasons[tenth][t],tmp_league_seasons[ninetieth][t])
            team_rec['range_%s' % t] = (tmp_league_seasons[0][t],tmp_league_seasons[-1][t])

    tmp_tags = []
    tmp_tags.append({'target': 'elo_rank'})
    tmp_tags.append({'target': 'adjusted_off_efficiency_rank'})
    tmp_tags.append({'target': 'RPI_rank', 'src': 'selection_sunday_RPI_rank'})
    for t in tmp_tags:
        if 'src' not in t: t['src'] = t['target']


        team_rec['%s_str' % t['target']] = "N/A"
        team_rec[t['target']] = team_season[t['src']]
        if team_season[t['src']] is not None:
            team_rec['%s_str' % t['target']] = "%d%s" % (team_season[t['src']], zc.get_number_suffix(team_season[t['src']]))


    return team_rec

def build_stats_goalies(goalies, team_rec, specs):
    team_rec['goalies'] = [z for z in goalies if z['team_ID'] == team_rec['ID']]


    print ("{:<40} @ {}".format ("  completed build_stats_goalies", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
    return team_rec

def build_LR_games_panel_view(misc, all_teams, all_game_streams, specs):
    misc['years'] = [{'year': y} for y in sorted(list(set([z['game_year'] for z in misc['games']])), reverse=True) if y > 2015]
    misc['months'] = [{'month_val': datetime.strptime("%s-01" % y, "%Y-%m-%d").strftime("%Y-%m"), 'month': datetime.strptime("%s-01" % y, "%Y-%m-%d").strftime("%b '%y")} for y in sorted(list(set([z['year_month'] for z in misc['games']])), reverse=True)]

    # These stats won't be shown on the LR public games panel
    stats_to_skip = ['emo_efficiency', 'on_goal_shooting_pct', 'faceoff_conversion_rate', 'true_faceoff_win_rate', 'clear_rate', 'ride_rate']
    
    misc['rows'] = []
    #misc['opponents'] = []
    misc['games'] = sorted(misc['games'], key=lambda x:x['game_epoch'])

    header_row = [{'sort_by': 'opponent', 'dtop_str': 'Opponent', 'mob_str': 'Opp.', 'str': 'Opp.', 'fmt': "{}", 'class': 'header', 'col': 2}, {'sort_by': 'date', 'dtop_str': 'Date', 'mob_str': 'Date', 'str': 'Date','fmt': "{}", 'class': 'dtop header', 'col': 1}]
    
    
    header_row += [{'sort_by': z['tag'], 'str': z['display'], 'dtop_str': z['dtop_display'], 'mob_str': z['mob_display'], 'fmt': z['fmt'], 'class': 'header', 'stat_type': z['stat_type'], 'col': 1} for z in misc['keys'] if z['for_summary'] and z['tag'] not in stats_to_skip]

    misc['rows'].append({'ignore': [], 'seq': len(misc['rows']), 'class': 'team-bg', 'panel': 'all_games', 'data': header_row, 'offense': None})
    misc['rows'].append({'ignore': ['Date'], 'seq': len(misc['rows']), 'class': 'team-bg', 'panel': 'by_opponents', 'data': header_row, 'offense': None})
    misc['rows'].append({'ignore': [], 'seq': len(misc['rows']), 'class': 'team-bg', 'panel': 'standard', 'data': header_row, 'offense': None})
    max_yr = specs['year'] if misc['games']==[] else max([z['game_year'] for z in misc['games']])

    for g in misc['games']:
        g['sorted_IDs'] = None
        if None not in [g['away_ID'], g['home_ID']]:
            g['sorted_IDs'] = "%s|%d|%d" % (g['date_YYYYmmdd'], min(g['away_ID'], g['home_ID']), max(g['away_ID'], g['home_ID']))
        #print "{:<30} vs {:<30} on {:<30}".format(g['confirmed_home_team'], g['confirmed_away_team'], g['game_date_str'])
        #zc.print_dict(all_game_streams[0:10])

        game_stream = None
        #print "Game %d Summary" % g['ID']
        #print g['ID'] is not None and g['ID'] in [z['game_ID'] for z in all_game_streams]
        #print " out of %d streams" % len(all_game_streams)
        if g['ID'] is not None and g['ID'] in [z['game_ID'] for z in all_game_streams]:
            game_stream = all_game_streams[ [z['game_ID'] for z in all_game_streams].index(g['ID']) ]
            #print "Found the game stream (1)!!!"
            #zc.print_dict(game_stream)
        elif g['sorted_IDs'] is not None and g['sorted_IDs'] in [z['sorted_IDs'] for z in all_game_streams]:
            game_stream = all_game_streams[ [z['sorted_IDs'] for z in all_game_streams].index(g['sorted_IDs']) ]
            #print "Found the game stream (2)!!!"
            #zc.print_dict(game_stream)
        g['date_mmddYYYY_with_gsurl'] = g['date_mmddYYYY']
        #print "Game stream is not None: %s" % (game_stream is not None)
        #if '2021' in g['date_mmddYYYY']: raw_input("Ok?");
        if game_stream is not None:

            if g['game_year'] >= 2021:

                g['date_mmddYYYY_with_gsurl'] = "<a href='https://lacrossereference.com/live-win-probabilities-mlax/#%s'>%s</a>" % (game_stream['game_file'], g['date_mmddYYYY'])
            else:
                g['date_mmddYYYY_with_gsurl'] = "<a href='https://lacrossereference.com/?p=%s'>%s</a>" % (game_stream['post_ID'], g['date_mmddYYYY'])
            #g['date'] = "<a href='https://lacrossereference.com/?p=%s'>%s</a>" % (game_stream['post_ID'], g['date'])
        if 'summaries' not in g:
            zc.print_dict(g);
            msg = ("No summaries found for ID %d" % g['ID'])
            print (msg)
            zc.send_crash(msg, bot_token)
            zc.exit("laxref0013")
            
        for summary in [z for z in g['summaries'] if z['filter'] == None]:
            row = []

            row.append({'dtop_str': g['opponent_result'], 'mob_str': g['opp_short_code_result'], 'val': g['opponent'], 'tag': 'opponent', 'stat_type': None, 'class': 'data', 'col': 2})
            row.append({'str': g['date_mmddYYYY_with_gsurl'], 'val': g['game_date_YYYYmmdd'], 'tag': 'date', 'stat_type': None, 'class': 'data dtop', 'col': 1})

            for k in misc['keys']:
                if k['tag'] not in stats_to_skip:
                    #print g['ID'], k['tag']
                    if summary[k['tag']] is None:
                        txt = "N/A"
                    else:

                        #if summary['on_keeper_shots'] == 0.:
                        #    print ("{:<30} vs {:<30} on {:<30} (ID={})".format(g['confirmed_home_team'], g['confirmed_away_team'], g['game_date_str'], g['ID']))
                        #    zc.exit("FAIL")
                            
                        if k['tag'] == "save_pct":
                            if summary['on_keeper_shots'] == 0:
                                txt = "N/A"
                            else:
                                txt = k['fmt'].format(summary["shots_saved"]/summary['on_keeper_shots']*100.)
                        else:
                            if k['fmt'].endswith("%"):
                                txt = k['fmt'].format(summary[k['tag']]*100.)
                            else:
                                txt = k['fmt'].format(summary[k['tag']])

                    if k['for_summary']:
                        row.append({'str': txt, 'val': summary[k['tag']], 'tag': k['tag'], 'stat_type': k['stat_type'], 'class': 'data', 'col': 1})
                        
                        #if "2022" in g['date_YYYYmmdd'] and row[-1]['tag'] == "save_pct":
                        #    print ("{}{:<15}{:<15}{:<30}{:<30}".format("\n" if summary['data_type']=="offense" else "", g['date_YYYYmmdd'], row[-1]['str'], summary['data_type'], row[-1]['tag']))
                        

            misc['rows'].append({'seq': len(misc['rows']), 'class': 'data', 'panel': 'all_games', 'offense': 1 if summary['data_type']=="offense" else 0, 'data': row})
            if g['game_year'] == max_yr:
                misc['rows'].append({'seq': len(misc['rows']), 'class': 'data', 'panel': 'standard', 'offense': 1 if summary['data_type']=="offense" else 0, 'data': row})

    #if '--test-game-rows' in sys.argv:
    #    zc.print_dict(misc['rows'])
    #    zc.exit("DONNE TEST")
    misc['rows'].append({'seq': len(misc['rows']), 'class': 'spacer', 'panel': 'standard', 'offense': None, 'data': None})

    aggs = []

    agg = {'class': 'sum', 'panel': 'standard', 'desc': 'W/L Splits', 'list': [
          {'display': "Wins", 'val': 1, 'criteria': lambda x, x_: x['win']==x_ and x['game_year'] == max_yr}
        , {'display': "Losses", 'val': 0,  'criteria': lambda x, x_: x['win']==x_ and x['game_year'] == max_yr}]}
    aggs.append(agg)

    agg = {'class': 'sum', 'panel': 'standard', 'desc': 'By Month', 'list': [{'display': z['month'], 'val': z['month_val'], 'criteria': lambda x, x_: x['year_month'] == x_ and x['game_year'] == max_yr} for z in misc['months']]}
    aggs.append(agg)

    agg = {'class': 'sum', 'panel': 'standard', 'desc': 'By Years', 'list': [{'display': z['year'], 'val': z['year'], 'criteria': lambda x, x_: x['game_year'] == x_} for z in misc['years']]}
    aggs.append(agg)


    agg = {'class': 'data', 'panel': 'by_opponents', 'desc': 'By Opponent', 'list': [{'display': z['display_name'], 'dtop_display': z['display_name'], 'mob_display': z['opp_short_code'], 'val': z['opponent'], 'criteria': lambda x, x_: x['opponent'] == x_} for z in misc['opponents']]}
    aggs.append(agg)

    for z_agg, agg in enumerate(aggs):


        for y in agg['list']:
            if 'dtop_display' not in y: y['dtop_display'] = None
            if 'mob_display' not in y: y['mob_display'] = None
            y['games'] = [z for z in misc['games'] if y['criteria'](z, y['val'])]
            completed_games = [z for z in y['games'] if 'complete' in z['status']]
            len_games = len(completed_games)
            y['wins'] = sum([z['win'] for z in completed_games])
            y['losses'] = float(len_games) - y['wins']

            y['summaries'] = {}
            stat_types = ['offense', 'defense']
            for stat_type in stat_types:

                row = []
                if y['display'] == "Wins": y['display'] = "In %d Win%s" % (len_games, "s" if len_games != 1 else "")
                if y['display'] == "Losses": y['display'] = "In %d Loss%s" % (len_games, "es" if len_games != 1 else "")

                row.append({'str': y['display'], 'dtop_str': y['dtop_display'], 'mob_str': y['mob_display'], 'stat_type': None, 'class': 'data', 'col': 2})
                row.append({'str': "", 'stat_type': None, 'class': 'dtop data', 'col': 1})
                tmp_summaries = []
                for g in completed_games:
                    tmp_summaries += [z for z in g['summaries'] if z['data_type'] == stat_type]
                opp_tmp_summaries = []
                for g in completed_games:
                    opp_tmp_summaries += [z for z in g['summaries'] if z['data_type'] != stat_type]
                if len(tmp_summaries) > 0:
                    for k in misc['keys']:
                        if k['tag'] not in stats_to_skip:
                            txt = "???"
                            val = None;
                            if k['calc'] is not None:
                                val = None
                                if k['calc']['operation'] == "average":

                                    zsum = sum([z[k['tag']] for z in tmp_summaries if z[k['tag']] is not None])
                                    zdenom = sum([1. for z in tmp_summaries if z[k['tag']] is not None])
                                    val = zsum/zdenom if zdenom != 0 else None

                                elif k['calc']['operation'] == "divide":
                                    #print "kdivide operation for stat: %s" % k['tag']
                                    zsum = sum([z[k['calc']['val1']] for z in tmp_summaries])
                                    zdenom = sum([z[k['calc']['val2']] for z in tmp_summaries])
                                    if 'val3' in k['calc']:
                                        zdenom += sum([z[k['calc']['val3']] for z in tmp_summaries ])
                                    val = zsum/zdenom if zdenom != 0 else None


                                elif k['calc']['operation'] == "sum":
                                    val = sum([z[k['tag']] for z in tmp_summaries])

                                elif k['calc']['operation'] == "weighted":
                                    #print ("\n")
                                    #print ("\n").join(["%s %s %s %s %s %s %s" % (z['game_ID'], z['team_ID'], z['data_type'], k['calc']['val1'], z[k['calc']['val1']], k['calc']['val2'], z[k['calc']['val2']]) for z in tmp_summaries])
                                    zsum = sum([0. if 0. in [z[k['calc']['val1']], z[k['calc']['val2']]] else z[k['calc']['val1']]*z[k['calc']['val2']] for z in tmp_summaries])
                                    zdenom = sum([z[k['calc']['val2']] for z in tmp_summaries])
                                    val = zsum/zdenom if zdenom != 0 else None

                                if val is None:
                                    txt = "N/A"
                                else:
                                    if k['fmt'].endswith("%"):
                                        txt = k['fmt'].format(val*100.)
                                    else:
                                        txt = k['fmt'].format(val)

                                y['summaries'][k['tag']] = txt


                            if k['for_summary']:
                                row.append({'str': txt, 'val': val, 'tag': k['tag'], 'stat_type': k['stat_type'], 'class': 'data', 'col': 1})


                    misc['rows'].append({'seq': len(misc['rows']), 'class': agg['class'], 'panel': agg['panel'], 'offense': 1 if stat_type=="offense" else 0, 'data': row})


    agg = {'class': 'sum', 'panel': 'standard', 'desc': 'Conference', 'list': [
          {'display': "Conference", 'val': 1, 'criteria': lambda x, x_: x['conference_game'] and x['game_year'] == max_yr}
        , {'display': "Non-Conference", 'val': 0,  'criteria': lambda x, x_: not x['conference_game'] and x['game_year'] == max_yr}]}
    aggs.append(agg)

    for z_agg, agg in enumerate(aggs):


        for y in agg['list']:
            y['games'] = [z for z in misc['games'] if y['criteria'](z, y['val'])]
            completed_games = [z for z in y['games'] if 'complete' in z['status']]
            len_games = len(completed_games)
            y['wins'] = sum([z['win'] for z in completed_games])
            y['losses'] = float(len_games) - y['wins']

            y['summaries'] = {}
            stat_types = ['offense', 'defense']
            for stat_type in stat_types:

                if y['display'] == "Wins": y['display'] = "In %d Win%s" % (len_games, "s" if len_games != 1 else "")
                if y['display'] == "Losses": y['display'] = "In %d Loss%s" % (len_games, "es" if len_games != 1 else "")


                tmp_summaries = []
                for g in completed_games:
                    tmp_summaries += [z for z in g['summaries'] if z['data_type'] == stat_type]
                if len(tmp_summaries) > 0:
                    for k in misc['keys']:
                        if k['tag'] not in stats_to_skip:
                            txt = "???"
                            val = None;
                            if k['calc'] is not None:
                                val = None
                                if k['calc']['operation'] == "average":

                                    zsum = sum([z[k['tag']] for z in tmp_summaries if z[k['tag']] is not None])
                                    zdenom = sum([1. for z in tmp_summaries if z[k['tag']] is not None])
                                    val = zsum/zdenom if zdenom != 0 else None

                                elif k['calc']['operation'] == "divide":
                                    zsum = sum([z[k['calc']['val1']] for z in tmp_summaries])
                                    zdenom = sum([z[k['calc']['val2']] for z in tmp_summaries])
                                    if 'val3' in k['calc']:
                                        zdenom += sum([z[k['calc']['val3']] for z in tmp_summaries])
                                    val = zsum/zdenom if zdenom != 0 else None

                                elif k['calc']['operation'] == "sum":
                                    val = sum([z[k['tag']] for z in tmp_summaries])

                                elif k['calc']['operation'] == "weighted":
                                    zsum = sum([0. if 0. in [z[k['calc']['val1']],z[k['calc']['val2']]] else z[k['calc']['val1']]*z[k['calc']['val2']] for z in tmp_summaries])
                                    zdenom = sum([z[k['calc']['val2']] for z in tmp_summaries])
                                    val = zsum/zdenom if zdenom != 0 else None

                                if val is None:
                                    txt = "N/A"
                                else:
                                    if k['fmt'].endswith("%"):
                                        txt = k['fmt'].format(val*100.)
                                    else:
                                        txt = k['fmt'].format(val)

                                y['summaries'][k['tag']] = txt

    misc['opponents'] = sorted(misc['opponents'],key=lambda x:x['cnt'], reverse=True)
    for opp in misc['opponents']:
        tmp = all_teams[ [z['ID'] for z in all_teams].index(opp['opponentID']) ]
        opp['display_name'] = tmp['display_name']
        opp['opp_short_code'] = tmp['short_code']
    return misc

def build_pacing_profile(team_ID, poss_list, ttag, specs):
    debug_ts = 1 if datetime.now().strftime("%Y%m%d") == "20240312" else 0
    USE_MARCH2024_METHOD=1 if 1 or '--test-pacing-profile-refactor' in sys.argv else 0
    
    team_ID_tag = 'team_ID' if ttag == "offense" else 'opp_ID'
    
    

    start_ms=time.time()
    print ("{:<40} @ {:<20}".format ("    started build_pacing_profile", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
   
    n_buckets = 4; bucket_len = 80/n_buckets;
    
    obj = {}
    obj['length_data'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['length_data_last_year'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['first_shot_data'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['first_shot_data_last_year'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['quarter_data'] = [{'min_t': z, 'max_t': z, 'x': z, 'y': None, 'label': "Q%d" % (z+1)} for z in range(0, n_buckets)]
    obj['quarter_data_last_year'] = [{'min_t': z, 'max_t': z, 'x': z, 'y': None, 'label': "Q%d" % (z+1)} for z in range(0, n_buckets)]
    obj['length_data'][-1]['label'] = "> 60s"
    obj['first_shot_data'][-1]['label'] = "> 60s"
    obj['quarter_data'][-1]['label'] = "Q4+OT"
    obj['length_data_last_year'][-1]['label'] = "> 60s"
    obj['first_shot_data_last_year'][-1]['label'] = "> 60s"
    obj['quarter_data_last_year'][-1]['label'] = "Q4+OT"
    
    tmp_year = specs['year']; diff_year = 0
    if 'game_year' in specs and specs['game_year'] is not None:
        tmp_year = specs['game_year']
        if team_ID != 32: diff_year = 1
        

    obj['this_year_is_from'] = tmp_year
    obj['last_year_is_from'] = tmp_year-1
    periods = [{'tag': 'this_year', 'val': tmp_year}, {'tag': 'last_year', 'val': tmp_year - 1}]

    if debug_ts: print ("       {:<33} @ {:<20}".format ("done setting up objects", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
    tmp_possessions = {}
    tmp_possessions
    for ijc, period in enumerate(periods):
        
        if debug_ts and ijc == 0: print ("       {:<33} @ {:<20}".format ("find key in poss_list", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        if period['val'] not in poss_list:
            if period['tag'] == "this_year":
                obj['quarter_data'] = None
                obj['length_data'] = None
                obj['first_shot_data'] = None
            else:
                obj['quarter_data_last_year'] = None
                obj['length_data_last_year'] = None
                obj['first_shot_data_last_year'] = None
                
        else:
            # The USE_MARCH2024_METHOD relies on an object that was pre-calculated to hold the league average data, as a result, we can just refer to that object to get the comparison data. That means instead of needing to filter the entire list of possessions every time, we can just do it for our team once.
            
            if not USE_MARCH2024_METHOD:
                for ijk, ky in enumerate([{'obj_key': 'length_data', 'tag': 'adj_duration'}, {'obj_key': 'quarter_data', 'tag': 'quarter'}, {'obj_key': 'first_shot_data', 'tag': 'adj_before_shot'}]):
                   
                    tmp_key = ky['obj_key']
                    if period['tag'] == "last_year":
                        tmp_key += "_last_year"
     
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("get non-Nones", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    non_None = [z for z in poss_list[period['val']] if z[ky['tag']] is not None]
                    
                    for ic, bucket in enumerate(obj[tmp_key]):
                        if debug_ts and ijc == 0 and ijk == 0 and ic==0: print ("       {:<33} @ {:<20}".format ("Filter possessions", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                        relevant = [z for z in non_None if bucket['min_t'] <= z[ky['tag']] <= bucket['max_t']]
                        bucket['league_cnt'] = float(len(relevant))
                        bucket['league_goals'] = sum([z['goal'] for z in relevant])

                        if debug_ts and ijc == 0 and ijk == 0 and ic==0: print ("       {:<33} @ {:<20}".format ("Filter by team", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    
                        relevant = [z for z in relevant if z[team_ID_tag] == team_ID]
                        bucket['cnt'] = float(len(relevant))
                        bucket['goals'] = sum([z['goal'] for z in relevant])

                        if debug_ts and ijc == 0 and ijk == 0 and ic==0: print ("       {:<33} @ {:<20}".format ("done w/ mini-loop", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("Calc totals", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    tmp_sum = sum([z['cnt'] for z in obj[tmp_key]])
                    tmp_league_sum = sum([z['league_cnt'] for z in obj[tmp_key]])
                    
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("Summarize rate stats", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    if tmp_sum == 0:
                        for ic, bucket in enumerate(obj[tmp_key]):
                            bucket['efficiency'] = None
                            bucket['share'] = None
                            bucket['share_str'] = None
                            bucket['league_pct'] = None
                            bucket['efficiency_diff'] = None
                            bucket['share_diff'] = None
                    else:
                        for ic, bucket in enumerate(obj[tmp_key]):

                            if period['tag'] == "this_year":
                                bucket['y'] = bucket['goals'] / bucket['cnt'] if bucket['cnt'] > 0 else None
                            bucket['efficiency'] = bucket['goals'] / bucket['cnt'] if bucket['cnt'] > 0 else None

                            bucket['share'] = bucket['cnt'] / tmp_sum if tmp_sum > 0 else None

                            bucket['share_str'] = "%.1f%%" % (100. * bucket['share'])
                            bucket['league_pct'] = bucket['league_goals'] / bucket['league_cnt'] if bucket['league_cnt'] > 0 else None
                            bucket['league_share'] = bucket['league_cnt'] / tmp_league_sum if tmp_league_sum > 0 else None
                            bucket['efficiency_diff'] = None if None in [bucket['efficiency'], bucket['league_pct']] else bucket['efficiency'] - bucket['league_pct']
                            bucket['share_diff'] = None if None in [bucket['share'], bucket['league_share']] else bucket['share'] - bucket['league_share']
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("done w/ loop", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
           
           
            if USE_MARCH2024_METHOD:
                team_poss_list = [z for z in poss_list[period['val']] if z[team_ID_tag] == team_ID]
                #alt_obj = json.loads(json.dumps(obj))
                for ijk, ky in enumerate([{'obj_key': 'length_data', 'tag': 'adj_duration'}, {'obj_key': 'quarter_data', 'tag': 'quarter'}, {'obj_key': 'first_shot_data', 'tag': 'adj_before_shot'}]):
                    
                    tmp_league_data = specs['league_avg_pacing_profile'][ky['obj_key']]
                    
                    tmp_key = ky['obj_key']
                    if period['tag'] == "last_year":
                        tmp_key += "_last_year"
     
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("get non-Nones", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    non_None = [z for z in team_poss_list if z[ky['tag']] is not None]
                    
                    for ic, bucket in enumerate(obj[tmp_key]):
                        #if debug_ts and ijc == 0 and ijk == 0 and ic==0: print ("       {:<33} @ {:<20}".format ("Filter possessions", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                        #relevant = [z for z in non_None]
                        tmp_league_bucket = tmp_league_data[ [z['label'] for z in tmp_league_data].index(bucket['label']) ]
                        bucket['league_cnt'] = tmp_league_bucket['league_cnt'] + 1
                        bucket['league_goals'] = tmp_league_bucket['league_goals']
                        

                        if debug_ts and ijc == 0 and ijk == 0 and ic==0: print ("       {:<33} @ {:<20}".format ("Filter by team", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    
                        relevant = [z for z in non_None if bucket['min_t'] <= z[ky['tag']] <= bucket['max_t']]
                        bucket['cnt'] = float(len(relevant))
                        bucket['goals'] = sum([z['goal'] for z in relevant])
                        
                        

                        if debug_ts and ijc == 0 and ijk == 0 and ic==0: print ("       {:<33} @ {:<20}".format ("done w/ mini-loop", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("Calc totals", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    tmp_sum = sum([z['cnt'] for z in obj[tmp_key]])
                    tmp_league_sum = sum([z['league_cnt'] for z in obj[tmp_key]])
                    
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("Summarize rate stats", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    if tmp_sum == 0:
                        for ic, bucket in enumerate(obj[tmp_key]):
                            bucket['efficiency'] = None
                            bucket['share'] = None
                            bucket['share_str'] = None
                            bucket['league_pct'] = None
                            bucket['efficiency_diff'] = None
                            bucket['share_diff'] = None
                    else:
                        for ic, bucket in enumerate(obj[tmp_key]):

                            if period['tag'] == "this_year":
                                bucket['y'] = bucket['goals'] / bucket['cnt'] if bucket['cnt'] > 0 else None
                            bucket['efficiency'] = bucket['goals'] / bucket['cnt'] if bucket['cnt'] > 0 else None

                            bucket['share'] = bucket['cnt'] / tmp_sum if tmp_sum > 0 else None

                            bucket['share_str'] = "%.1f%%" % (100. * bucket['share'])
                            bucket['league_pct'] = bucket['league_goals'] / bucket['league_cnt'] if bucket['league_cnt'] > 0 else None
                            bucket['league_share'] = bucket['league_cnt'] / tmp_league_sum if tmp_league_sum > 0 else None
                            bucket['efficiency_diff'] = None if None in [bucket['efficiency'], bucket['league_pct']] else bucket['efficiency'] - bucket['league_pct']
                            bucket['share_diff'] = None if None in [bucket['share'], bucket['league_share']] else bucket['share'] - bucket['league_share']
                    if debug_ts and ijc == 0 and ijk == 0: print ("       {:<33} @ {:<20}".format ("done w/ loop", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
                    
    print ("{:<40} @ {:<20}{:<10.3f}s".format ("  completed build_pacing_profile", datetime.now().strftime("%I:%M:%S.%f")[:-3], time.time()-start_ms))
    if 0 and '--test-pacing-profile-refactor' in sys.argv:
        for tmp_key in ['quarter_data', 'length_data', 'first_shot_data']:
            print ("\nOne time ({})\n------------------------".format(tmp_key))
            zc.print_dict(alt_obj[tmp_key])
            print ("\nLocal ({})\n------------------------".format(tmp_key))
            zc.print_dict(obj[tmp_key])
            orig_val_str = "|".join(["%d --> %.4f" % (z['league_cnt'], z['share_diff']) for z in obj[tmp_key]])
            new_val_str = "|".join(["%d --> %.4f" % (z['league_cnt'], z['share_diff']) for z in alt_obj[tmp_key]])
            if orig_val_str != new_val_str:
                msg = "[FATAL], the USE_MARCH2024_METHOD failed for team ID %d, period=%s, metric=%s\n\nOrig: %s\n\nTest: %s" % (team_ID, period['val'], tmp_key, orig_val_str, new_val_str)
                zc.send_crash(msg, bot_token)
                zc.exit("ERROR")
        
    return obj

def calculate_league_average_pacing_profile(poss_list, specs):
    """
    Instead of having to filter through the entire possession list to calculate a league average every time the build_pacing_profile function is run, let's just do it one time for the entire script execution and then send that object in every time the function is executed.
    """
    debug_ts = 0
    
    n_buckets = 4; bucket_len = 80/n_buckets;
    obj = {}
    obj['length_data'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['length_data_last_year'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['first_shot_data'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['first_shot_data_last_year'] = [{'min_t': z*bucket_len, 'max_t': (1+z)*bucket_len, 'x': z, 'y': None, 'label': "%d-%ds" % (z*bucket_len, z*bucket_len+bucket_len-1)} for z in range(0, n_buckets)]
    obj['quarter_data'] = [{'min_t': z, 'max_t': z, 'x': z, 'y': None, 'label': "Q%d" % (z+1)} for z in range(0, n_buckets)]
    obj['quarter_data_last_year'] = [{'min_t': z, 'max_t': z, 'x': z, 'y': None, 'label': "Q%d" % (z+1)} for z in range(0, n_buckets)]
    obj['length_data'][-1]['label'] = "> 60s"
    obj['first_shot_data'][-1]['label'] = "> 60s"
    obj['quarter_data'][-1]['label'] = "Q4+OT"
    obj['length_data_last_year'][-1]['label'] = "> 60s"
    obj['first_shot_data_last_year'][-1]['label'] = "> 60s"
    obj['quarter_data_last_year'][-1]['label'] = "Q4+OT"
    
    tmp_year = specs['year']; diff_year = 0
    if 'game_year' in specs and specs['game_year'] is not None:
        tmp_year = specs['game_year']
        if team_ID != 32: diff_year = 1
        

    obj['this_year_is_from'] = tmp_year
    obj['last_year_is_from'] = tmp_year-1
    periods = [{'tag': 'this_year', 'val': tmp_year}, {'tag': 'last_year', 'val': tmp_year - 1}]

    for ijc, period in enumerate(periods):
        if period['val'] not in poss_list:
            if period['tag'] == "this_year":
                obj['quarter_data'] = None
                obj['length_data'] = None
                obj['first_shot_data'] = None
            else:
                obj['quarter_data_last_year'] = None
                obj['length_data_last_year'] = None
                obj['first_shot_data_last_year'] = None
                
        else:
            
            for ijk, ky in enumerate([{'obj_key': 'length_data', 'tag': 'adj_duration'}, {'obj_key': 'quarter_data', 'tag': 'quarter'}, {'obj_key': 'first_shot_data', 'tag': 'adj_before_shot'}]):
               
                tmp_key = ky['obj_key']
                if period['tag'] == "last_year":
                    tmp_key += "_last_year"
 

                non_None = [z for z in poss_list[period['val']] if z[ky['tag']] is not None]
                
                for ic, bucket in enumerate(obj[tmp_key]):

                    relevant = [z for z in non_None if bucket['min_t'] <= z[ky['tag']] <= bucket['max_t']]
                    bucket['league_cnt'] = float(len(relevant))
                    bucket['league_goals'] = sum([z['goal'] for z in relevant])

                
                tmp_league_sum = sum([z['league_cnt'] for z in obj[tmp_key]])
                

                if tmp_league_sum == 0:
                    for ic, bucket in enumerate(obj[tmp_key]):

                        bucket['league_share'] = None
                        bucket['league_pct'] = None
                else:
                    for ic, bucket in enumerate(obj[tmp_key]):
                        
                        bucket['league_pct'] = bucket['league_goals'] / bucket['league_cnt'] if bucket['league_cnt'] > 0 else None
                        bucket['league_share'] = bucket['league_cnt'] / tmp_league_sum if tmp_league_sum > 0 else None
    specs['league_avg_pacing_profile'] = obj
    return specs

def log_db_update_insert(table, n_updates, n_inserts=0):
    """
    I have had a lot of issues with table locks timing out, and I want to have a way to log updates/inserts to see if there is a pattern around when a lock timeout error occurs and when it doesn't.
    """
    dt = datetime.now().strftime("%Y%m%d")
    src = os.path.join(lr_fldr, "Logs", "DBQueryLogs", "%s.log" % dt)
    rec = "%s,%s,%d,%d\n" % (datetime.now().strftime("%H%M%S"), table, n_updates, n_inserts)
    f = open(src, 'a')
    f.write(rec)
    f.close()

def build_sim_results(misc, team_rec, sim_results, specs):
    team_rec['sim_results'] = [z for z in sim_results if z['team_ID'] == team_rec['ID']]
    last_month = None

    for s in team_rec['sim_results']:
        s['x'] = (s['datestamp'] - datetime(1970, 1, 1)).total_seconds()
        s['y'] = (s['RPI_rank'])

        s['label'] = ""
        if s['datestamp'].month != last_month or last_month is None:
            if s['datestamp'].month > 1:
                s['label'] = s['datestamp'].strftime("%b")
            last_month = s['datestamp'].month

        s['datestamp_mmmdd'] = s['datestamp'].strftime("%b %d").replace(" 0", " ")
        s['date_str'] = s['datestamp'].strftime("%Y%m%d")
        s['epoch'] = (s['datestamp'] - datetime(1970, 1, 1)).total_seconds()
        s['RPI_rank_str'] = "%d%s" % (int(s['RPI_rank']), zc.get_number_suffix(int(s['RPI_rank'])))
        s['datestamp'] = None
        for tmp in ['NCAA_probability', 'seeded_probability', 'conf_tournament_probability']:
            if s[tmp] is None:
                s[tmp + '_str'] = "N/A"
                s[tmp + '_width'] = 0.
                s[tmp + '_color'] = "#FFF"
            else:
                if s[tmp] < .001:
                    if tmp == "seeded_probability":
                        if s['NCAA_probability'] < .1:
                            s[tmp + '_str'] = "N/A"
                            s[tmp + '_width'] = .01
                        else:
                            s[tmp + '_str'] = "< .1%"
                            s[tmp + '_width'] = .01
                    else:
                        s[tmp + '_str'] = "< .1%"
                        s[tmp + '_width'] = .01

                else:
                    s[tmp + '_str'] = "%d%%" % (100. * s[tmp])
                    s[tmp + '_width'] = s[tmp]
                s[tmp + '_color'] = zc.pct_to_red_green_scale(s[tmp])

    tmp_game_list = [z['ID'] for z in misc['games'] if 'complete' in z['status']]
    team_rec['last_game_ID'] = None; team_rec['last_game_date_YYYYmmdd'] = "N/A"; team_rec['last_game_epoch'] = None
    if len(tmp_game_list) > 0:
        team_rec['last_game_ID'] = tmp_game_list[-1]
        lg = misc['games'][ [z['ID'] for z in misc['games']].index(team_rec['last_game_ID'])]
        team_rec['last_game_epoch'] = lg['game_epoch']
        team_rec['last_game_date_YYYYmmdd'] = lg['game_date_YYYYmmdd']

    # specify the most recent sim prior to the last game
    for s in team_rec['sim_results']:
        s['prior_to_last_game'] = 0
        if team_rec['last_game_epoch'] is None or s['epoch'] > team_rec['last_game_epoch'] or s['date_str'] == team_rec['last_game_date_YYYYmmdd']:
            s['before_last_game'] = -9999999
        else:
            s['before_last_game'] = (s['epoch'] - team_rec['last_game_epoch'])



    team_rec['sim_results'] = sorted(team_rec['sim_results'], key=lambda x:x['before_last_game'], reverse=True)
    team_rec['last_sim'] = None
    if len(team_rec['sim_results']) > 0:
        team_rec['sim_results'][0]['prior_to_last_game'] = 1; last_RPI = team_rec['sim_results'][0]['RPI_rank']
        team_rec['sim_results'][0]['change_since_last_game'] = -1*int("%d" % (sorted(team_rec['sim_results'], key=lambda x:x['epoch'], reverse=True)[0]['RPI_rank'] - last_RPI))
        team_rec['sim_results'][0]['change_since_last_game_str'] = "--"
        if team_rec['sim_results'][0]['change_since_last_game'] > 0:
            team_rec['sim_results'][0]['change_since_last_game_str'] = "+%d" % team_rec['sim_results'][0]['change_since_last_game']
        else:
            team_rec['sim_results'][0]['change_since_last_game_str'] = "%d" % team_rec['sim_results'][0]['change_since_last_game']
        team_rec['last_sim'] = sorted(team_rec['sim_results'], key=lambda x:x['epoch'], reverse=True)[0]

    return team_rec
    
def get_admin_schedule_page_url(t, yr=datetime.now().year):
    USE_LOCALHOST = 0
    if USE_LOCALHOST:
        if 'team_ID' in t:
            return "http://localhost:8080/admin_schedules?team_ID={}&year={}".format(t['team_ID'], yr)
        else:
            return "http://localhost:8080/admin_schedules?team_ID={}&year={}".format(t['ID'], yr)
    else:
        if 'team_ID' in t:
            return "https://pro.lacrossereference.com/admin_schedules?team_ID={}&year={}".format(t['team_ID'], yr)
        else:
            return "https://pro.lacrossereference.com/admin_schedules?team_ID={}&year={}".format(t['ID'], yr)
        
def calc_shot_probability(shot, specs):
    shot['prob'] = specs['sample_shooting_pct']
    for tag in specs['tags']:
        if tag['tag'] in shot and tag['tag'] in specs['f']['data']['weights']:
            if 'trendline' in tag:
                if tag['trendline'] is not None:
                    diff = (shot[tag['tag']] * tag['trendline']['slope'] + tag['trendline']['intercept']) - specs['sample_shooting_pct']
                    shot['prob'] += (specs['f']['data']['weights'][tag['tag']] * diff)
            else:
                inc = tag['increments'][shot[tag['tag']]]
                shot['prob'] += specs['f']['data']['weights'][tag['tag']] * inc
    return shot
    
def team_ID_from_name(misc, original_team_name):
    """
    This function takes in a name found in the wild (i.e. from a team schedule page) and searches through the team names stored within the various misc objects to find a match. If a match is found, return the ID
    """
    db_team = None
    msg = ""
    ID = None
    
        
    league_teams = [z for z in misc['db_teams'] if z['league'] == misc['league']]
    non_league_teams = [z for z in misc['db_teams'] if z['league'] is None or z['league'].split(" ")[-1] == misc['league'].split(" ")[-1]]
        
    # Convert the original_team_name to a cleaned version
    clean_name = original_team_name.lower()
    
    # 1) Remove text that can be added to the team name labels
    

    clean_name = (clean_name
    .replace("(homecoming)", "")
    .replace("(senior day)", "")
    .replace("(code blue)", ""))
    
    # 2) Remove non ascii stuff
    clean_name = "".join([z for z in clean_name if 97 <= ord(z) <= 122])
    
    # Find a db team or an alternate name record that matches the name found in the wild
    if clean_name in [z['name_clean'] for z in league_teams]:
        db_team = league_teams[ [z['name_clean'] for z in league_teams].index(clean_name) ]
    elif len([1 for z in league_teams if z['league'] == misc['league'] and clean_name in [y['alternate_name'] for y in z['alternate_names']] ]) > 0:
        tmp = [z for z in league_teams if z['league'] == misc['league'] and clean_name in [y['alternate_name'] for y in z['alternate_names']] ]
        if len(tmp) == 1:
            db_team = league_teams[ [z['ID']for z in league_teams].index(tmp[0]['ID']) ]
        
    # Check the other divisions to see if perhaps this is a non-division game        
    if db_team is None:
        
        #lg("Clean Name: %s" % clean_name)
        #pd([z for z in non_league_teams if z['ID'] == 998])
        
        if clean_name in [z['name_clean'] for z in non_league_teams]:
            db_team = non_league_teams[ [z['name_clean'] for z in non_league_teams].index(clean_name) ]
        elif len([1 for z in non_league_teams if z['league'] != misc['league'] and clean_name in [y['alternate_name'] for y in z['alternate_names']] ]) > 0:
            tmp = [z for z in non_league_teams if z['league'] != misc['league'] and clean_name in [y['alternate_name'] for y in z['alternate_names']] ]
            if len(tmp) == 1:
                db_team = non_league_teams[ [z['ID']for z in non_league_teams].index(tmp[0]['ID']) ]
        if db_team is not None:
            # Need to let the user know that it was a non-league opponent
            msg += "Non-League Opponent"
    if db_team is not None:
        ID = db_team['ID']
    else:
        msg += "No ID could be identified for %s (%s)" % (original_team_name, misc['league'])
    return ID, msg
    
def build_misc_keys(misc, league, specs):

    # Reverse=1 means that more is better because we are setting the python sort function reverse flag to 1 and we are going to get the highest values first. Note (Mar 8th, 2022; this gets confusing in other scripts where it seems like reverse should be lower is better)

    misc['keys'] = [
    {'for_ranks': 1, 'desc': 'Efficiency', 'display': 'Eff%', 'calc': {'val1': 'goals', 'val2': 'possessions'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'efficiency', 'exclude': ['faceoffs', 'goalkeepers']}

    , {'display': 'Shoot%', 'calc': {'val1': 'goals', 'val2': 'shots'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'shooting_pct', 'exclude': ['faceoffs', 'goalkeepers']}

    , {'display': 'ShEff', 'calc': {'val1': 'shooting_EGA', 'val2': 'shots'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'shooting_efficiency', 'exclude': ['faceoffs', 'goalkeepers']}
    
    #, {'display': 'expSh%', 'calc': {'val1': 'expected_goals', 'val2': 'shots'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'expected_shooting_pct', 'exclude': ['faceoffs', 'goalkeepers']}

    , {'display': 'SOG%', 'calc': {'val1': 'sog', 'val2': 'shots'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'sog_rate', 'exclude': ['faceoffs', 'goalkeepers']}
    



    , {'reverse': 0, 'display': 'TO%', 'desc': 'Turnover Rate', 'calc': {'val1': 'turnovers', 'val2': 'possessions'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'turnover_rate', 'exclude': ['faceoffs', 'goalkeepers']}
    
    , {'display': 'Asst%', 'desc': 'Assist Rate', 'calc': {'val1': 'assists', 'val2': 'goals'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'assist_rate', 'exclude': ['faceoffs', 'goalkeepers']}

    
    , {'for_ranks': 1, 'desc': 'Clear Rate', 'display': 'Clear%', 'calc': {'val1': 'possessions', 'val2': 'possessions_plus_failed_clears'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'clear_rate', 'exclude': ['faceoffs', 'defense', 'goalkeepers']}
    
    , {'for_ranks': 1, 'desc': 'Ride Rate', 'display': 'Ride%', 'calc': {'val1': 'successful_rides', 'val2': 'ride_opportunities'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'ride_rate', 'exclude': ['faceoffs', 'defense', 'goalkeepers']}
    
    , {'for_ranks': 1, 'desc': 'EMO Eff', 'display': 'emEff%', 'calc': {'val1': 'man_up_goals', 'val2': 'man_up_chances'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'emo_efficiency', 'exclude': ['faceoffs', 'goalkeepers']}

    , {'reverse': 0, 'for_ranks': 1, 'display': '1st Shot', 'desc': 'Pace', 'short': "Pace", 'calc': {'val1': 'time_to_first_shot', 'val2': 'poss_w_shot', 'operation': 'weighted'}, 'stat_type': 'pace', 'fmt': "{:.1f}", 'jsfmt': "1s", 'bucket_fmt': '0s', 'tag': 'time_to_first_shot', 'exclude': ['faceoffs', 'goalkeepers']}

    , {'display': 'GB%', 'exclude': ['offense', 'faceoffs', 'goalkeepers'], 'calc': {'val1': 'gbs_won', 'val2': 'gbs_won', 'val3': 'gbs_lost'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'gb_win_rate'}

    , {'display': 'T.O.P.', 'exclude': ['defense', 'faceoffs', 'goalkeepers'], 'desc': 'Time of Possession', 'calc': {'operation': 'average'}, 'stat_type': 'pace', 'fmt': "{:.1f}%", 'tag': 'time_of_possession'}

    , {'stat_type': 'raw', 'exclude': ['faceoffs', 'goalkeepers'], 'fmt': "{:.0f}", 'tag': 'shots', 'display': 'Shots/g', 'short': 'Shots/g', 'calc': {'operation': 'average'}}

    , {'stat_type': 'raw', 'exclude': ['faceoffs', 'goalkeepers'], 'jsfmt': "1", 'fmt': "{:.0f}", 'display': 'Goals/g', 'short': 'Goals/g', 'tag': 'goals', 'calc': {'operation': 'average'}}

    , {'stat_type': 'raw', 'exclude': ['faceoffs', 'goalkeepers'], 'fmt': "{:.0f}", 'tag': 'possessions', 'display': 'Poss/g', 'short': 'Poss/g', 'calc': {'operation': 'average'}}

    , {'reverse': 0, 'exclude': ['faceoffs', 'goalkeepers'], 'display': 'TO/g', 'desc': 'Turnovers/game', 'short': 'TO/g', 'stat_type': 'raw', 'fmt': "{:.0f}", 'tag': 'turnovers', 'calc': {'operation': 'average'}, 'jsfmt': "1"}

    , {'display': 'Poss+/-', 'exclude': ['defense', 'faceoffs', 'goalkeepers'], 'stat_type': 'raw', 'jsfmt': "+/-1", 'fmt': "{:.0f}", 'tag': 'modified_possession_margin', 'calc': {'operation': 'average'}}

    , {'display': 'Shot/Pos', 'exclude': ['faceoffs', 'goalkeepers'], 'dtop_display': 'Shot/Pos', 'mob_display': 'Sh/Pos', 'calc': {'val1': 'shots', 'val2': 'possessions'}, 'stat_type': 'rate', 'fmt': "{:.2f}", 'js_fmt': "2", 'tag': 'shots_per_possession'}

    , {'display': 'FO Win%', 'short': 'FO%', 'exclude': ['offense', 'defense', 'goalkeepers'], 'calc': {'val1': 'faceoff_wins', 'val2': 'faceoff_wins', 'val3': 'faceoff_losses'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'faceoff_win_rate'}

    , {'display': 'True FO%', 'short': 'trueFO%', 'exclude': ['offense', 'defense', 'goalkeepers'], 'calc': {'val1': 'true_faceoff_wins', 'val2': 'true_faceoff_wins', 'val3': 'true_faceoff_losses'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'true_faceoff_win_rate'}

    , {'display': 'FO Conv%', 'exclude': ['offense', 'defense', 'goalkeepers'], 'calc': {'val1': 'faceoff_conversions', 'val2': 'faceoff_wins'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'faceoff_conversion_rate'}

    , {'reverse': 0, 'display': 'Avg Poss', 'desc': "Avg Poss. Length", 'jsfmt': "1s", 'bucket_fmt': "0s", 'dtop_display': 'Avg Poss', 'mob_display': 'Sec/Pos', 'calc': {'val1': 'avg_possession_length', 'val2': 'possessions', 'operation': 'weighted'}, 'stat_type': 'pace', 'fmt': "{:.1f}", 'tag': 'avg_possession_length', 'exclude': ['faceoffs', 'goalkeepers']}
    
    

    , {'display': 'ogSh%', 'calc': {'val1': 'goals', 'val2': 'on_keeper_shots'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'on_goal_shooting_pct', 'exclude': ['faceoffs', 'goalkeepers']}
    
    , {'reverse': 0, 'for_summary': 0, 'display': 'Save%', 'calc': {'val1': 'shots_saved', 'val2': 'on_keeper_shots'}, 'stat_type': 'rate', 'fmt': "{:.1f}%", 'tag': 'save_pct', 'exclude': ['offense', 'defense', 'faceoffs']}

    #, {'display': '#Contrib', 'exclude': ['defense', 'faceoffs', 'goalkeepers'], 'calc': {'operation': 'average'}, 'stat_type': 'pace', 'fmt': "{:.0f}", 'tag': 'number_of_contributors'}
    ]
    
    if "Women" in league:
        misc['keys'] = [z for z in misc['keys'] if z['tag'] not in ['emo_efficiency']]
        
    for ik, k in enumerate(misc['keys']):
        k['for_summary'] = 1
        k['seq'] = ik

    for ir, k in enumerate(misc['keys']):
        if 'display' not in k: k['display'] = k['tag'].title()
        if 'desc' not in k: k['desc'] = k['display']
        if 'for_summary' not in k: k['for_summary'] = 1
        if 'for_ranks' not in k: k['for_ranks'] = 0
        if 'dtop_display' not in k: k['dtop_display'] = None
        if 'mob_display' not in k: k['mob_display'] = None
        if 'calc' in k:
            if 'operation' not in k['calc']: k['calc']['operation'] = "divide"
            if 'val2' not in k['calc']: k['calc']['val2'] = None
        else:
            k['calc'] = None


        if 'short' not in k: k['short'] = k['display']
        if 'reverse' not in k: k['reverse'] = 1
        if 'subtract_from_100' not in k: k['subtract_from_100'] = 0
        
        if 'nbuckets' not in k: k['nbuckets'] = 10
        if 'bucket_fmt' not in k:
            if 'jsfmt' in k:
                k['bucket_fmt'] = k['jsfmt']
            else:
                k['bucket_fmt'] = k['fmt']
        if 'jsfmt' not in k: k['jsfmt'] = k['fmt'].replace("{", "").replace("}", "").replace(":", "").replace(".", "")

        k['seq'] = ir + 1

    return misc
    
def convert_raw_into_weighted_wp(g, ln, weight_param, pct_complete, home, raw_wp):

    starting_odds_weight = max(0, (ln(weight_param+1) - ln(pct_complete*100.0/(100.0/weight_param)+1))/ln(weight_param+1))
    
    uncertainty_value = 0.    
        
    game_state_weight = 1.0 - starting_odds_weight


    #print "{:<5}{:>10.3f}{:>10.3f}{:>10.3f}{:>10.3f}{:>10.3f}{:>10.0f}{:>10.3f}".format(r['quarter'], r['pct_complete'], 1. - odds, section, adjusted_diff, home_win_odds, game_state, 1. - (odds * game_state_weight + home_win_odds * starting_odds_weight))

    if home:
        team_specific_starting_odds = g['pregame_home_wp']
    else:
        team_specific_starting_odds = 1. - g['pregame_home_wp']
        
    res = raw_wp * game_state_weight + team_specific_starting_odds * starting_odds_weight
    
    
    
    return res
    
def record_step_timestamp_completion(step, build_stats_timestamps, cur_ms):

    if step not in [z['tag'] for z in build_stats_timestamps]:
        build_stats_timestamps.append({'tag': step, 'timestamps': [{'end': time.time(), 'start': cur_ms}]})
    else:
        bst = build_stats_timestamps[ [z['tag'] for z in build_stats_timestamps].index(step) ]
        bst['timestamps'].append({'end': time.time(), 'start': cur_ms})
    cur_ms = time.time()

    return build_stats_timestamps, cur_ms
    
def increment_queries(query_log, query_tag, res):
    add_new_log = 0
    if query_tag not in [z['query_tag'] for z in query_log]:
        query_log.append({'query_tag': query_tag, 'calls': 0., 'with_data_calls': 0., 'estimated_egress': 0.})
        
    ql = query_log[ [z['query_tag'] for z in query_log].index(query_tag) ]
    ql['calls'] += 1.
    if len(res) > 0:
        ql['with_data_calls'] += 1.
        n = len(res)
        per_n = len(str(res[0]))
        ql['estimated_egress'] += float(n) * per_n
        ql['records'] = n
        ql['per_record'] = per_n
  
    return query_log    

def report_egress_data(query_log, script):
    
    
    
    
    msg = "%s Query Egress Report (%s)\n" % (script, datetime.now().strftime("%I:%M %p"))
    
    
    query_log = sorted(query_log, key=lambda x:x['estimated_egress'], reverse=True)
    for q in query_log:
        q['estimated_egress_in_mb'] = q['estimated_egress'] / 1024. / 1024.
    total_mb = sum([z['estimated_egress_in_mb'] for z in query_log]) 
    msg += "\n".join(["%s - %.3fMB" % (z['query_tag'], z['estimated_egress_in_mb']) for z in query_log]) 
    msg += "\n\nTotal MB: {:,.3f}".format(total_mb)
    msg += "\n\n%s" % zc.print_dict(query_log)
    print (msg)
    zc.send_email(msg, {'subject': 'Database Egress Report', 'from': "LaxRef.py"})




def build_team_stats_LRP(uyear, run_settings, orig_team_ID=None):
    
    start_ms = time.time(); cur_ms = start_ms
    mod_val = 40
    query_log = []
    USE_ZGAMEYEAR=1
    orig_team_IDs = []
    if orig_team_ID is not None:
        orig_team_IDs = [int(z.strip()) for z in orig_team_ID.split("|") if z.strip() != ""]
    
    specs = {'year': uyear, 'last_year': uyear-1, 'LR': 1, 'LRP': 0, 'missing_efficiency_errors': []}
    all_misc = []

    build_stats_timestamps = []
    if '--use-stored-db-results' in sys.argv:
        #print ("{:<40} @ {}".format ("Loading query data", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #tomato_games = add_dates_back(json.loads(open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'tomato_games'), 'r').read()))
        #print "{:,} historical games.".format(len(tomato_games));

        print ("{:<40} @ {}".format ("Done loading query data", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        zc.exit("laxref0015")
    else:
        print ("{:<40} @ {}".format ("Processing queries", datetime.now().strftime("%I:%M:%S.%f")[:-3]))

        league_averages = {}
        conn, cursor = zc.mysql_connect("LR")

        tmp_start_ms = time.time()
        cursor.execute("SELECT * from LaxRef_Seasons", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        seasons = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'LaxRef_Seasons', seasons)
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} seasons".format(len(seasons)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} seasons".format(len(seasons)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        
        #teamQuery
        tmp_start_ms = time.time()
        cursor.execute("SELECT a.ID, a.display_name, a.pro_url_tag, b.league, a.short_code, b.partial_member, b.conference_ID from LaxRef_Teams a LEFT JOIN LaxRef_Team_Seasons b ON a.ID=b.team_ID and b.year=%s where a.active", [specs['year']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_teams = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'LaxRef_Teams', all_teams)
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_teams".format(len(all_teams)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_teams".format(len(all_teams)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_teams'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_teams))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        #cursor.execute("SELECT * from LaxRef_Games where YEAR(game_date)>=2015 and status like 'complete%%' and active order by game_date asc", [])
        #tomato_games = zc.dict_query_results(cursor)
        #print ("{:<40} @ {}".format ("  Pulled {:,} tomato_games".format(len(tomato_games)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        ##if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'tomato_games'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(tomato_games))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        cursor.execute("SELECT b.player_ID, a.player from LaxRef_Players a, LaxRef_Player_Seasons b, LaxRef_Teams c where c.ID=b.team_ID and upper(trim(a.player)) != 'TEAM' and a.active and b.active and b.player_ID=a.ID and b.year=%s", [specs['year']-1])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        last_year_players = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'last_year_players', last_year_players)
        
        tmp_start_ms = time.time()

        TEST_ONLY_THIS_LEAGUE=0
        if REMOVE_RANKS_FROM_LAXREF_PLAYER_SEASONS:
            # On March 7th, 2024, I started a test to see if is causes any issues to remove the player's hometown from this query. It's not displayed anywhere and would have a small impact on reducing JSON size. Also removed team_custom_usage_adjusted_EGA.
            if TEST_ONLY_THIS_LEAGUE and run_settings['league'] is not None:
                
                #cursor.execute("SELECT a.player, a.hometown, a.faceoff_ELO, a.seasons_played, a.pro_url_tag, a.is_individual, a.unlocked, b.ID, b.player_ID, b.shots_taken, b.shots_faced, b.goals_scored, b.goals_allowed, b.expected_goals_scored, b.expected_goals_allowed, b.EGA, b.active, b.year, b.team_ID, b.faceoff_wins, b.faceoff_losses, b.faceoff_win_rate, b.team_play_shares, b.role, b.team_listed_role, b.turnovers, b.gbs, b.sog, b.assists, b.sog_faced, b.sog_rate_faced, b.save_pct, b.shooting_pct, b.on_goal_shooting_pct, b.offensive_EGA, b.defensive_EGA, b.faceoff_EGA, b.sog_rate, b.excess_goals_scored, b.excess_saves, b.EGA_per_game, b.games_appeared_in, b.caused_turnovers, b.penalties, b.num_faceoffs_taken_last_team_game, b.excess_goals_per_shot, b.usage_adjusted_EGA, b.excess_saves_per_sog, b.on_keeper_sog_faced, b.on_keeper_rate_faced, b.devittes, b.fp_shots, b.fp_goals, b.fp_shooting_pct, b.weighted_team_play_shares, b.turnover_rate, b.is_returning, b.faceoffs_taken, b.share_of_team_assists, b.assist_to_turnover_ratio, b.share_adjusted_assist_rate, b.goals, b.shots, b.excess_shooting_pct, b.coach_assigned_line_ID, b.calculated_line_ID, b.pct_of_shots, b.jersey_number, b.share_of_team_shots, b.seasons_played, b.caused_turnover_to_penalty_ratio, b.on_roster_last_year, b.second_assists, b.third_assists, b.is_individual, b.is_primary_fogo, b.jersey_number, b.height, b.weight, b.shooting_efficiency, b.saved_shot_pct, b.team_custom_usage_adjusted_EGA, b.missed_assists, d.league, a.ID player_ID from LaxRef_Players a, LaxRef_Player_Seasons b, LaxRef_Teams c, LaxRef_Team_Seasons d where d.active and d.team_ID=b.team_ID and b.year=d.year and c.ID=b.team_ID and upper(trim(a.player)) != 'TEAM' and d.league=%s and a.active and b.active and b.player_ID=a.ID and b.year=%s", [run_settings['league'], specs['year']])
                
                
                cursor.execute("SELECT a.player, a.faceoff_ELO, a.seasons_played, a.pro_url_tag, a.is_individual, a.unlocked, b.ID, b.player_ID, b.shots_taken, b.shots_faced, b.goals_scored, b.goals_allowed, b.expected_goals_scored, b.expected_goals_allowed, b.EGA, b.active, b.year, b.team_ID, b.faceoff_wins, b.faceoff_losses, b.faceoff_win_rate, b.team_play_shares, b.role, b.team_listed_role, b.turnovers, b.gbs, b.sog, b.assists, b.sog_faced, b.sog_rate_faced, b.save_pct, b.shooting_pct, b.on_goal_shooting_pct, b.offensive_EGA, b.defensive_EGA, b.faceoff_EGA, b.sog_rate, b.excess_goals_scored, b.excess_saves, b.EGA_per_game, b.games_appeared_in, b.caused_turnovers, b.penalties, b.num_faceoffs_taken_last_team_game, b.excess_goals_per_shot, b.usage_adjusted_EGA, b.excess_saves_per_sog, b.on_keeper_sog_faced, b.on_keeper_rate_faced, b.devittes, b.fp_shots, b.fp_goals, b.fp_shooting_pct, b.weighted_team_play_shares, b.turnover_rate, b.is_returning, b.faceoffs_taken, b.share_of_team_assists, b.assist_to_turnover_ratio, b.share_adjusted_assist_rate, b.goals, b.shots, b.excess_shooting_pct, b.coach_assigned_line_ID, b.calculated_line_ID, b.pct_of_shots, b.jersey_number, b.share_of_team_shots, b.seasons_played, b.caused_turnover_to_penalty_ratio, b.on_roster_last_year, b.second_assists, b.third_assists, b.is_individual, b.is_primary_fogo, b.jersey_number, b.height, b.weight, b.shooting_efficiency, b.saved_shot_pct, b.team_custom_usage_adjusted_EGA, b.missed_assists, d.league, a.ID player_ID from LaxRef_Players a, LaxRef_Player_Seasons b, LaxRef_Teams c, LaxRef_Team_Seasons d where d.active and d.team_ID=b.team_ID and b.year=d.year and c.ID=b.team_ID and upper(trim(a.player)) != 'TEAM' and d.league=%s and a.active and b.active and b.player_ID=a.ID and b.year=%s", [run_settings['league'], specs['year']])
            else:
                #cursor.execute("SELECT a.player, a.hometown, a.faceoff_ELO, a.seasons_played, a.pro_url_tag, a.is_individual, a.unlocked, b.ID, b.player_ID, b.shots_taken, b.shots_faced, b.goals_scored, b.goals_allowed, b.expected_goals_scored, b.expected_goals_allowed, b.EGA, b.active, b.year, b.team_ID, b.faceoff_wins, b.faceoff_losses, b.faceoff_win_rate, b.team_play_shares, b.role, b.team_listed_role, b.turnovers, b.gbs, b.sog, b.assists, b.sog_faced, b.sog_rate_faced, b.save_pct, b.shooting_pct, b.on_goal_shooting_pct, b.offensive_EGA, b.defensive_EGA, b.faceoff_EGA, b.sog_rate, b.excess_goals_scored, b.excess_saves, b.EGA_per_game, b.games_appeared_in, b.caused_turnovers, b.penalties, b.num_faceoffs_taken_last_team_game, b.excess_goals_per_shot, b.usage_adjusted_EGA, b.excess_saves_per_sog, b.on_keeper_sog_faced, b.on_keeper_rate_faced, b.devittes, b.fp_shots, b.fp_goals, b.fp_shooting_pct, b.weighted_team_play_shares, b.turnover_rate, b.is_returning, b.faceoffs_taken, b.share_of_team_assists, b.assist_to_turnover_ratio, b.share_adjusted_assist_rate, b.goals, b.shots, b.excess_shooting_pct, b.coach_assigned_line_ID, b.calculated_line_ID, b.pct_of_shots, b.jersey_number, b.share_of_team_shots, b.seasons_played, b.caused_turnover_to_penalty_ratio, b.on_roster_last_year, b.second_assists, b.third_assists, b.is_individual, b.is_primary_fogo, b.jersey_number, b.height, b.weight, b.shooting_efficiency, b.saved_shot_pct, b.team_custom_usage_adjusted_EGA, b.missed_assists, d.league, a.ID player_ID from LaxRef_Players a, LaxRef_Player_Seasons b, LaxRef_Teams c, LaxRef_Team_Seasons d where d.active and d.team_ID=b.team_ID and b.year=d.year and c.ID=b.team_ID and upper(trim(a.player)) != 'TEAM' and a.active and b.active and b.player_ID=a.ID and b.year=%s", [specs['year']])
        
                cursor.execute("SELECT a.player, a.faceoff_ELO, a.seasons_played, a.pro_url_tag, a.is_individual, a.unlocked, b.ID, b.player_ID, b.shots_taken, b.shots_faced, b.goals_scored, b.goals_allowed, b.expected_goals_scored, b.expected_goals_allowed, b.EGA, b.active, b.year, b.team_ID, b.faceoff_wins, b.faceoff_losses, b.faceoff_win_rate, b.team_play_shares, b.role, b.team_listed_role, b.turnovers, b.gbs, b.sog, b.assists, b.sog_faced, b.sog_rate_faced, b.save_pct, b.shooting_pct, b.on_goal_shooting_pct, b.offensive_EGA, b.defensive_EGA, b.faceoff_EGA, b.sog_rate, b.excess_goals_scored, b.excess_saves, b.EGA_per_game, b.games_appeared_in, b.caused_turnovers, b.penalties, b.num_faceoffs_taken_last_team_game, b.excess_goals_per_shot, b.usage_adjusted_EGA, b.excess_saves_per_sog, b.on_keeper_sog_faced, b.on_keeper_rate_faced, b.devittes, b.fp_shots, b.fp_goals, b.fp_shooting_pct, b.weighted_team_play_shares, b.turnover_rate, b.is_returning, b.faceoffs_taken, b.share_of_team_assists, b.assist_to_turnover_ratio, b.share_adjusted_assist_rate, b.goals, b.shots, b.excess_shooting_pct, b.coach_assigned_line_ID, b.calculated_line_ID, b.pct_of_shots, b.jersey_number, b.share_of_team_shots, b.seasons_played, b.caused_turnover_to_penalty_ratio, b.on_roster_last_year, b.second_assists, b.third_assists, b.is_individual, b.is_primary_fogo, b.height, b.weight, b.shooting_efficiency, b.saved_shot_pct, b.missed_assists, d.league from LaxRef_Players a, LaxRef_Player_Seasons b, LaxRef_Teams c, LaxRef_Team_Seasons d where d.active and d.team_ID=b.team_ID and b.year=d.year and c.ID=b.team_ID and upper(trim(a.player)) != 'TEAM' and a.active and b.active and b.player_ID=a.ID and b.year=%s", [specs['year']])
        
        else:
            cursor.execute("SELECT a.player, a.hometown, a.faceoff_ELO, a.faceoff_ELO_rank, a.seasons_played, a.pro_url_tag, a.is_individual, a.unlocked, b.ID, b.player_ID, b.shots_taken, b.shots_faced, b.goals_scored, b.goals_allowed, b.expected_goals_scored, b.expected_goals_allowed, b.EGA, b.active, b.year, b.team_ID, b.faceoff_wins, b.faceoff_losses, b.faceoff_win_rate, b.team_play_shares, b.role, b.team_listed_role, b.turnovers, b.gbs, b.sog, b.assists, b.sog_faced, b.sog_rate_faced, b.save_pct, b.shooting_pct, b.on_goal_shooting_pct, b.offensive_EGA, b.defensive_EGA, b.faceoff_EGA, b.sog_rate, b.excess_goals_scored, b.excess_saves, b.turnovers_rank, b.EGA_rank, b.offensive_EGA_rank, b.defensive_EGA_rank, b.faceoff_EGA_rank, b.sog_rate_rank, b.save_pct_rank, b.excess_goals_scored_rank, b.excess_saves_rank, b.EGA_per_game, b.EGA_per_game_rank, b.games_appeared_in, b.caused_turnovers, b.penalties, b.num_faceoffs_taken_last_team_game, b.excess_goals_per_shot, b.excess_goals_per_shot_rank, b.usage_adjusted_EGA, b.excess_saves_per_sog, b.excess_saves_per_sog_rank, b.on_keeper_sog_faced, b.on_keeper_rate_faced, b.devittes, b.fp_shots, b.fp_goals, b.fp_shooting_pct, b.weighted_team_play_shares, b.turnover_rate, b.turnover_rate_rank, b.is_returning, b.faceoff_win_rate_rank, b.faceoffs_taken, b.share_of_team_assists, b.tewaaraton, b.assist_to_turnover_ratio, b.share_adjusted_assist_rate, b.tewaaraton_finalist, b.goals, b.shots, b.usage_adjusted_EGA_rank, b.assist_to_turnover_ratio_rank, b.excess_shooting_pct, b.excess_shooting_pct_rank, b.points, b.points_per_game, b.points_per_game_rank, b.points_rank, b.coach_assigned_line_ID, b.calculated_line_ID, b.pct_of_shots, b.jersey_number, b.share_of_team_shots, b.seasons_played, b.caused_turnover_to_penalty_ratio, b.on_roster_last_year, b.second_assists, b.third_assists, b.share_adjusted_assist_rate_rank, b.is_individual, b.faceoff_conversion_rate, b.faceoff_conversion_rate_rank, b.usage_adjusted_EGA_percentile, b.EGA_per_game_percentile, b.EGA_percentile, b.offensive_EGA_percentile, b.defensive_EGA_percentile, b.faceoff_EGA_percentile, b.excess_goals_scored_percentile, b.excess_goals_per_shot_percentile, b.excess_saves_percentile, b.shooting_pct_percentile, b.share_adjusted_assist_rate_percentile, b.sog_rate_percentile, b.turnover_rate_percentile, b.is_primary_fogo, b.save_pct_percentile, b.assist_to_turnover_ratio_percentile, b.jersey_number, b.height, b.weight, b.points_per_game_percentile, b.caused_turnovers_rank, b.caused_turnovers_percentile, b.shooting_efficiency, b.shooting_efficiency_rank, b.caused_turnover_to_penalty_ratio_rank, b.caused_turnover_to_penalty_ratio_percentile, b.saved_shot_pct, b.saved_shot_pct_rank, b.saved_shot_pct_percentile, b.team_custom_usage_adjusted_EGA, b.missed_assists, b.drawn_penalties, d.league, a.ID player_ID from LaxRef_Players a, LaxRef_Player_Seasons b, LaxRef_Teams c, LaxRef_Team_Seasons d where d.active and d.team_ID=b.team_ID and b.year=d.year and c.ID=b.team_ID and upper(trim(a.player)) != 'TEAM' and a.active and b.active and b.player_ID=a.ID and b.year=%s", [specs['year']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_players = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_players', all_players)
        
        goalies = [z for z in all_players if z['shots_faced'] is not None and z['shots_faced'] > 0]
        for a in all_players:
            a['EGA_per_game_rank_str'] = "N/A" if 'EGA_per_game_rank' not in a or a['EGA_per_game_rank'] is None else ("%d%s" % (a['EGA_per_game_rank'], zc.get_number_suffix(a['EGA_per_game_rank'])))


        for g in goalies:
            g['save_pct'] = None if g['sog_faced'] in [None, 0] else ((g['sog_faced'] - g['goals_allowed'])/g['sog_faced'])
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_players".format(len(all_players)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_players".format(len(all_players)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'goalies'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(goalies))); f.close(); conn, cursor = reconnect_db(conn, cursor)
        tmp_start_ms = time.time()
        if USE_ZGAMEYEAR:
            if run_settings['league'] is None:
                cursor.execute("SELECT a.ID, a.player_ID, a.game_ID, a.EGA, a.faceoff_EGA, a.offensive_EGA, a.defensive_EGA, a.team_ID, a.shots, a.goals, a.sog, a.assists, a.turnovers, a.gbs, a.penalties, a.faceoff_wins, a.faceoffs_taken, a.caused_turnovers, a.shots_faced, a.sog_faced, a.sog_rate_faced, a.save_pct, a.plays_recorded, a.team_play_shares, a.weighted_play_share, a.saves, a.on_keeper_faced, a.usage_adjusted_EGA, a.shooting_pct, a.opp_team_ID, a.turnover_rate, a.faceoff_win_rate, a.points, a.pct_of_shots, a.sog_rate, a.fp_shots, a.fp_goals, a.fp_shooting_pct, a.on_keeper_shots, c.team_listed_role, IFNULL(c.coach_assigned_line_ID, IFNULL(c.calculated_line_ID,0)) calculated_line_ID, c.has_highest_share_of_team_assists, c.has_highest_excess_goals_per_shot, c.has_highest_goals, c.has_highest_shots, c.is_primary_fogo, c.has_highest_weighted_team_play_shares, c.has_highest_usage_adjusted_EGA, c.has_highest_points, c.has_highest_turnover_rate, c.team_play_shares season_team_play_shares from LaxRef_Player_Game_Summaries a, LaxRef_Games b, LaxRef_Player_Seasons c where b.status like 'comp%%' and IFNULL(b.game_type,'')='' and c.year=zgame_year and c.player_ID=a.player_ID and zgame_year=%s and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active=1", [specs['year']])
            else:
                cursor.execute("SELECT a.ID, a.player_ID, a.game_ID, a.EGA, a.faceoff_EGA, a.offensive_EGA, a.defensive_EGA, a.team_ID, a.shots, a.goals, a.sog, a.assists, a.turnovers, a.gbs, a.penalties, a.faceoff_wins, a.faceoffs_taken, a.caused_turnovers, a.shots_faced, a.sog_faced, a.sog_rate_faced, a.save_pct, a.plays_recorded, a.team_play_shares, a.weighted_play_share, a.saves, a.on_keeper_faced, a.usage_adjusted_EGA, a.shooting_pct, a.opp_team_ID, a.turnover_rate, a.faceoff_win_rate, a.points, a.pct_of_shots, a.sog_rate, a.fp_shots, a.fp_goals, a.fp_shooting_pct, a.on_keeper_shots, c.team_listed_role, IFNULL(c.coach_assigned_line_ID, IFNULL(c.calculated_line_ID,0)) calculated_line_ID, c.has_highest_share_of_team_assists, c.has_highest_excess_goals_per_shot, c.has_highest_goals, c.has_highest_shots, c.is_primary_fogo, c.has_highest_weighted_team_play_shares, c.has_highest_usage_adjusted_EGA, c.has_highest_points, c.has_highest_turnover_rate, c.team_play_shares season_team_play_shares from LaxRef_Player_Game_Summaries a, LaxRef_Games b, LaxRef_Player_Seasons c where b.status like 'comp%%' and IFNULL(b.game_type,'')='' and b.league=%s and c.year=zgame_year and c.player_ID=a.player_ID and zgame_year=%s and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active=1 and c.active", [run_settings['league'], specs['year']])
        else:
            if run_settings['league'] is None:
                cursor.execute("SELECT a.ID, a.player_ID, a.game_ID, a.EGA, a.faceoff_EGA, a.offensive_EGA, a.defensive_EGA, a.team_ID, a.shots, a.goals, a.sog, a.assists, a.turnovers, a.gbs, a.penalties, a.faceoff_wins, a.faceoffs_taken, a.caused_turnovers, a.shots_faced, a.sog_faced, a.sog_rate_faced, a.save_pct, a.plays_recorded, a.team_play_shares, a.weighted_play_share, a.saves, a.on_keeper_faced, a.usage_adjusted_EGA, a.shooting_pct, a.opp_team_ID, a.turnover_rate, a.faceoff_win_rate, a.points, a.pct_of_shots, a.sog_rate, a.fp_shots, a.fp_goals, a.fp_shooting_pct, a.on_keeper_shots, c.team_listed_role, IFNULL(c.coach_assigned_line_ID, IFNULL(c.calculated_line_ID,0)) calculated_line_ID, c.has_highest_share_of_team_assists, c.has_highest_excess_goals_per_shot, c.has_highest_goals, c.has_highest_shots, c.is_primary_fogo, c.has_highest_weighted_team_play_shares, c.has_highest_usage_adjusted_EGA, c.has_highest_points, c.has_highest_turnover_rate, c.team_play_shares season_team_play_shares from LaxRef_Player_Game_Summaries a, LaxRef_Games b, LaxRef_Player_Seasons c where b.status like 'comp%%' and IFNULL(b.game_type,'')='' and c.year=b.zgame_year and c.player_ID=a.player_ID and YEAR(game_date)=%s and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active=1", [specs['year']])
            else:
                cursor.execute("SELECT a.ID, a.player_ID, a.game_ID, a.EGA, a.faceoff_EGA, a.offensive_EGA, a.defensive_EGA, a.team_ID, a.shots, a.goals, a.sog, a.assists, a.turnovers, a.gbs, a.penalties, a.faceoff_wins, a.faceoffs_taken, a.caused_turnovers, a.shots_faced, a.sog_faced, a.sog_rate_faced, a.save_pct, a.plays_recorded, a.team_play_shares, a.weighted_play_share, a.saves, a.on_keeper_faced, a.usage_adjusted_EGA, a.shooting_pct, a.opp_team_ID, a.turnover_rate, a.faceoff_win_rate, a.points, a.pct_of_shots, a.sog_rate, a.fp_shots, a.fp_goals, a.fp_shooting_pct, a.on_keeper_shots, c.team_listed_role, IFNULL(c.coach_assigned_line_ID, IFNULL(c.calculated_line_ID,0)) calculated_line_ID, c.has_highest_share_of_team_assists, c.has_highest_excess_goals_per_shot, c.has_highest_goals, c.has_highest_shots, c.is_primary_fogo, c.has_highest_weighted_team_play_shares, c.has_highest_usage_adjusted_EGA, c.has_highest_points, c.has_highest_turnover_rate, c.team_play_shares season_team_play_shares from LaxRef_Player_Game_Summaries a, LaxRef_Games b, LaxRef_Player_Seasons c where b.status like 'comp%%' and IFNULL(b.game_type,'')='' and b.league=%s and c.year=b.zgame_year and c.player_ID=a.player_ID and YEAR(game_date)=%s and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active=1", [run_settings['league'], specs['year']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        player_game_summaries = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'player_game_summaries', player_game_summaries)
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} player_game_summaries".format(len(player_game_summaries)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'player_game_summaries'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(player_game_summaries))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        player_game_summaries_by_game = []
        for i in range(mod_val):
            player_game_summaries_by_game.append([z for z in player_game_summaries if int(z['game_ID'] % mod_val) == i])

        tmp_start_ms = time.time()
        cursor.execute("SELECT a.player, num_faceoffs_taken_last_team_game, team_ID, a.ID 'player_ID', b.faceoff_ELO_history, b.faceoff_win_rate, a.faceoff_ELO, b.faceoff_wins, b.faceoff_losses from LaxRef_Players a, LaxRef_Player_Seasons b where upper(trim(a.player)) != 'TEAM' and a.active and ((b.active and b.player_ID=a.ID and b.year=%s))", [specs['year']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        print ("{:<40} @ {}".format ("Query 1 Done", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        fogos = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'fogos', fogos)


        tmp_start_ms = time.time()
        cursor.execute("SELECT a.player, num_faceoffs_taken_last_team_game, team_ID, a.ID 'player_ID', b.faceoff_ELO_history, b.faceoff_win_rate, a.faceoff_ELO, b.faceoff_wins, b.faceoff_losses from LaxRef_Players a, LaxRef_Player_Seasons b where upper(trim(a.player)) != 'TEAM' and a.active and NOT ISNULL(b.faceoff_ELO_history) and b.active and b.player_ID=a.ID and b.year=%s", [specs['last_year']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        print ("{:<40} @ {}".format ("Query 2 Done", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        ly_fogos = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'ly_fogos', ly_fogos)

        for f in fogos:
            f['active_this_year'] = 0 if f['faceoff_ELO_history'] is None else 1
            f['active_last_year'] = None

            #f['faceoff_ELO_history'] = None
            f['faceoff_win_rate_str'] = "N/A"
            f['faceoff_ELO_str'] = "N/A"
            f['faceoff_ELO_rank_str'] = "N/A"
            f['total_FOs'] = None
            
            

            if None not in [f['faceoff_wins'], f['faceoff_losses']]:
                if f['faceoff_ELO_history'] is not None:
                    f['faceoff_ELO_history'] = json.loads(f['faceoff_ELO_history'])
                f['faceoff_win_rate_str'] = ("%.1f%%" % (f['faceoff_win_rate'] * 100.)) if f['faceoff_win_rate'] is not None else "N/A"
                f['faceoff_ELO_str'] = "N/A" if f['faceoff_ELO'] is None else "%d" % f['faceoff_ELO']
                f['total_FOs'] = float(f['faceoff_wins']) + float(f['faceoff_losses'])
            elif f['player_ID'] in [z['player_ID'] for z in ly_fogos]: # Try getting their info from the prior year
                ly_fogo = ly_fogos[ [z['player_ID'] for z in ly_fogos].index(f['player_ID']) ]
                f['faceoff_ELO_history'] = json.loads(ly_fogo['faceoff_ELO_history'])
                f['active_last_year'] = 0 if f['faceoff_ELO_history'] is None else 1
            else:
                f['faceoff_ELO_history'] = None
        fogos = [z for z in fogos if z['faceoff_ELO_history'] is not None]
       

        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} fogos".format(len(fogos)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} fogos".format(len(fogos)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'fogos'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(fogos))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        if run_settings['league'] is None:
            cursor.execute("SELECT a.game_ID, a.team_ID, a.stat_ID, a.adjustment, a.offense from LaxRef_Game_Stat_Adjustments a", [])
        else:
            cursor.execute("SELECT a.game_ID, a.team_ID, a.stat_ID, a.adjustment, a.offense from LaxRef_Game_Stat_Adjustments a, LaxRef_Games b where IFNULL(b.game_type,'')='' and b.active and b.league=%s and b.ID=a.game_ID", [run_settings['league']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        game_stat_adjustments = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'game_stat_adjustments', game_stat_adjustments)
        for g in game_stat_adjustments:
            g['tup'] = (g['team_ID'], g['game_ID'])
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} game_stat_adjustments".format(len(game_stat_adjustments)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} game_stat_adjustments".format(len(game_stat_adjustments)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        all_efficiency_game_adjustments = [z for z in game_stat_adjustments if z['stat_ID'] == 1]
       
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'game_stat_adjustments'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(game_stat_adjustments))); f.close(); conn, cursor = reconnect_db(conn, cursor)
        
        efficiency_game_adjustments = []
        for i in range(mod_val):
            efficiency_game_adjustments.append([z for z in all_efficiency_game_adjustments if int(z['game_ID'] % mod_val) == i])
        all_efficiency_game_adjustments = None    

        tmp_start_ms = time.time()
        cursor.execute("SELECT a.* from LaxRef_Season_Stat_Adjustments a", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        season_stat_adjustments = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'season_stat_adjustments', season_stat_adjustments)
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} season_stat_adjustments".format(len(season_stat_adjustments)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        for g in season_stat_adjustments:
            g['tup'] = (g['team_ID'], g['year'])
        
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'season_stat_adjustments'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(season_stat_adjustments))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        cursor.execute("SELECT ID, active, stat, description, js_fmt, fmt, reverse, both_units, display_on_LR, short_code, use_in_player_outcome_splits, player_outcome_splits_priority, numerator, denominator, relevant_subjects from LaxRef_Statistics", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_statistics = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_statistics', all_statistics)
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_statistics".format(len(all_statistics)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_statistics".format(len(all_statistics)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        
        tmp_start_ms = time.time()
        cursor.execute("SELECT * from LaxRef_Player_Groupings", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        player_groupings = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'player_groupings', player_groupings)
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} player_groupings".format(len(player_groupings)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} player_groupings".format(len(player_groupings)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        
        
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_statistics'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_statistics))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        cursor.execute("SELECT a.ID, a.game_file, a.game_ID, b.game_date, a.confirmed_away_team, a.confirmed_home_team, a.home_ID, a.away_ID, a.post_ID from LaxRef_Game_Streams a, LaxRef_Games b where b.ID=a.game_ID and a.active and b.active", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_game_streams = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_game_streams', all_game_streams)
        for a in all_game_streams:
            a['sorted_IDs'] = None
            if None not in [a['away_ID'], a['home_ID']]:
                a['sorted_IDs'] = "%s|%d|%d" % (a['game_date'].strftime("%Y%m%d"), min(a['away_ID'], a['home_ID']), max(a['away_ID'], a['home_ID']))
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_game_streams".format(len(all_game_streams)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_game_streams".format(len(all_game_streams)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_game_streams'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_game_streams))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        cursor.execute("SELECT b.*, a.datestamp from LaxRef_PostSeason_Simulations a, LaxRef_PostSeason_SimResults b where YEAR(datestamp)=%s and b.sim_ID=a.ID and b.active and a.active", [specs['year']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        sim_results = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'sim_results', sim_results)
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} sim_results".format(len(sim_results)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} sim_results".format(len(sim_results)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'sim_results'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(sim_results))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        cursor.execute("SELECT * from LaxRef_Conferences", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        conferences = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'conferences', conferences)
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} conferences".format(len(conferences)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} conferences".format(len(conferences)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'conferences'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(conferences))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()

        if run_settings['league'] is None:
            cursor.execute("SELECT a.ID, a.started_with, a.duration, a.before_shot, a.team_ID, a.opp_ID, a.num_shots, a.shots_on_goal, a.goal, a.turnover, b.zgame_year 'year', a.game_ID, a.start_time, b.league, a.team_odds from LaxRef_Possessions a, LaxRef_Games b where IFNULL(b.game_type, '') != 'Non-Division' and b.league like 'NCAA D%%' and zgame_year >= %s and zgame_year <= %s and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active and b.active order by b.game_date desc, start_time desc", [specs['last_year'], specs['last_year'] + 2])
        else:
            cursor.execute("SELECT a.ID, a.started_with, a.duration, a.before_shot, a.team_ID, a.opp_ID, a.num_shots, a.shots_on_goal, a.goal, a.turnover, b.zgame_year 'year', a.game_ID, a.start_time, a.team_odds from LaxRef_Possessions a, LaxRef_Games b where IFNULL(b.only_box_score, 0)=0 and IFNULL(b.game_type, '') = '' and b.league=%s and zgame_year >= %s and zgame_year <= %s and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active and b.active order by b.game_date desc, start_time desc", [run_settings['league'], specs['last_year'], specs['last_year'] + 2])
        
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_possessions = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_possessions', all_possessions)

        #print "\n{:<30}{:>15,}".format("Skinny", len(json.dumps(all_possessions)))


        #cursor.close(); conn.close(); zc.exit("laxref0016")
        for p in all_possessions:
            p['quarter'] = int(min(3599., p['start_time'])/900.)
            p['adj_before_shot'] = None if p['before_shot'] is None else min(79, p['before_shot'])
            p['adj_duration'] = min(79, p['duration'])
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_possessions".format(len(all_possessions)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_possessions".format(len(all_possessions)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_possessions'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_possessions))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()

        if run_settings['league'] is None:
            cursor.execute("SELECT a.ID, a.team_ID, a.opp_team_ID, a.game_ID, a.winner_ID, a.loser_ID, a.picked_up_by_ID, a.time_elapsed, a.following, a.team_odds, a.game_state, a.won_on_violation, a.converted_to_possession, b.zgame_year 'year' from LaxRef_Faceoffs a, LaxRef_Games b where a.active and b.active and (zgame_year = %s or zgame_year=%s) and b.ID=a.game_ID and b.league like 'NCAA D%%' and b.status like 'complete%%'", [specs['year'], specs['last_year']])
        else:
            cursor.execute("SELECT a.ID, a.team_ID, a.opp_team_ID, a.game_ID, a.winner_ID, a.loser_ID, a.picked_up_by_ID, a.time_elapsed, a.following, a.team_odds, a.game_state, a.won_on_violation, a.converted_to_possession, b.zgame_year 'year' from LaxRef_Faceoffs a, LaxRef_Games b where IFNULL(b.game_type,'')='' and IFNULL(b.only_box_score, 0)=0 and a.active and b.active and (zgame_year = %s or zgame_year=%s) and b.ID=a.game_ID and b.league=%s and b.status like 'complete%%'", [specs['year'], specs['last_year'], run_settings['league']])

        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_faceoffs = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_faceoffs', all_faceoffs)
        
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_faceoffs".format(len(all_faceoffs)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_faceoffs".format(len(all_faceoffs)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_faceoffs'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_faceoffs))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        if run_settings['league'] is None:
            cursor.execute("SELECT a.adjusted_efficiency, a.adjusted_assist_rate, a.adjusted_time_of_possession, a.adjusted_turnover_rate, a.adjusted_clear_rate, a.adjusted_ride_rate, a.adjusted_emo_efficiency, a.adjusted_faceoff_conversion_rate, a.adjusted_faceoff_win_rate, a.adjusted_shooting_pct, a.adjusted_shooting_efficiency, a.adjusted_on_goal_shooting_pct, a.adjusted_sog_rate, a.adjusted_gb_win_rate, a.adjusted_save_pct, a.adjusted_modified_possession_margin, a.game_ID, a.team_ID, a.opp_team_ID, a.goals, a.possessions, a.adjusted_shots_per_possession, a.shots, a.sog, a.efficiency, a.save_pct, a.shooting_pct, a.sog_rate, a.faceoff_wins, a.faceoff_losses, a.faceoff_win_rate, a.turnover_rate, a.gbs_won, a.gbs_lost, a.gb_win_rate, a.time_of_possession, a.avg_possession_length, a.time_to_first_shot, a.shots_per_possession, a.data_type, a.saves, a.turnovers, a.poss_w_shot, a.modified_possession_margin, a.possession_margin, a.possessions_plus_failed_clears, a.good_clears, a.failed_clears, a.assists, a.assist_rate, a.win, a.penalties, a.man_up_goals, a.man_up_chances, a.man_down_goals, a.on_goal_shooting_pct, a.filter, a.filter_val, a.shots_saved, a.sog_faced, a.on_keeper_shots, a.on_keeper_shots_faced, a.shooting_EGA, a.clear_rate, a.ride_rate, a.emo_efficiency, a.faceoff_conversions, a.on_goal_shooting_pct, a.faceoff_conversion_rate, a.fp_efficiency, a.fp_utilization, a.fp_shooting_pct, a.game_date, a.fp_shooter_pct, a.fp_attempts, a.fp_goals, a.fp_shots, a.fp_shots_off_one_pass, b.league, CASE WHEN c.conference_ID=d.conference_ID OR abs(b.home_elo - b.away_elo) < 200 THEN 1 ELSE 0 END is_peer, c.conference_ID=d.conference_ID is_conference from LaxRef_Team_Game_Summaries a, LaxRef_Games b, LaxRef_Team_Seasons c, LaxRef_Team_Seasons d where IFNULL(b.game_type, '')='' and d.year=c.year and d.year=%s and b.home_ID=c.team_ID and b.league like 'NCAA D%%' and b.away_ID=d.team_ID and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active=1", [specs['year']])
        else:
            cursor.execute("SELECT a.adjusted_efficiency, a.adjusted_assist_rate, a.adjusted_time_of_possession, a.adjusted_turnover_rate, a.adjusted_clear_rate, a.adjusted_ride_rate, a.adjusted_emo_efficiency, a.adjusted_faceoff_conversion_rate, a.adjusted_faceoff_win_rate, a.adjusted_shooting_pct, a.adjusted_shooting_efficiency, a.adjusted_on_goal_shooting_pct, a.adjusted_sog_rate, a.adjusted_gb_win_rate, a.adjusted_save_pct, a.adjusted_modified_possession_margin, a.game_ID, a.team_ID, a.opp_team_ID, a.goals, a.possessions, a.adjusted_shots_per_possession, a.shots, a.sog, a.efficiency, a.save_pct, a.shooting_pct, a.shooting_efficiency, a.sog_rate, a.faceoff_wins, a.on_goal_shooting_pct, a.faceoff_losses, a.faceoff_win_rate, a.turnover_rate, a.gbs_won, a.gbs_lost, a.gb_win_rate, a.time_of_possession, a.avg_possession_length, a.time_to_first_shot, a.shots_per_possession, a.data_type, a.saves, a.turnovers, a.poss_w_shot, a.modified_possession_margin, a.possession_margin, a.possessions_plus_failed_clears, a.good_clears, a.failed_clears, a.assists, a.shooting_EGA, a.assist_rate, a.win, a.penalties, a.man_up_goals, a.man_up_chances, a.man_down_goals, a.filter, a.filter_val, a.shots_saved, a.sog_faced, a.on_keeper_shots, a.on_keeper_shots_faced, a.clear_rate, a.ride_rate, a.emo_efficiency, a.faceoff_conversions, a.faceoff_conversion_rate, a.fp_efficiency, a.fp_utilization, a.fp_shooting_pct, a.game_date, a.fp_shooter_pct, a.fp_attempts, a.fp_goals, a.fp_shots, a.fp_shots_off_one_pass, b.league, CASE WHEN c.conference_ID=d.conference_ID OR abs(b.home_elo - b.away_elo) < 200 THEN 1 ELSE 0 END is_peer, c.conference_ID=d.conference_ID is_conference from LaxRef_Team_Game_Summaries a, LaxRef_Games b, LaxRef_Team_Seasons c, LaxRef_Team_Seasons d where IFNULL(b.game_type, '')='' and d.year=c.year and d.year=%s and b.home_ID=c.team_ID and b.league=%s and b.away_ID=d.team_ID and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active and b.active and c.active and d.active", [specs['year'], run_settings['league']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_summaries = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_summaries', all_summaries)
        
        for a in all_summaries:
            a['next_year'] = 1 if a['game_date'].year == (specs['year'] + 1) else 0
            a['this_year'] = 1 if a['game_date'].year == specs['year'] else 0
            a['last_year'] = 1 if a['game_date'].year == specs['last_year'] else 0
            a['game_year'] = a['game_date'].year
            a['game_epoch'] = (a['game_date'] - datetime(1970, 1, 1)).total_seconds()


            a['game_month'] = a['game_date'].month
            a['game_date'] = None

        all_summaries_by_team = []
        for i in range(mod_val):
            all_summaries_by_team.append([z for z in all_summaries if int(z['team_ID'] % mod_val) == i])

        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_summaries".format(len(all_summaries)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_summaries".format(len(all_summaries)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_summaries'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_summaries))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()
        if run_settings['league'] is None:
            cursor.execute("SELECT a.*, d_off.shots/d_off.possessions off_shots_per_possession, d_def.shots/d_def.possessions def_shots_per_possession, d_def.total_possession_time/d_def.possessions def_avg_possession_length, d_off.total_possession_time/d_off.possessions off_avg_possession_length, a.def_pace def_time_to_first_shot, a.off_pace off_time_to_first_shot, d_off.goals/a.games_played off_goals, d_def.goals/a.games_played def_goals, d_off.turnovers/a.games_played off_turnovers, d_def.turnovers/a.games_played def_turnovers, d_off.shots/a.games_played off_shots, d_def.shots/a.games_played def_shots, d_off.possessions/a.games_played off_possessions, d_def.possessions/a.games_played def_possessions, b.league, c.short_code 'conf_short_code', c.independent from LaxRef_Team_Seasons a, LaxRef_Teams b, LaxRef_Conferences c, (SELECT team_ID, year(game_date) year, sum(goals) goals, sum(possessions) possessions, sum(avg_possession_length*possessions) total_possession_time, sum(turnovers) turnovers, sum(time_of_possession) time_of_possession, sum(shots) shots from LaxRef_Team_Game_Summaries d1 where d1.active and d1.data_type='offense' and ISNULL(d1.filter) group by d1.team_ID, year(game_date)) d_off, (SELECT team_ID, year(game_date) year, sum(goals) goals, sum(possessions) possessions, sum(avg_possession_length*possessions) total_possession_time, sum(turnovers) turnovers, sum(time_of_possession) time_of_possession, sum(shots) shots from LaxRef_Team_Game_Summaries d1 where d1.active and d1.data_type='defense' and ISNULL(d1.filter) group by d1.team_ID, year(game_date)) d_def where d_def.year=a.year and d_def.team_ID=a.team_ID and d_off.year=a.year and d_off.team_ID=a.team_ID and a.active and b.active and c.ID = a.conference_ID and a.league like 'NCAA D%%' and b.ID=a.team_ID", [])
        else:
            cursor.execute("SELECT a.*, d_off.shots/d_off.possessions off_shots_per_possession, d_def.shots/d_def.possessions def_shots_per_possession, d_def.total_possession_time/d_def.possessions def_avg_possession_length, d_off.total_possession_time/d_off.possessions off_avg_possession_length, a.def_pace def_time_to_first_shot, a.off_pace off_time_to_first_shot, d_off.goals/a.games_played off_goals, d_def.goals/a.games_played def_goals, d_off.turnovers/a.games_played off_turnovers, d_def.turnovers/a.games_played def_turnovers, d_off.shots/a.games_played off_shots, d_def.shots/a.games_played def_shots, d_off.possessions/a.games_played off_possessions, d_def.possessions/a.games_played def_possessions, a.league, c.short_code 'conf_short_code', c.independent from LaxRef_Team_Seasons a, LaxRef_Teams b, LaxRef_Conferences c, (SELECT team_ID, year(game_date) year, sum(goals) goals, sum(possessions) possessions, sum(avg_possession_length*possessions) total_possession_time, sum(turnovers) turnovers, sum(time_of_possession) time_of_possession, sum(shots) shots from LaxRef_Team_Game_Summaries d1 where d1.active and d1.data_type='offense' and ISNULL(d1.filter) group by d1.team_ID, year(game_date)) d_off, (SELECT team_ID, year(game_date) year, sum(goals) goals, sum(possessions) possessions, sum(avg_possession_length*possessions) total_possession_time, sum(turnovers) turnovers, sum(time_of_possession) time_of_possession, sum(shots) shots from LaxRef_Team_Game_Summaries d1 where d1.active and d1.data_type='defense' and ISNULL(d1.filter) group by d1.team_ID, year(game_date)) d_def where d_def.year=a.year and d_def.team_ID=a.team_ID and d_off.year=a.year and d_off.team_ID=a.team_ID and a.active and b.active and c.ID = a.conference_ID and a.league=%s and b.ID=a.team_ID", [run_settings['league']])
            query = "Select teams.*, CASE WHEN NOT ISNULL(d_off.shots) THEN d_off.shots/d_off.possessions ELSE NULL END off_shots_per_possession, CASE WHEN NOT ISNULL(d_off.shots) THEN d_def.shots/d_def.possessions ELSE NULL END def_shots_per_possession, CASE WHEN NOT ISNULL(d_off.shots) THEN d_def.total_possession_time/d_def.possessions ELSE NULL END def_avg_possession_length, CASE WHEN NOT ISNULL(d_off.shots) THEN d_off.total_possession_time/d_off.possessions ELSE NULL END off_avg_possession_length, teams.def_pace def_time_to_first_shot, teams.off_pace off_time_to_first_shot, CASE WHEN NOT ISNULL(d_off.shots) THEN d_off.goals/teams.games_played ELSE NULL END off_goals, CASE WHEN NOT ISNULL(d_off.shots) THEN d_def.goals/teams.games_played ELSE NULL END def_goals, CASE WHEN NOT ISNULL(d_off.shots) THEN d_off.turnovers/teams.games_played ELSE NULL END off_turnovers, CASE WHEN NOT ISNULL(d_off.shots) THEN d_def.turnovers/teams.games_played ELSE NULL END def_turnovers, CASE WHEN NOT ISNULL(d_off.shots) THEN d_off.shots/teams.games_played ELSE NULL END off_shots, CASE WHEN NOT ISNULL(d_off.shots) THEN d_def.shots/teams.games_played ELSE NULL END def_shots, CASE WHEN NOT ISNULL(d_off.shots) THEN d_off.possessions/teams.games_played ELSE NULL END off_possessions, CASE WHEN NOT ISNULL(d_off.shots) THEN d_def.possessions/teams.games_played ELSE NULL END def_possessions, d_off.possessions, d_def.possessions from (SELECT a.*, c.short_code 'conf_short_code', c.independent from LaxRef_Team_Seasons a, LaxRef_Teams b, LaxRef_Conferences c where a.active and b.active and c.ID=a.conference_ID and a.league=%s and a.team_ID=b.ID) teams LEFT JOIN (SELECT team_ID, sum(goals) goals, sum(possessions) possessions, sum(avg_possession_length*possessions) total_possession_time, sum(turnovers) turnovers, sum(time_of_possession) time_of_possession, sum(shots) shots, year(d1.game_date) year from LaxRef_Team_Game_Summaries d1 where d1.active and d1.data_type='offense' and ISNULL(d1.filter) group by d1.team_ID, year(d1.game_date)) d_off ON teams.year=d_off.year and d_off.team_ID=teams.team_ID LEFT JOIN (SELECT team_ID, sum(goals) goals, sum(possessions) possessions, sum(avg_possession_length*possessions) total_possession_time, sum(turnovers) turnovers, sum(time_of_possession) time_of_possession, sum(shots) shots ,year(d1.game_date) year from LaxRef_Team_Game_Summaries d1 where d1.active and d1.data_type='defense' and ISNULL(d1.filter) group by d1.team_ID, year(d1.game_date)) d_def ON d_def.team_ID=teams.team_ID and teams.year=d_def.year"
            cursor.execute(query, [run_settings['league']])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_team_seasons = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_team_seasons', all_team_seasons)
        
        for a in all_team_seasons:
            a['modified_possession_margin'] = (a['modified_possession_margin']/a['games_played']) if None not in [a['modified_possession_margin'], a['games_played']] and a['games_played'] > 0 else None
            a['def_efficiency_inverted'] = None if a['def_efficiency'] is None else 1. - a['def_efficiency']
            a['rankings_dict'] = None
            a['dc_rankings_dict'] = None
            if a['adjusted_off_efficiency_rank'] is None:
                a['rankings_summary_str'] = ""
                a['rankings_summary_str_mob'] = ""
            else:
                tmp = ["Off: %d%s" % (a['adjusted_off_efficiency_rank'], zc.get_number_suffix(a['adjusted_off_efficiency_rank']))
                       , "Def: %d%s" % (a['adjusted_def_efficiency_rank'], zc.get_number_suffix(a['adjusted_def_efficiency_rank']))
                       , "FO: %d%s" % (a['adjusted_faceoff_win_rate_rank'], zc.get_number_suffix(a['adjusted_faceoff_win_rate_rank']))
                       , "GK: %d%s" % (a['adjusted_def_save_pct_rank'], zc.get_number_suffix(a['adjusted_def_save_pct_rank']))]
                a['rankings_summary_str'] = " / ".join(tmp)
                a['rankings_summary_str_mob'] = " / ".join(tmp[0:2])
                a['rankings_dict'] = []
                a['rankings_dict'].append({'unit': 'offense', 'val': a['adjusted_off_efficiency'], 'rank': a['adjusted_off_efficiency_rank'], 'rank_str': "%d%s" % (a['adjusted_off_efficiency_rank'], zc.get_number_suffix(a['adjusted_off_efficiency_rank']))})
                a['rankings_dict'].append({'unit': 'defense', 'val': a['adjusted_def_efficiency'], 'rank': a['adjusted_def_efficiency_rank'], 'rank_str': "%d%s" % (a['adjusted_def_efficiency_rank'], zc.get_number_suffix(a['adjusted_def_efficiency_rank']))})
                a['rankings_dict'].append({'unit': 'faceoffs', 'val': a['adjusted_faceoff_win_rate'], 'rank': a['adjusted_faceoff_win_rate_rank'], 'rank_str': "%d%s" % (a['adjusted_faceoff_win_rate_rank'], zc.get_number_suffix(a['adjusted_faceoff_win_rate_rank']))})
                a['rankings_dict'].append({'unit': 'goalkeepers', 'val': a['adjusted_def_save_pct'], 'rank': a['adjusted_def_save_pct_rank'], 'rank_str': "%d%s" % (a['adjusted_def_save_pct_rank'], zc.get_number_suffix(a['adjusted_def_save_pct_rank']))})
                
                a['rankings_dict'].append({'unit': 'faceoffs', 'rank_str': "%d%s" % (a['adjusted_faceoff_win_rate_rank'], zc.get_number_suffix(a['adjusted_faceoff_win_rate_rank'])), 'tag': 'faceoff_win_rate', 'raw_val': a['faceoff_win_rate'], 'adjusted_val': a['adjusted_faceoff_win_rate'], 'raw_rank': a['faceoff_win_rate_rank'], 'adjusted_rank': a['adjusted_faceoff_win_rate_rank']})
                a['rankings_dict'].append({'unit': 'faceoffs', 'tag': 'off_faceoff_conversion_rate', 'raw_val': a['off_faceoff_conversion_rate'], 'adjusted_val': a['adjusted_off_faceoff_conversion_rate'], 'raw_rank': a['off_faceoff_conversion_rate_rank'], 'adjusted_rank': a['adjusted_off_faceoff_conversion_rate_rank']})
                a['rankings_dict'].append({'unit': 'faceoffs', 'tag': 'def_faceoff_conversion_rate', 'raw_val': a['def_faceoff_conversion_rate'], 'adjusted_val': a['adjusted_def_faceoff_conversion_rate'], 'raw_rank': a['def_faceoff_conversion_rate_rank'], 'adjusted_rank': a['adjusted_def_faceoff_conversion_rate_rank']})

        # Tag team seasons to team records
        for t in all_teams:
            tmp_seasons = [{'year': z['year'], 'games_played': z['games_played']} for z in all_team_seasons if z['adjusted_off_efficiency'] is not None and z['team_ID'] == t['ID']]
            t['n_seasons'] = len(tmp_seasons); t['min_year'] = None; t['max_year'] = None
            if t['n_seasons'] > 0:
                t['min_year'] = min([z['year'] for z in tmp_seasons])
                t['max_year'] = max([z['year'] for z in tmp_seasons])
                
        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_team_seasons".format(len(all_team_seasons)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_team_seasons".format(len(all_team_seasons)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_team_seasons'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_team_seasons))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        this_year_team_seasons = [z for z in all_team_seasons if z['year'] == specs['year']]
        
        
        last_year_team_seasons = [z for z in all_team_seasons if z['year'] == specs['last_year']]

        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'this_year_team_seasons'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(this_year_team_seasons))); f.close(); conn, cursor = reconnect_db(conn, cursor)
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'last_year_team_seasons'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(last_year_team_seasons))); f.close(); conn, cursor = reconnect_db(conn, cursor)

        tmp_start_ms = time.time()

        cursor.execute("SELECT ID, home_team, away_team, confirmed_home_team, confirmed_away_team, game_date, home_score, away_score, overtime, game_type, league, last_updated, elo_transfer, home_ID, IFNULL(only_box_score,0) only_box_score, away_ID, status, last_LRP_upload, pregame_home_wp, home_elo, away_elo, neutral_site from LaxRef_Games where league like 'NCAA%%' and IFNULL(game_type, '')='' and active=1 and zgame_year > 2015", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()

        
        all_games = zc.dict_query_results(cursor)
        tmp_object_elapsed = time.time() - tmp_start_ms; 
        if '--record-egress' in sys.argv: query_log = increment_queries(query_log, 'all_games', all_games)
        for a in all_games:
        
            #a['LRP_json_path'] = os.path.join(lr_fldr, "Logs", "LRPGameJSONs", a['league'].replace(" ", ""), "%d" % a['game_date'].year, "game%07d_LRP.json" % a['ID'])
            a['LRP_json_path'] = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GameData", 'game%07d_LRP.json' % (a['ID']))
            a['last_file_change'] = None if not os.path.isfile(a['LRP_json_path']) else int(os.path.getctime(a['LRP_json_path']))
            a['last_LRP_upload'] = None if a['last_LRP_upload'] is None else int(a['last_LRP_upload'])
            a['game_epoch'] = (a['game_date'] - datetime(1970,1, 1)).total_seconds()
            a['game_year'] = a['game_date'].year
            a['game_date_str'] = a['game_date'].strftime("%b %d, %Y")
            a['short_date_str'] = a['game_date'].strftime("%b %d").replace(" 0", " ")
            a['next_year'] = 1 if a['game_year'] == (specs['year'] + 1) else 0
            a['this_year'] = 1 if a['game_year'] == specs['year'] else 0
            a['last_year'] = 1 if a['game_year'] == specs['last_year'] else 0
            a['game_date_YYYYmmdd'] = a['game_date'].strftime("%Y%m%d")
            a['dashed_date'] = a['game_date'].strftime("%Y-%m-%d")
            a['year_month'] = a['game_date'].strftime("%Y-%m")
            a['timestamp'] = (a['game_date'] - datetime(1970, 1, 1)).total_seconds()
            a['date_mmdd'] = a['game_date'].strftime("%m/%d")
            a['date_mmmdd'] = a['game_date'].strftime("%b %d").replace(" 0", " ")
            a['date_mmddYYYY'] = a['game_date'].strftime("%m/%d/%Y").replace("/0","/")
            a['date_mmmddYYYY'] = a['game_date'].strftime("%b %d, %Y").replace(" 0", " ")
            a['date_YYYYmmdd'] = a['game_date'].strftime("%Y%m%d")
            a['last_updated'] = None

        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_games".format(len(all_games)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_games".format(len(all_games)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'all_games'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(all_games))); f.close(); conn, cursor = reconnect_db(conn, cursor)


        leagues = list(set([z['league'] for z in all_games]))
        possession_lists = {}
        for l in leagues:
            possession_lists[l] = {}
            #print "League: %s" % l
            league_possessions = [z for z in all_possessions if 'league' not in z or z['league'] == l]
            for y in range(2010, 2050):
                
                tmp = [z for z in league_possessions if z['year'] == y]
                if len(tmp) > 0:
                    possession_lists[l][y] = [{'started_with': z['started_with'], 'team_odds': z['team_odds'], 'ID': z['ID'], 'num_shots': z['num_shots'], 'turnover': z['turnover'], 'shots_on_goal': z['shots_on_goal'], 'start_time': z['start_time'], 'game_ID': z['game_ID'], 'duration': z['duration'], 'adj_duration': z['adj_duration'], 'quarter': z['quarter'], 'adj_before_shot': z['adj_before_shot'], 'team_ID': z['team_ID'], 'opp_ID': z['opp_ID'], 'goal': z['goal']} for z in tmp]

                    #print "  {:<9}{:<15}{:<20,}".format(y, l, len(possession_lists[l][y]))
        all_possessions = None
        print ("{:<40} @ {}".format ("  Created league/yr poss lists", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #if '--store-db-queries' in sys.argv: f = open(os.path.join(lr_fldr, "Logs", "SavedDBQueries", 'possession_lists'), 'w'); f.write(json.dumps(zc.remove_dates_from_obj(possession_lists))); f.close(); conn, cursor = reconnect_db(conn, cursor)
    
    if '--record-egress' in sys.argv: report_egress_data(query_log, 'build_team_stats_LRP')
    
    build_stats_timestamps.append({'tag': 'DB Queries', 'timestamps': [{'end': time.time(), 'start': cur_ms}]}); cur_ms = time.time()


    tmp_team_IDs = [{'team_ID': y} for y in filter(None, list(set([z['home_ID'] for z in all_games] + [z['away_ID'] for z in all_games])))]
    primary_fogos_by_team = {}
    for tmp_team in tmp_team_IDs:
        team_players = [z for z in all_players if z['team_ID'] == tmp_team['team_ID']]
        primary_fogo_ID = None
        if 1 in [z['is_primary_fogo'] for z in team_players]:
            primary_fogo_ID = team_players[ [z['is_primary_fogo'] for z in team_players].index(1) ]['player_ID']
        
        # In the WLAX faceoffs process, we need to know whether the draw was won by the primary draw taker for one of the teams; that means we need an accessible dict to identify whether that is true in little code
        primary_fogos_by_team[tmp_team['team_ID']] = primary_fogo_ID
        

    team_IDs = get_team_IDs_for_processing({'LR': 0, 'LRP': 1, 'cursor': cursor, 'all_games': all_games})
    #zc.send_telegram(msg, bot_token)

    # Remove teams that do not have a record in the season in question or the prior year (i.e. for teams that have joined the league since the year in question)
    team_IDs = [y for y in team_IDs if y['team_ID'] in [z['team_ID'] for z in this_year_team_seasons] or y['team_ID'] in [z['team_ID'] for z in last_year_team_seasons]]
    msg = "{:<40} @ {}".format ("Begin processing %d teams" % len(team_IDs), datetime.now().strftime("%I:%M:%S %p"))
    print (msg)
    
    # Because some data (i.e. fogo data) is used by other functions (i.e. creating the next game scouting report), we need to create it here before the functions that might pick up this data are run
    
    # Calculate the league averages for the pacing profile information
    if 1 or '--test-pacing-profile-refactor' in sys.argv:
        specs = calculate_league_average_pacing_profile(possession_lists[sys.argv[sys.argv.index('-league') + 1]], specs)
    
    
    print ("{:<40} @ {}".format ("  Pre-processing rosters/faceoffs for %d teams" % len(team_IDs), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
    for ij, team in enumerate(team_IDs):
        team_rec = all_teams[ [z['ID'] for z in all_teams].index(team['team_ID']) ]
        tmp = [z for z in last_year_team_seasons if z['team_ID'] == team['team_ID']]
        
        team_rec['last_season'] = None if len(tmp) == 0 else tmp[0]
        
        tmp = [z for z in this_year_team_seasons if z['team_ID'] == team['team_ID']]
        team_rec['this_season'] = None if len(tmp) == 0 else tmp[0]
        
        #team_rec['all_statistics'] = all_statistics
        
        if '-league' in sys.argv and sys.argv[sys.argv.index("-league") + 1] != team_rec['league']:
            continue
            
        team_players = [z for z in all_players if z['team_ID'] == team_rec['ID']]
        all_league_players = [z for z in all_players if z['league'] == team_rec['league']]
        team_rec = build_roster(team_rec, team_players, all_league_players, specs)
        #print ("{:<40} @ {}".format ("  completed build_roster", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_roster", build_stats_timestamps, cur_ms)
            
        team_rec = build_stats_faceoffs(fogos, team_players, all_faceoffs, team_rec, primary_fogos_by_team, specs)
        #print ("{:<40} @ {}".format ("  completed build_stats_faceoffs", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_stats_faceoffs", build_stats_timestamps, cur_ms)
        
    n_teams_to_process = 0
    for ij, team in enumerate(team_IDs):
        misc = {}
       

        team_rec = all_teams[ [z['ID'] for z in all_teams].index(team['team_ID']) ]
        
        if '-league' in sys.argv and sys.argv[sys.argv.index("-league") + 1] != team_rec['league']:
            continue
        else:
            n_teams_to_process += 1
        
           
    n_teams_processed = 0    
    for ij, team in enumerate(team_IDs):
        misc = {}
       

        team_rec = all_teams[ [z['ID'] for z in all_teams].index(team['team_ID']) ]
        
        if '-league' in sys.argv and sys.argv[sys.argv.index("-league") + 1] != team_rec['league']:
            continue
            
        # If a team is not active in the current season, we can skip processing for that team; the team must still be in the source data so that processing prior year games can happen
        elif team['team_ID'] not in [z['team_ID'] for z in this_year_team_seasons]:
            print ("No %d record for %s" % (specs['year'], team_rec['display_name']))
            continue
            
        print ("{:<70} @ {}".format (" start %s (ID=%d; %s; %d): %d/%d" % (team_rec['display_name'], team_rec['ID'], team_rec['league'], specs['year'], n_teams_processed+1, n_teams_to_process), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        n_teams_processed += 1

        if 0 and team_rec['this_season'] is not None:

            team_rec['this_season']['off_possessions'] = sum([z['possessions'] for z in all_summaries if z['this_year'] and z['filter'] is None and z['data_type'] == "offense" and z['team_ID'] == team_rec['ID']])
            team_rec['this_season']['def_possessions'] = sum([z['possessions'] for z in all_summaries if z['this_year'] and z['filter'] is None and z['data_type'] == "defense" and z['team_ID'] == team_rec['ID']])

        misc['display_name'] = team_rec['display_name']
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Grab team_rec demographics", build_stats_timestamps, cur_ms)
        
        misc = build_misc_keys(misc, team_rec['league'], specs)
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Build Misc keys", build_stats_timestamps, cur_ms)

        my_games = [z for z in all_games if team_rec['ID'] in [z['home_ID'], z['away_ID']]]
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Get my games", build_stats_timestamps, cur_ms)

        misc['games'] = sorted(my_games, key=lambda x:x['game_epoch'], reverse=True)
        summaries = [z for z in all_summaries if team_rec['ID'] in [z['team_ID'],  z['opp_team_ID']]]
        team_season = this_year_team_seasons[ [z['team_ID'] for z in this_year_team_seasons].index(team['team_ID']) ]
        league_seasons = [z for z in this_year_team_seasons if z['league'] == team_rec['league']]
        all_team_game_stat_adjustments = [z for z in game_stat_adjustments if z['team_ID'] == team_rec['ID']]
        print ("{:<40} @ {}".format ("  locate team-specific DBdata", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Join to other data tables", build_stats_timestamps, cur_ms)
        
        # To cut down on lookup times, split these lists into sub-lists that are indexed on a modulus of the game_ID
        team_game_stat_adjustments = []
        for i in range(mod_val):
            team_game_stat_adjustments.append([z for z in all_team_game_stat_adjustments if int(z['game_ID'] % mod_val) == i])

        #print ("    n summaries: {:,.0f}".format(len(summaries)))
        #print ("    n team_game_stat_adjustments: {:,.0f}".format(len(all_team_game_stat_adjustments)))
        
        for a in summaries:
            game_mod = int(a['game_ID'] % mod_val)
            a['my_team'] = 1 if a['team_ID'] == team_rec['ID'] else 0 
            a['saved_shots'] = a['sog'] - a['goals']
            a['game_stat_adjustments'] = [z for z in team_game_stat_adjustments[game_mod] if z['game_ID'] == a['game_ID'] and z['offense'] == (a['data_type'] == "offense")]
            
            a['opp_efficiency_adjustment'] = None
            tmp = [z for z in efficiency_game_adjustments[game_mod] if z['game_ID'] == a['game_ID'] and z['team_ID'] == team_rec['ID'] and (not z['offense']) == (a['data_type'] == "offense")]
            if len(tmp) > 0:
                a['opp_efficiency_adjustment'] = tmp[0]['adjustment']
        print ("{:<40} @ {}".format ("  aggregate team game_stat_adjustments", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Agg Team game_stat_adjustments", build_stats_timestamps, cur_ms)
        
        team_rec = build_player_outcome_splits(player_groupings, all_statistics, player_game_summaries, summaries, all_players, last_year_players, team_rec, specs)
        print ("{:<40} @ {}".format ("  completed build_player_outcome_splits", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_player_outcome_splits", build_stats_timestamps, cur_ms)

        team_rec = build_team_outcome_splits(player_groupings, all_statistics, player_game_summaries, summaries, all_players, last_year_players, team_rec, specs)
        print ("{:<40} @ {}".format ("  completed build_team_outcome_splits", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_team_outcome_splits", build_stats_timestamps, cur_ms)

        team_rec['record'] = team_season['record']
        if '--team-record' in sys.argv:
            print(team_rec['record'])
            zc.exit("TS R")
        team_rec['league_record'] = team_season['league_record']
        team_rec['ss_date_timestamp'] = (seasons[ [(z['league'], z['year']) for z in seasons].index((team_rec['league'], specs['year']))]['selection_sunday'] - datetime(1970, 1, 1)).total_seconds()
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Grab additional team_rec fields", build_stats_timestamps, cur_ms)

        team_rec = build_stats_goalies(goalies, team_rec, specs)
        print ("{:<40} @ {}".format ("  completed build_stats_goalies", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_stats_goalies", build_stats_timestamps, cur_ms)

        team_rec = build_sim_results(misc, team_rec, sim_results, specs)
        print ("{:<40} @ {}".format ("  completed sim_results", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("sim_results", build_stats_timestamps, cur_ms)

        team_rec = build_RPI_factors(team_rec, this_year_team_seasons, team_season, conferences, specs)
        print ("{:<40} @ {}".format ("  completed build_RPI_factors", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_RPI_factors", build_stats_timestamps, cur_ms)

        team_rec = build_shooting_profiles(team_rec, specs)
        print ("{:<40} @ {}".format ("  completed shooting profile", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("shooting profile", build_stats_timestamps, cur_ms)

        team_rec["offensive_pace_profile"] = build_pacing_profile(team_rec['ID'], possession_lists[team_rec['league']], 'offense', specs)
        team_rec["defensive_pace_profile"] = build_pacing_profile(team_rec['ID'], possession_lists[team_rec['league']], 'defense', specs)
        print ("{:<40} @ {}".format ("  completed pacing profile", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("pacing profile", build_stats_timestamps, cur_ms)

        team_rec = build_team_conference_data(team_rec, conferences, specs)
        print ("{:<40} @ {}".format ("  completed conference info", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("completed conference info", build_stats_timestamps, cur_ms)

        team_rec = build_team_ranks(misc, team_rec, team_season, league_seasons, specs)
        print ("{:<40} @ {}".format ("  completed build_team_ranks", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_team_ranks", build_stats_timestamps, cur_ms)

        team_rec = build_team_ranks_new(misc, team_rec, team_season, league_seasons, all_statistics, specs)
        print ("{:<40} @ {}".format ("  completed build_team_ranks_new", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_team_ranks_new", build_stats_timestamps, cur_ms)

        misc, team_rec = build_games_list(misc, team_rec, possession_lists, player_game_summaries_by_game, game_stat_adjustments, all_statistics, summaries, all_summaries_by_team, all_teams, this_year_team_seasons, last_year_team_seasons, fogos, mod_val, specs)
        print ("{:<40} @ {}".format ("  completed build_games_list", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_games_list", build_stats_timestamps, cur_ms)


        scheduled = [z for z in misc['games'] if z['status'] in ["scheduled"]]
        this_year_games = [z for z in misc['games'] if z['this_year']]
        next_year_games = [z for z in misc['games'] if z['next_year']]
        games_played_this_year = len([1 for z in misc['games'] if z['this_year'] and "complete" in z['status']])
        team_rec = build_stats_future_games(scheduled, this_year_games, next_year_games, games_played_this_year, team_rec, possession_lists, all_games, all_teams, specs)
        print ("{:<40} @ {}".format ("  completed build_stats_future_games", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_stats_future_games", build_stats_timestamps, cur_ms)

        team_rec = build_next_game_team_summaries(team_rec, specs)
        print ("{:<40} @ {}".format ("  completed build_next_game_team_summaries", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_next_game_team_summaries", build_stats_timestamps, cur_ms)

        team_rec['matchup_history'] = build_matchup_history(team_rec, all_games, game_stat_adjustments, summaries, specs)
        print ("{:<40} @ {}".format ("  completed build_matchup_history", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Build Matchup History", build_stats_timestamps, cur_ms)

        team_rec = build_league_averages(team_rec, summaries, all_summaries, specs)
        print ("{:<40} @ {}".format ("  completed calculating league averages", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Calc league averages", build_stats_timestamps, cur_ms)

        #misc = build_LR_games_panel_view(misc, all_teams, all_game_streams, specs)
        #print ("{:<40} @ {}".format ("  completed build_LR_games_panel_view", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        #build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_LR_games_panel_view", build_stats_timestamps, cur_ms)

        team_rec = build_future_games(team_rec, misc, specs)
        print ("{:<40} @ {}".format ("  completed build_future_games", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Build Future Games", build_stats_timestamps, cur_ms)

        team_rec = build_laxelo_history(team_rec, misc, specs)
        print ("{:<40} @ {}".format ("  completed LaxELO History", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("LaxELO History", build_stats_timestamps, cur_ms)

        
        src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GeneralData", "LeagueAverages_%d_%s.json" % (specs['year'], team_rec['league'].replace(" ", "")))
        if datetime.now().month < 3 and not os.path.isfile(src):
            src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GeneralData", "LeagueAverages_%d_%s.json" % (specs['last_year'], team_rec['league'].replace(" ", "")))
        
        team_rec['league_averages'] = None
        if os.path.isfile(src):
            team_rec['league_averages'] = json.loads(open(src, 'r').read())
        
        misc['team_rec'] = team_rec
        all_misc.append(misc)
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Append to all_misc", build_stats_timestamps, cur_ms)

        #print "%s Misc\n----------------------------------------------------" % team_rec['display_name']
        #zc.profile_dict(misc, {})


    cursor.close(); conn.close()

    
    print ("{:<40} @ {}".format ("  Stripping out data", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
    for ij, team in enumerate(team_IDs):
        # Clean-Up stuff
        
        team_rec = all_teams[ [z['ID'] for z in all_teams].index(team['team_ID']) ]
        team_rec = strip_away_new(team_rec, specs)
        build_stats_timestamps, cur_ms = record_step_timestamp_completion("Strip out unnecessaries", build_stats_timestamps, cur_ms)

    end_ms = time.time()
    print ("{:<40} @ {}".format ("Completed laxref.build_team_stats in %.1f mins" % ((end_ms - start_ms)/60.), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

    return all_misc, build_stats_timestamps

def get_team_IDs_for_processing(specs):
    team_IDs = [{'team_ID': y} for y in filter(None, list(set([z['home_ID'] for z in specs['all_games']] + [z['away_ID'] for z in specs['all_games']])))]
    if '-t' in sys.argv:
        team_IDs = [{'team_ID': int(z.strip()), 'new_games': 1} for z in sys.argv[sys.argv.index('-t') + 1].split("|") if z.strip() != ""]
    elif '--team-ID' in sys.argv:
        team_IDs = [{'team_ID': int(z.strip()), 'new_games': 1} for z in sys.argv[sys.argv.index('--team-ID') + 1].split("|") if z.strip() != ""]
    else:
        # Check to confirm that something has changed that would warrant and update to each team (i.e. they have played a new game)
        if specs['LR']:
            last_run_log_path = os.path.join(lr_fldr, 'Logs', 'LR_update_team_log.json')
        else:
            last_run_log_path = os.path.join(lr_fldr, 'Logs', 'LRP_update_team_log.json')


        
        specs['cursor'].execute("SELECT team_ID, sum(CASE WHEN b.status like '%%NCAA%%' THEN 1 else 0 END) ncaaGames, sum(CASE WHEN b.status like '%%veS%%' THEN 1 else 0 END) liveStatsGames from LaxRef_Team_Game_Summaries a, LaxRef_Games b where a.game_ID=b.ID and b.active and a.active and ISNULL(filter) and data_type='offense' group by team_ID",  [])
        db_last_run_log = zc.dict_query_results(specs['cursor'])
        for rec in db_last_run_log:
            rec['ncaaGames'] = int(rec['ncaaGames']); rec['liveStatsGames'] = int(rec['liveStatsGames'])
        if '--run-all-teams' in sys.argv or not os.path.isfile(last_run_log_path):
            for t in team_IDs:
                t['new_games'] = 1
        else:
            last_run_log = None
            try:
                last_run_log = json.loads(open(last_run_log_path, 'r').read())

            except Exception:
                msg = "LR_update_team_log.json was corrupted, we will execute all teams."
                print (msg); zc.send_telegram(msg, bot_token)




            if last_run_log is None:
                for t in team_IDs:
                    t['new_games'] = 1
            else:
            
                
                # Check whether any teams have more games played than they did the last time they were updated; if they do, they'll be flagged for an update   
                for comp in team_IDs:
                    comp['same_number_of_games'] = 1
                    #print ("\n"), comp['team_ID'], comp['team_ID'] in [z['team_ID'] for z in db_last_run_log], comp['team_ID'] in [z['team_ID'] for z in last_run_log],comp['team_ID'] in [z['team_ID'] for z in db_last_run_log] and comp['team_ID'] in [z['team_ID'] for z in last_run_log]
                    if comp['team_ID'] in [z['team_ID'] for z in db_last_run_log] and comp['team_ID'] in [z['team_ID'] for z in last_run_log]:
                        db_rec = db_last_run_log[ [z['team_ID'] for z in db_last_run_log].index(comp['team_ID']) ]
                        log_rec = last_run_log[ [z['team_ID'] for z in last_run_log].index(comp['team_ID']) ]
                        #print comp['team_ID'], db_rec['games_played'], log_rec['games_played'], db_rec['games_played'] == log_rec['games_played']
                        comp['same_number_of_NCAA_games'] = 1 if db_rec['ncaaGames'] == log_rec['ncaaGames'] else 0
                        comp['same_number_of_liveStats_games'] = 1 if db_rec['liveStatsGames'] == log_rec['liveStatsGames'] else 0
                        comp['same_number_of_games'] = comp['same_number_of_NCAA_games'] and comp['same_number_of_liveStats_games']
                        
                # We also need to update teams that are playing teams next who need to be updated (i.e. to the next game scout is fresh)
                for t in team_IDs:
                    t['next_opp_ID'] = None; t['next_opp_ID_same_number_of_games'] = 1
                    team_future_games = sorted([z for z in specs['all_games'] if (z['home_ID'] == t['team_ID'] or z['away_ID'] == t['team_ID']) and z['status'] == "scheduled"], key=lambda x:x['game_epoch'])
                    if len(team_future_games) > 0:
                        tmp = team_future_games[0]
                        t['next_opp_ID'] = tmp['home_ID'] if tmp['away_ID'] == t['team_ID'] else tmp['away_ID']
                        t['next_opp_ID_same_number_of_games'] = team_IDs[ [z['team_ID'] for z in team_IDs].index(t['next_opp_ID']) ]['same_number_of_games']
                
                if specs['LR']:
                    team_IDs = [z for z in team_IDs if '--update-all' in sys.argv or not z['same_number_of_games']]
                else:
                    for t in team_IDs:
                        t['new_games'] = 1 if not t['same_number_of_games'] else 0
                    team_IDs = [z for z in team_IDs if '--update-all' in sys.argv or not z['same_number_of_games'] or not z['next_opp_ID_same_number_of_games']]
                     
                
       
        #f = open(last_run_log_path, 'w'); f.write(json.dumps(db_last_run_log)); f.close()
    return team_IDs



def build_team_stats_LR(uyear, orig_team_ID=None):
        start_ms = time.time(); cur_ms = start_ms
        mod_val = 40

        specs = {'year': uyear, 'last_year': uyear-1, 'LR': 1, 'LRP': 0, 'missing_efficiency_errors': []}
        all_misc = []

        build_stats_timestamps = []
        
        print ("{:<40} @ {}".format ("Processing queries", datetime.now().strftime("%I:%M:%S.%f")[:-3]))

        conn, cursor = zc.mysql_connect("LR")
        tmp_start_ms = time.time()
        cursor.execute("SELECT * from LaxRef_Games where IFNULL(game_type, '')='' and active=1 and zgame_year > 2015", [])
        tmp_query_elapsed = time.time() - tmp_start_ms; tmp_start_ms = time.time()
        all_games = zc.dict_query_results(cursor)
        for a in all_games:
            #a['LRP_json_path'] = os.path.join(lr_fldr, "Logs", "LRPGameJSONs", a['league'].replace(" ", ""), "%d" % a['game_date'].year, "game%07d_LRP.json" % a['ID'])
            a['LRP_json_path'] = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GameData", 'game%07d_LRP.json' % (a['ID']))
            a['last_file_change'] = None if not os.path.isfile(a['LRP_json_path']) else int(os.path.getctime(a['LRP_json_path']))
            a['last_LRP_upload'] = None if a['last_LRP_upload'] is None else int(a['last_LRP_upload'])
            a['game_epoch'] = (a['game_date'] - datetime(1970,1, 1)).total_seconds()
            a['game_year'] = a['game_date'].year
            a['game_date_str'] = a['game_date'].strftime("%b %d, %Y")
            a['short_date_str'] = a['game_date'].strftime("%b %d").replace(" 0", " ")
            a['next_year'] = 1 if a['game_year'] == specs['year'] + 1 else 0
            a['this_year'] = 1 if a['game_year'] == specs['year'] else 0
            a['last_year'] = 1 if a['game_year'] == specs['last_year'] else 0
            a['game_date_YYYYmmdd'] = a['game_date'].strftime("%Y%m%d")
            a['dashed_date'] = a['game_date'].strftime("%Y-%m-%d")
            a['year_month'] = a['game_date'].strftime("%Y-%m")
            a['timestamp'] = (a['game_date'] - datetime(1970, 1, 1)).total_seconds()
            a['date_mmdd'] = a['game_date'].strftime("%m/%d")
            a['date_mmmdd'] = a['game_date'].strftime("%b %d").replace(" 0", " ")
            a['date_mmddYYYY'] = a['game_date'].strftime("%m/%d/%Y").replace("/0","/")
            a['date_mmmddYYYY'] = a['game_date'].strftime("%b %d, %Y").replace(" 0", " ")
            a['date_YYYYmmdd'] = a['game_date'].strftime("%Y%m%d")
            a['last_updated'] = None

        #REMOVEprint ("{:<40} @ {}".format ("  Pulled {:,} all_games".format(len(all_games)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        tmp_object_elapsed = time.time() - tmp_start_ms
        print ("{:<40} {:<30} @ {}".format ("  Pulled {:,} all_games".format(len(all_games)), "Query: {:.2f}s; Obj: {:.2f}s".format(tmp_query_elapsed, tmp_object_elapsed), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
        
        team_IDs = get_team_IDs_for_processing({'LR': 1, 'LRP': 0, 'cursor': cursor, 'all_games': all_games})
        print ("{:<40} @ {}".format ("Begin processing %d teams" % len(team_IDs), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

        if len(team_IDs) > 0:



            cursor.execute("SELECT * from LaxRef_Seasons", [])
            seasons = zc.dict_query_results(cursor)
            print ("{:<40} @ {}".format ("  Pulled {:,} seasons".format(len(seasons)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            
            
            cursor.execute("SELECT a.ID, a.display_name, a.pro_url_tag, b.league, a.short_code, b.partial_member, b.conference_ID from LaxRef_Teams a LEFT JOIN LaxRef_Team_Seasons b ON a.ID=b.team_ID and b.year=%s where a.active", [specs['year']])
            all_teams = zc.dict_query_results(cursor)
            print ("{:<40} @ {}".format ("  Pulled {:,} all_teams".format(len(all_teams)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            

            cursor.execute("SELECT a.ID, a.player_ID, a.game_ID, a.position, a.active, a.EGA, a.faceoff_EGA, a.offensive_EGA, a.defensive_EGA, a.team_ID, a.shots, a.goals, a.sog, a.assists, a.turnovers, a.gbs, a.penalties, a.penalty_minutes, a.faceoff_wins, a.faceoffs_taken, a.caused_turnovers, a.game_year, a.shots_faced, a.sog_faced, a.sog_rate_faced, a.save_pct, a.plays_recorded, a.team_play_shares, a.weighted_play_share, a.saves, a.on_keeper_faced, a.opp_team_ID, a.devittes, a.assisted_goals, a.usage_adjusted_EGA, a.shooting_pct, a.turnover_rate, a.faceoff_win_rate, a.points, a.pct_of_shots, a.sog_rate, a.team_custom_usage_adjusted_EGA, a.missed_assists, a.drawn_penalties, a.composite_EGA, a.faceoff_wins_vs_primary, a.faceoffs_taken_vs_primary, a.fp_shots, a.fp_goals, a.fp_shooting_pct, a.from_box_score from LaxRef_Player_Game_Summaries a, LaxRef_Games b where b.zgame_year=%s and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active=1", [specs['year']])
            remove_player_game_summaries = zc.dict_query_results(cursor)
            print ("{:<40} @ {}".format ("  [REMOVE] Pulled {:,} player_game_summaries".format(len(remove_player_game_summaries)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            

            cursor.execute("SELECT a.ID, a.game_file, a.game_ID, b.game_date, a.confirmed_away_team, a.confirmed_home_team, a.home_ID, a.away_ID, a.post_ID from LaxRef_Game_Streams a, LaxRef_Games b where b.ID=a.game_ID and a.active and b.active", [])
            all_game_streams = zc.dict_query_results(cursor)
            for a in all_game_streams:
                a['sorted_IDs'] = None
                if None not in [a['away_ID'], a['home_ID']]:
                    a['sorted_IDs'] = "%s|%d|%d" % (a['game_date'].strftime("%Y%m%d"), min(a['away_ID'], a['home_ID']), max(a['away_ID'], a['home_ID']))
            print ("{:<40} @ {}".format ("  Pulled {:,} all_game_streams".format(len(all_game_streams)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            
    
            if '-league' in sys.argv:
                cursor.execute("SELECT a.game_ID, a.team_ID, a.opp_team_ID, a.goals, a.possessions, a.sub_30_poss, a.30_60_poss, a.60_plus_poss, a.sub_30_poss_goals, a.30_60_poss_goals, a.60_plus_poss_goals, a.shots, a.sog, a.efficiency, a.save_pct, a.shooting_pct, a.sog_rate, a.faceoff_wins, a.faceoff_losses, a.faceoff_win_rate, a.shooting_EGA, a.forced_turnovers, a.unforced_turnovers, a.turnover_rate, a.gbs_won, a.gbs_lost, a.gb_win_rate, a.time_of_possession, a.good_clears, a.avg_possession_length, a.time_to_first_shot, a.shots_per_possession, a.number_of_contributors, a.weird_time_as_pct, a.data_type, a.saves, a.turnovers, a.poss_w_shot, a.modified_possession_margin, a.possession_margin, a.date_added, a.multiple_shot_possessions, a.multiple_shot_possession_rate, a.possessions_plus_failed_clears, a.failed_clears, a.assists, a.assist_rate, a.game_date, a.win, a.penalties, a.adjusted_efficiency, a.man_up_goals, a.man_up_chances, a.shooting_efficiency, a.man_down_goals, a.filter, a.filter_val, a.expected_shooting_pct, a.shots_saved, a.sog_faced, a.on_keeper_shots, a.on_keeper_shots_faced, a.expected_goals, a.excess_goals, a.clear_rate, a.ride_rate, a.emo_efficiency, a.LTM_adjusted_off_efficiency_stdev, a.adjusted_shots_per_possession, a.adjusted_efficiency, a.adjusted_assist_rate, a.adjusted_time_of_possession, a.adjusted_turnover_rate, a.adjusted_clear_rate, a.adjusted_ride_rate, a.adjusted_emo_efficiency, a.adjusted_faceoff_conversion_rate, a.adjusted_faceoff_win_rate, a.adjusted_shooting_pct, a.adjusted_shooting_efficiency, a.adjusted_on_goal_shooting_pct, a.adjusted_sog_rate, a.adjusted_gb_win_rate, a.adjusted_save_pct, a.adjusted_modified_possession_margin, a.LTM_adjusted_def_efficiency_stdev, a.faceoff_conversions, a.faceoff_conversion_rate, a.fp_efficiency, a.fp_utilization, a.fp_shooting_pct, a.fp_shooter_pct, a.fp_attempts, a.fp_goals, a.fp_shots, a.fp_shots_off_one_pass, YEAR(a.game_date) 'game_year', b.league from LaxRef_Team_Game_Summaries a, LaxRef_Games b where IFNULL(game_type,'')='' and ISNULL(filter) and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active and b.active and b.league=%s", [sys.argv[sys.argv.index('-league') + 1]])
            
            else:
                cursor.execute("SELECT a.game_ID, a.team_ID, a.opp_team_ID, a.goals, a.possessions, a.sub_30_poss, a.30_60_poss, a.60_plus_poss, a.sub_30_poss_goals, a.30_60_poss_goals, a.60_plus_poss_goals, a.shots, a.sog, a.efficiency, a.save_pct, a.shooting_pct, a.sog_rate, a.faceoff_wins, a.faceoff_losses, a.faceoff_win_rate, a.shooting_EGA, a.forced_turnovers, a.unforced_turnovers, a.turnover_rate, a.gbs_won, a.gbs_lost, a.gb_win_rate, a.time_of_possession, a.good_clears, a.avg_possession_length, a.time_to_first_shot, a.shots_per_possession, a.number_of_contributors, a.weird_time_as_pct, a.data_type, a.saves, a.turnovers, a.poss_w_shot, a.modified_possession_margin, a.possession_margin, a.date_added, a.multiple_shot_possessions, a.multiple_shot_possession_rate, a.possessions_plus_failed_clears, a.failed_clears, a.assists, a.assist_rate, a.game_date, a.win, a.penalties, a.adjusted_efficiency, a.man_up_goals, a.man_up_chances, a.shooting_efficiency, a.man_down_goals, a.filter, a.filter_val, a.expected_shooting_pct, a.shots_saved, a.sog_faced, a.on_keeper_shots, a.on_keeper_shots_faced, a.expected_goals, a.excess_goals, a.clear_rate, a.ride_rate, a.emo_efficiency, a.LTM_adjusted_off_efficiency_stdev, a.adjusted_shots_per_possession, a.adjusted_efficiency, a.adjusted_assist_rate, a.adjusted_time_of_possession, a.adjusted_turnover_rate, a.adjusted_clear_rate, a.adjusted_ride_rate, a.adjusted_emo_efficiency, a.adjusted_faceoff_conversion_rate, a.adjusted_faceoff_win_rate, a.adjusted_shooting_pct, a.adjusted_shooting_efficiency, a.adjusted_on_goal_shooting_pct, a.adjusted_sog_rate, a.adjusted_gb_win_rate, a.adjusted_save_pct, a.adjusted_modified_possession_margin, a.LTM_adjusted_def_efficiency_stdev, a.faceoff_conversions, a.faceoff_conversion_rate, a.fp_efficiency, a.fp_utilization, a.fp_shooting_pct, a.fp_shooter_pct, a.fp_attempts, a.fp_goals, a.fp_shots, a.fp_shots_off_one_pass, YEAR(a.game_date) 'game_year', b.league from LaxRef_Team_Game_Summaries a, LaxRef_Games b where IFNULL(game_type,'')='' and ISNULL(filter) and IFNULL(b.simulation,0)=0 and a.game_ID=b.ID and a.active and b.active", [])
            all_summaries = zc.dict_query_results(cursor)
            for a in all_summaries:
                a['this_year'] = 1 if a['game_date'].year == specs['year'] else 0
                a['next_year'] = 1 if a['game_date'].year == specs['year'] + 1 else 0
                a['game_year'] = a['game_date'].year
                a['game_epoch'] = (a['game_date'] - datetime(1970, 1, 1)).total_seconds()


                a['game_month'] = a['game_date'].month
                #a['date_added'] = None
                #a['game_date'] = None
            all_summaries_by_team = []
            for i in range(mod_val):
                all_summaries_by_team.append([z for z in all_summaries if int(z['team_ID'] % mod_val) == i])

            print ("{:<40} @ {}".format ("  Pulled {:,} all_summaries".format(len(all_summaries)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

            cursor.execute("SELECT a.*, c.short_code 'conf_short_code', c.independent from LaxRef_Team_Seasons a, LaxRef_Conferences c where c.ID = a.conference_ID and a.active=1", [])
            all_team_seasons = zc.dict_query_results(cursor)
            for a in all_team_seasons:
                a['def_efficiency_inverted'] = None if a['def_efficiency'] is None else 1. - a['def_efficiency']
                a['rankings_dict'] = None
                if a['adjusted_off_efficiency_rank'] is None:
                    a['rankings_summary_str'] = ""
                    a['rankings_summary_str_mob'] = ""
                else:
                    tmp = ["Off: %d%s" % (a['adjusted_off_efficiency_rank'], zc.get_number_suffix(a['adjusted_off_efficiency_rank']))
                           , "Def: %d%s" % (a['adjusted_def_efficiency_rank'], zc.get_number_suffix(a['adjusted_def_efficiency_rank']))
                           , "FO: %d%s" % (a['adjusted_faceoff_win_rate_rank'], zc.get_number_suffix(a['adjusted_faceoff_win_rate_rank']))
                           , "GK: %d%s" % (a['adjusted_def_save_pct_rank'], zc.get_number_suffix(a['adjusted_def_save_pct_rank']))]
                    a['rankings_summary_str'] = " / ".join(tmp)
                    a['rankings_summary_str_mob'] = " / ".join(tmp[0:2])
                    a['rankings_dict'] = []
                    a['rankings_dict'].append({'unit': 'offense', 'rank': a['adjusted_off_efficiency_rank'], 'rank_str': "%d%s" % (a['adjusted_off_efficiency_rank'], zc.get_number_suffix(a['adjusted_off_efficiency_rank']))})
                    a['rankings_dict'].append({'unit': 'defense', 'rank': a['adjusted_def_efficiency_rank'], 'rank_str': "%d%s" % (a['adjusted_def_efficiency_rank'], zc.get_number_suffix(a['adjusted_def_efficiency_rank']))})
                    a['rankings_dict'].append({'unit': 'faceoffs', 'rank': a['adjusted_faceoff_win_rate_rank'], 'rank_str': "%d%s" % (a['adjusted_faceoff_win_rate_rank'], zc.get_number_suffix(a['adjusted_faceoff_win_rate_rank']))})
                    a['rankings_dict'].append({'unit': 'goalkeepers', 'rank': a['adjusted_def_save_pct_rank'], 'rank_str': "%d%s" % (a['adjusted_def_save_pct_rank'], zc.get_number_suffix(a['adjusted_def_save_pct_rank']))})

            print ("{:<40} @ {}".format ("  Pulled {:,} all_team_seasons".format(len(all_team_seasons)), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

            this_year_team_seasons = [z for z in all_team_seasons if z['year'] == specs['year']]
            last_year_team_seasons = [z for z in all_team_seasons if z['year'] == specs['last_year']]

            

            leagues = list(set([z['league'] for z in all_games]))
            possession_lists = None
                
        build_stats_timestamps.append({'tag': 'DB Queries', 'timestamps': [{'end': time.time(), 'start': cur_ms}]}); cur_ms = time.time()



        # Remove teams that do not have a record in the season in question (i.e. for teams that have joined the league since the year in question)
        team_IDs = [y for y in team_IDs if y['team_ID'] in [z['team_ID'] for z in this_year_team_seasons]]
        
        
        n_teams_to_process = 0
        for ij, team in enumerate(team_IDs):
            misc = {}
           

            team_rec = all_teams[ [z['ID'] for z in all_teams].index(team['team_ID']) ]
            
            if '-league' in sys.argv and sys.argv[sys.argv.index("-league") + 1] != team_rec['league']:
                continue
            else:
                n_teams_to_process += 1

        n_teams_processed = 0 
        for ij, team in enumerate(team_IDs):
            misc = {}
            

            team_rec = all_teams[ [z['ID'] for z in all_teams].index(team['team_ID']) ]
            if '-league' in sys.argv and sys.argv[sys.argv.index("-league") + 1] != team_rec['league']:
                continue
            print ("{:<70} @ {}".format (" start %s (ID=%d; %s; %d): %d/%d" % (team_rec['display_name'], team_rec['ID'], team_rec['league'], specs['year'], n_teams_processed+1, n_teams_to_process), datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            n_teams_processed += 1


            misc = build_misc_keys(misc, team_rec['league'], specs)
            build_stats_timestamps, cur_ms = record_step_timestamp_completion("Build Misc keys", build_stats_timestamps, cur_ms)

            my_games = [z for z in all_games if team_rec['ID'] in [z['home_ID'], z['away_ID']]]
            build_stats_timestamps, cur_ms = record_step_timestamp_completion("Get my games", build_stats_timestamps, cur_ms)

            misc['games'] = sorted(my_games, key=lambda x:x['game_epoch'], reverse=True)
            summaries = [z for z in all_summaries if team_rec['ID'] in [z['team_ID'],  z['opp_team_ID']]]
            print ("{:<40} @ {}".format ("  locate team-specific DBdata", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            build_stats_timestamps, cur_ms = record_step_timestamp_completion("Join to other data tables", build_stats_timestamps, cur_ms)

            misc, team_rec = build_games_list(misc, team_rec, None, None, None, None, summaries, all_summaries_by_team, all_teams, None, None, None, mod_val, specs)
            print ("{:<40} @ {}".format ("  completed build_games_list", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_games_list", build_stats_timestamps, cur_ms)

            misc = build_LR_games_panel_view(misc, all_teams, all_game_streams, specs)
            print ("{:<40} @ {}".format ("  completed build_LR_games_panel_view", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            build_stats_timestamps, cur_ms = record_step_timestamp_completion("build_LR_games_panel_view", build_stats_timestamps, cur_ms)

            team_rec, misc = strip_away(team_rec, misc, specs)
            print ("{:<40} @ {}".format ("  stripped out unnecessaries", datetime.now().strftime("%I:%M:%S.%f")[:-3]))
            build_stats_timestamps, cur_ms = record_step_timestamp_completion("Strip out unnecessaries", build_stats_timestamps, cur_ms)


            misc['team_rec'] = team_rec
            all_misc.append(misc)
            build_stats_timestamps, cur_ms = record_step_timestamp_completion("Append to all_misc", build_stats_timestamps, cur_ms)



        cursor.close(); conn.close()



        end_ms = time.time()
        print ("{:<40} @ {}".format ("Completed laxref.build_team_stats_LR in %.1f mins" % ((end_ms - start_ms)/60.), datetime.now().strftime("%I:%M:%S.%f")[:-3]))

        return all_misc, build_stats_timestamps



def schedules():


    mysql_conn, cursor = zc.mysql_connect("LR")
    cursor.execute("SELECT * from LaxRef_Teams where active=1")
    teams = zc.dict_query_results(cursor)
    cursor.close(); mysql_conn.close()

    for t in teams:
        t['games'] = []
        t['published_games'] = 0

    yr = datetime.now().year
    if datetime.now().month > 10:
        yr += 1


    res = {}
    files = os.listdir(os.path.join(lr_fldr, 'Logs', 'Schedules'))
    files = [z for z in files if 'team' in z]
    inferred_files = [z for z in files if "%d" % yr in z and "Inferred" in z]
    published_files = [z for z in files if "%d" % yr in z and "Inferred" not in z]
    files = published_files + inferred_files

    res['season_start'] = None
    res['season_end'] = None
    for f_,  f in enumerate(files):
        team_ID = int(f.split("_")[0][4:])
        inferred = 1 if "Inferred" in f else 0
        team = teams[ [z['ID'] for z in teams].index(team_ID)]

        rows = filter(None, open(os.path.join(lr_fldr, 'Logs', 'Schedules', f), 'r').read().replace("'", "").replace('"', "").split("\n"))
        rows = [z.split("|") for z in rows]
        games = [{'date_str': z[0], 'opponent': z[1], 'opponentID': int(z[2]), 'location': z[3], 'inferred': inferred } for z in rows]

        for g in games:
            g['date'] = datetime.strptime(g['date_str'], "%m/%d/%Y")
            if res['season_start'] is None or g['date'] < res['season_start']: res['season_start'] = g['date']
            if res['season_end'] is None or g['date'] > res['season_end']: res['season_end'] = g['date']
            tup = (g['date_str'], g['opponentID'])
            if tup not in [(z['date_str'], z['opponentID']) for z in team['games']]:
                team['games'].append(g)


    if res['season_end'] is not None :
        res['season_length'] = float((res['season_end'] - res['season_start']).total_seconds() / 3600. / 24.)
    else:
        res['season_length'] = 120.
        
    final_teams = []
    for t in teams:
        for g in t['games']:
            g['days_in'] = (g['date'] - res['season_start']).total_seconds() / 3600. / 24.
            g['x_loc'] = g['days_in'] / res['season_length']
            g['date'] = ""
            g['color'] = "#5FF" if g['inferred'] else "#5F5"

        t['published_games'] = len([1 for z in t['games'] if not z['inferred']])
        t['inferred_games'] = len([1 for z in t['games'] if z['inferred']])
        ft = {'name': t['name'].replace("'", ""), 'games': t['games'], 'inferred_games': t['inferred_games'], 'published_games': t['published_games']}
        final_teams.append(ft)

    res['teams'] = sorted(final_teams, key=lambda x:x['published_games'], reverse=True)


    return res
def create_team_viz_chart(settings):
    magick_path = os.path.join(piFolder, "ImageMagick", "magick.exe")
    windows = "C:" in piFolder
    mysql_conn, cursor = zc.mysql_connect("LR")
    team_colors = get_team_colors(cursor)
    cursor.close(); mysql_conn.close()

    if 'columns' not in settings:
        settings['columns'] = 2


    fg_color = team_colors[[t['Team'] for t in team_colors].index('Duke')]['fg_color']
    bg_color = team_colors[[t['Team'] for t in team_colors].index('Duke')]['bg_color']

    all_args = []
    games_printed = settings['count']

    top_margin = '0'
    team_font = '11'
    row_height = 25 if 'row_height' not in settings else settings['row_height']

    rank_offset = 0
    if '--rank-offset' in sys.argv: rank_offset += int(sys.argv[sys.argv.index("--rank-offset") + 1])

    desc_offset = 0
    if 'description' in settings:
        desc_png = os.path.join(piFolder, "Snaps", "description.png")
        args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-o', desc_png, '-cendter', '-notrim', '-topmargin', top_margin, '-text', settings['description'], '-font', 'Oswald', '-fontsize', team_font, '-fontcolor', '(40,40,40,255)', '-fillcolor', '(254,254,254,255)', '-y', "%s" % row_height, '-x', '436']
        proc = subprocess.Popen(args, stdout=subprocess.PIPE)
        print (args)
        time.sleep(5)
        output = proc.stdout.read()
        print (output)
        regex = re.compile(r'\|Offset\: (.*?)\|')
        match = regex.search(output)
        if match is not None:
            desc_offset = int(match.group(1))
            print("Desc offset: %d" % desc_offset)


    path = settings['path']
    # Create the base temp file
    args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-o', path, '-notrim', '-topmargin', top_margin, '-text', "", '-font', 'Oswald', '-fontsize', '18', '-fontcolor', "(255,255,255,255)", '-fillcolor', "(0,0,0,255)", '-y', '%d' % (desc_offset + 51 + (1+games_printed/settings['columns'])*(4+row_height)), '-x', '440']
    all_args.append(args)


    # Remove the inner ring
    cutout = os.path.join(piFolder, "Snaps", "cutout.png")
    args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-o', cutout, '-notrim', '-topmargin', top_margin, '-text', "", '-font', 'Oswald', '-fontsize', '18', '-fontcolor', "(255,255,255,255)", '-fillcolor', "(255,255,255,255)", '-y', '%d' % (desc_offset + 51 + (1+games_printed/settings['columns'])*(4+row_height) - 4), '-x', '436']
    all_args.append(args)

    args = [magick_path if windows else '', 'composite', '-geometry', '+2+2', cutout, '-type', "\"TrueColor\"", path, path]
    all_args.append(args)

    # Create the base temp file


    temp_path = os.path.join(piFolder, "Snaps", "header.png")
    args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-o', temp_path, '-notrim', '-topmargin', top_margin, '-text', "\"%s\"" % settings['title'], '-font', 'Oswald', '-fontsize', '18', '-fontcolor', fg_color, '-fillcolor', bg_color, '-y', '%d' % 32, '-x', '440']
    all_args.append(args)

    args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (0,0), temp_path, '-type', "\"TrueColor\"", path, path]
    all_args.append(args)

    header_1 = os.path.join(piFolder, "Snaps", "header_name.png")
    args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-o', header_1, '-notrim', '-topmargin', top_margin, '-text', "\"%s\"" % settings['name_header'], '-fontstyle', 'Bold', '-font', 'Oswald', '-fontsize', team_font, '-fontcolor', '(40,40,40,255)', '-fillcolor', '(254,254,254,255)', '-y', "%s" % row_height, '-x', '%d' %(120/settings['columns'])]
    all_args.append(args)

    header_2 = os.path.join(piFolder, "Snaps", "header_opp_elo.png")
    args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-o', header_2, '-center', '-notrim', '-topmargin', top_margin, '-text', "\"%s\"" % settings['value_header'], '-fontstyle', 'Bold', '-font', 'Oswald', '-fontsize', team_font, '-fontcolor', '(40,40,40,255)', '-fillcolor', '(254,254,254,255)', '-y', "%s" % row_height, '-x', '%d' %(90/settings['columns'])]
    all_args.append(args)

    if '--show-caption' in sys.argv:
        temp_path = os.path.join(piFolder, "Snaps", "signature.png")
        args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-o', temp_path, '-notrim', '-topmargin', top_margin, '-text', "\"%s\"" % "Infographic created by LacrosseReference.com", '-font', 'Oswald', '-fontsize', '12', '-fontcolor', '(0,0,0,255)', '-fillcolor', '(255,255,255,255)', '-y', '20', '-x', '436']
        all_args.append(args)

        args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (2, desc_offset + 29 + (1+games_printed/settings['columns'])*(4+row_height)), temp_path, '-type', "\"TrueColor\"", path, path]
        all_args.append(args)

    if 'description' in settings:
        args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (2, 25), desc_png, '-type', "\"TrueColor\"", path, path]
        all_args.append(args)
    games_printed = 0
    half_width = 440/settings['columns']



    for i, t in enumerate(settings['entries'][0:settings['count']]):


        tmp_file1 = os.path.join(piFolder, "Snaps", "team_rank%04d.png" % i)
        args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-o', tmp_file1, '-notrim', '-topmargin', top_margin, '-text', "#%d" % (i+1+rank_offset), '-font', 'Oswald', '-fontsize', team_font, '-fontcolor', '(40,40,40,255)', '-fillcolor', '(254,254,254,255)', '-y', "%s" % row_height, '-x', '%d' % (50/settings['columns'])]
        all_args.append(args)

        tmp_file2 = os.path.join(piFolder, "Snaps", "team_snapshot%04d.png" % i)
        args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-o', tmp_file2, '-notrim', '-topmargin', top_margin, '-text', "\"%s\"" % t[settings['name_label']], '-font', 'Oswald', '-fontsize', team_font, '-fontcolor', '(40,40,40,255)', '-fillcolor', '(254,254,254,255)', '-y', "%s" % row_height, '-x', '%d' % (230/settings['columns'])]
        all_args.append(args)

        tmp_file3a = os.path.join(piFolder, "Snaps", "opp_snapshot%04d.png" % i)
        args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-quiet', '-center', '-o', tmp_file3a, '-notrim', '-topmargin', top_margin, '-text', "\"%s\"" % t[settings['value_label']], '-font', 'Oswald', '-fontsize', team_font, '-fontcolor', '(40,40,40,255)', '-fillcolor', '(254,254,254,255)', '-y', "%s" % row_height, '-x', '%d' % (90/settings['columns'])]
        all_args.append(args)

        # 40 - 250 - 50 - 50 - 50
        y = desc_offset + 36 + (row_height+4) * (games_printed%(settings['count']/settings['columns']) + 1)
        x = 55 + (i/(settings['count']/settings['columns']))*half_width
        # Overlay the temp header png onto the actual plot
        args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (x,y), tmp_file2, '-type', "\"TrueColor\"", path, path]
        all_args.append(args)

        if i % (settings['count']/settings['columns']) == 0:
            args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (x,36+desc_offset), header_1, '-type', "\"TrueColor\"", path, path]
            all_args.append(args)


        x = 30 + (i/(settings['count']/settings['columns']))*half_width
        # Overlay the temp header png onto the actual plot
        try:

            gif_path = get_team_gif(t)
            if gif_path is None:
                print_stuff(opponent); zc.exit("laxref0017")
            args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (x,y-4), gif_path, '-type', "\"TrueColor\"", path, path]
            all_args.append(args)
        except Exception:
            print("No team GIF for %s" % t[settings['team_label']])

        x = 2 + (i/(settings['count']/settings['columns']))*half_width
        args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (x,y), tmp_file1, '-type', "\"TrueColor\"", path, path]
        all_args.append(args)

        x = (i/(settings['count']/settings['columns'])+1)*half_width - 100/settings['columns']
        # Overlay the temp header png onto the actual plot
        args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (x,y), tmp_file3a, '-type', "\"TrueColor\"", path, path]
        all_args.append(args)

        if i % (settings['count']/settings['columns']) == 0:
            args = [magick_path if windows else '', 'composite', '-geometry', '+%d+%d' % (x,36+desc_offset), header_2, '-type', "\"TrueColor\"", path, path]
            all_args.append(args)

        games_printed += 1

    #args = [magick_path if windows else '', 'convert', '-unsharp', '1.5x1.2+1.0+0.10', path, path.replace(".png", "_sharp.png")]
    #all_args.append(args)

    if "/home" in lr_fldr:
        f = open(os.path.join(lr_fldr, 'all_args_ev.sh'), 'w')
        f.write("#!/bin/bash\n\n")
        for i, aall in enumerate(all_args):
            #print "arg %d" % i
            if '-debug' in sys.argv:
                f.write("echo '%04d / %04d...'\n" % (i+1, len(all_args)))
            for i_, a in enumerate(aall):

                #print "\t%s" % str(aall[i_])
                if piFolder in a:
                    f.write("{}".format(("\"%s\" " % a.replace("\n", "\\n")).encode('ascii', 'ignore')))
                elif i_ > 0:

                    if str("{}".format(aall[i_-1].strip().encode('ascii', 'ignore'))) in ["-text", "-fillcolor", "-fontcolor"]:
                        f.write("{}".format(("\"%s\" " % a.replace("\n", "\\n")).encode('ascii', 'ignore')))
                    else:
                        f.write("%s " % a)
                else:
                    f.write("%s " % a)
            f.write("\n")

        f.close()


        os.system('sudo chmod 766 %s/all_args_ev.sh' % lr_fldr)
        start_ms = datetime.now().strftime("%H:%M:%S")
        os.system(os.path.join(lr_fldr, 'all_args_ev.sh'))
        end_ms = datetime.now().strftime("%H:%M:%S")
    else:
        all_args.append(['echo', "'The script has been completed'"])

        script_fname = os.path.join(lr_fldr, "Logs", "draw_img.bat")
        f = open(script_fname, 'w')
        code = "\n\n\n%s\n" % ("\n".join([" ".join(z) for z in all_args]))
        f.write(code)
        f.close()
        start_ms = datetime.now().strftime("%H:%M:%S")
        subprocess.call([script_fname])
    if '--upload-image' in sys.argv:
        upload_image_to_wp(settings['path'])

from ftplib import FTP
def upload_image_to_wp(path):
        dt = datetime.now()
        fname = path; loc = path.split("/")[-1]
        print ("Send %s to %s" % (fname, loc))

        creds = [{'username': z.split("|")[0], 'password': z.split("|")[1], 'url': z.split("|")[2]} for z in filter(None, open(os.path.join(lr_fldr, 'Logs', 'ftp_creds'), 'r').read().split("\n"))]
        #zc.print_dict(creds)
        print ("  Creating FTP object...")
        ftp = FTP(creds[0]['url'])
        print ("  Logging in...")
        ftp.login(creds[0]['username'], creds[0]['password'])
        print ("  Move to right folder...")
        ftp.cwd('/wp-content/uploads')

        content_dir1 = '%d' % (dt.year)
        content_dir2 = '%02d' % (dt.month)
        if content_dir1 not in ftp.nlst():
            ftp.mkd(content_dir1)
            ftp.cwd(content_dir1)
            ftp.mkd(content_dir2)
        else:
            ftp.cwd(content_dir1)
            if content_dir2 not in ftp.nlst():
                ftp.mkd(content_dir2)
        ftp.cwd(content_dir2)
        attached_file = "%s/%s/%s" % (content_dir1, content_dir2, loc)
        guid = "https://lacrossereference.com/wp-content/uploads/%s" % attached_file
        print ("  Upload file...")
        ftp.storbinary('STOR ' + loc, open(fname, 'rb'))
        print ("  Close connection...")
        ftp.quit()

        # Check if wp_post entry has been created for this file
        conn, cursor = zc.mysql_connect("LR")
        query = "SELECT * from wp_posts where guid like %s"
        param = ["%%%s%%" % loc.lower().replace("(", "").replace(")", "")]
        cursor.execute(query, param)
        res = zc.dict_query_results(cursor)
        if res == []:
            print ("File has not been added to wp_posts")

            query = "SELECT max(ID) + 1, 'ID' from wp_posts"
            cursor.execute(query)
            new_ID = zc.dict_query_results(cursor)[0]['ID']
            print (" Image is a new post with ID: %d" % new_ID)

            query = "INSERT INTO wp_posts (ID, post_author, post_date, post_date_gmt, post_content, post_title, post_excerpt, post_status, comment_status, ping_status, post_password, post_name, to_ping, pinged, post_modified, post_modified_gmt, post_content_filtered, post_parent, guid, menu_order, post_type, post_mime_type, comment_count) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
            param = [new_ID, 2, dt.strftime("%Y-%m-%d %H:%M:%S"), (dt + timedelta(seconds=3600*5)).strftime("%Y-%m-%d %H:%M:%S"), '', loc.split(".")[0], '', 'inherit', 'open', 'closed', '', loc.lower().split(".")[0], '', '', dt.strftime("%Y-%m-%d %H:%M:%S"), (dt + timedelta(seconds=3600*5)).strftime("%Y-%m-%d %H:%M:%S"), '', 0, guid, 0, 'attachment', 'image/png', 0]
            print ("Query %s w/ %s" % (query, param))
            cursor.execute(query, param)
            print ("Query 1/3 done")

            query = "INSERT INTO wp_postmeta (meta_id, post_id, meta_key, meta_value) VALUES ((SELECT max(meta_id) + 1 from wp_postmeta fds), %s, %s, %s)"
            param = [new_ID, '_wp_attached_file', attached_file]
            print ("Query %s w/ %s" % (query, param))
            cursor.execute(query, param)
            print ("Query 2/3 done")

            query = "INSERT INTO wp_postmeta (meta_id, post_id, meta_key, meta_value) VALUES ((SELECT max(meta_id) + 1 from wp_postmeta fds), %s, %s, %s)"
            param = [new_ID, '_wp_attachment_metadata', '']
            print ("Query %s w/ %s" % (query, param))
            cursor.execute(query, param)
            print ("Query 3/3 done")
            #conn.commit()

        else:
            print ("File has already been added to wp_posts")
        cursor.close(); conn.close()

def translate_confirmed_teams(home_team_full, away_team_full, alt_team1, alt_team2, specs):

    import statistics
    mysql_conn, cursor = zc.mysql_connect("LR")
    query = "SELECT confirmed_home_team, count(1), home_ID from LaxRef_Games where status like 'complete%%' and home_team=%s and not ISNULL(home_team) and not ISNULL(confirmed_home_team) and league=%s group by confirmed_home_team, home_team, home_ID order by 2 desc"
    param = [alt_team1, specs['league']]
    cursor.execute(query, param)
    res = cursor.fetchall()
    home_teams = []

    #print("Home Team Options\n---------------------------------")
    for r in res:
        print("%s - %d" % (r[0], r[1]))
        if r[0] not in [z['name'] for z in home_teams]:
            home_teams.append({'name': r[0], 'ID': r[2], 'cnt': 0})

        tmp = home_teams[ [z['name'] for z in home_teams].index(r[0])]
        tmp['cnt'] += r[1]
    query = "SELECT confirmed_home_team, count(1), home_ID from LaxRef_Games where status like 'complete%%' and alt_home_team=%s and not ISNULL(alt_home_team) and not ISNULL(confirmed_home_team) and league=%s group by confirmed_home_team, alt_home_team, home_ID order by 2 desc"
    param = [alt_team1, specs['league']]
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Home Team Options\n---------------------------------")
    for r in res:
        print("%s - %d" % (r[0], r[1]))
        if r[0] not in [z['name'] for z in home_teams]:
            home_teams.append({'name': r[0], 'ID': r[2], 'cnt': 0})
        tmp = home_teams[ [z['name'] for z in home_teams].index(r[0])]
        tmp['cnt'] += r[1]
    query = "SELECT confirmed_away_team, count(1), away_ID from LaxRef_Games where status like 'complete%%' and away_team=%s and not ISNULL(away_team) and not ISNULL(confirmed_away_team) and league=%s group by confirmed_away_team, away_team, away_ID order by 2 desc"
    param = [alt_team2, specs['league']]
    cursor.execute(query, param)
    res = cursor.fetchall()
    away_teams = []

    #print("Away Team Options\n---------------------------------")
    for r in res:
        print("%s - %d" % (r[0], r[1]))
        if r[0] not in [z['name'] for z in away_teams]:
            away_teams.append({'name': r[0], 'ID': r[2], 'cnt': 0})
        tmp = away_teams[ [z['name'] for z in away_teams].index(r[0])]
        tmp['cnt'] += r[1]
    query = "SELECT confirmed_away_team, count(1), away_ID from LaxRef_Games where status like 'complete%%' and alt_away_team=%s and not ISNULL(alt_away_team) and not ISNULL(confirmed_away_team) and league=%s group by confirmed_away_team, alt_away_team, away_ID order by 2 desc"
    param = [alt_team2, specs['league']]
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Away Team Options\n---------------------------------")
    for r in res:
        print("%s - %d" % (r[0], r[1]))
        if r[0] not in [z['name'] for z in away_teams]:
            away_teams.append({'name': r[0], 'ID': r[2], 'cnt': 0})
        tmp = away_teams[ [z['name'] for z in away_teams].index(r[0])]
        tmp['cnt'] += r[1]
    cursor.close(); mysql_conn.close()


    def use_token_approach(full, possibles):

        opts = [{'ID': z['ID'], 'name': z['name'], 'tokens': str(z['name'].replace("'","").replace('"',"").replace("-","").replace("(","").replace(")","")).split(" "), 'full_matches': None} for z in possibles]
        for o in opts:
            o['full_matches'] = len([1 for z in o['tokens'] if z in full.replace("'","").replace('"',"").replace("-","").replace("(","").replace(")","").split(" ")])
        #zc.print_dict(opts)
        max_matches = max([z['full_matches'] for z in opts])
        #print "Max Matches: %d" % max_matches
        max_opts = [z for z in opts if z['full_matches'] == max_matches]
        #print "Max Opts: %d" % len(max_opts)
        if len(max_opts) == 1 and max_matches > 0:
            #zc.print_dict(max_opts)

            msg = "Seems like we have a winner for %s; options were (%s) and we selected %s (from use token approach)" % (full, ", ".join([z['name'] for z in possibles]), max_opts[0]['name'])
            print (msg)
            
            if False and '-manual' in sys.argv:
                zc.send_telegram(msg, bot_token)
                if raw_input("\n\tConfirm (y/n): ") in ['y', 'Y']:
                    return max_opts[0]
                else:
                    return None
            else:
                return max_opts[0]

        return None

    alt_home_team = None; alt_home_team_ID = None
    alt_away_team = None; alt_away_team_ID = None

    if len(away_teams) == 0:
        print("Sorry, error, no away team options found.")
    elif len(away_teams) == 1:
        alt_away_team = away_teams[0]['name']
        alt_away_team_ID = away_teams[0]['ID']
    elif len(away_teams) == 2:
        if away_teams[0]['cnt'] * 100 / sum([z['cnt'] for z in away_teams]) > 66:
            alt_away_team = away_teams[0]['name']
            alt_away_team_ID = away_teams[0]['ID']
        else:
            res = use_token_approach(away_team_full, away_teams)
            if res is not None:
                alt_away_team = res['name']
                alt_away_team_ID = res['ID']
            else:
                #print("There were away 2 options, but it was pretty close, so I'm not sure...\n\t%s\n\t%s\n" % (str(away_teams), str(away_team_counts)))
                return None, None, None, None
    else:
        std_dev = statistics.stdev([z['cnt'] for z in away_teams])
        avg = statistics.mean([z['cnt'] for z in away_teams])
        if (away_teams[0]['cnt'] - avg) / std_dev > 2:
            alt_away_team = away_teams[0]['name']
            alt_away_team_ID = away_teams[0]['ID']
        else:
            print("First away option std dev was only %.2f" % ((away_teams[0]['cnt'] - avg) / std_dev))

    if len(home_teams) == 0:
        print("Sorry, error, no home team options found.")
    elif len(home_teams) == 1:
        alt_home_team = home_teams[0]['name']
        alt_home_team_ID = home_teams[0]['ID']
    elif len(home_teams) == 2:
        if home_teams[0]['cnt'] * 100 / sum([z['cnt'] for z in home_teams]) > 66:
            alt_home_team = home_teams[0]['name']
            alt_home_team_ID = home_teams[0]['ID']
        else:
            res = use_token_approach(home_team_full, home_teams)
            if res is not None:
                alt_home_team = res['name']
                alt_home_team_ID = res['ID']
            else:
                #print("There were home 2 options, but it was pretty close, so I'm not sure...\n\t%s\n\t%s\n" % (str(home_teams), str(home_team_counts)))
                return None, None, None, None
    else:
        std_dev = statistics.stdev([z['cnt'] for z in home_teams])
        avg = statistics.mean([z['cnt'] for z in home_teams])
        if (home_teams[0]['cnt'] - avg) / std_dev > 2:
            alt_home_team = home_teams[0]['name']
            alt_home_team_ID = home_teams[0]['ID']
        else:
            print("First home option std dev was only %.2f" % ((home_teams[0]['cnt'] - avg) / std_dev))


    return alt_home_team, alt_home_team_ID, alt_away_team, alt_away_team_ID


def translate_event_type(p, pd, full_detail, misc = None):
        e = "???"
        msg = None
        p = p.lower().strip()
        pd = pd.lower().strip()
        if pd.endswith("<"):
            pd = pd[0:-1]
        if p.strip() == "2-point shot":
            p = "shot"
        if p.strip() == "2-point goal":
            p = "goal"

        #print ("\np"); print (p)
        #print ("\npd"); print (pd)
        #print ("\nfull_detail"); print (full_detail)
        
        regex = re.compile('(\[?[0-9]+:[0-9]+\]?) .*?')
        for i in range(3):
            match = regex.search(p.strip())
            if match is not None and match.start() == 0:
                p = p.replace(match.group(1), "").strip()
        regex = re.compile('([0-9]{4}) .*?')
        for i in range(3):
            match = regex.search(p.strip())
            if match is not None and match.start() == 0:
                p = p.replace(match.group(1), "").strip()


        if (p == "clear attempt" or (p.startswith("[") and "clear attempt" in p)) and pd == "good.":
            e = "Good Clear"
        elif p == "clear attempt" and pd == "failed.":
            e = "Failed Clear"
        elif "shot" in p and (" save " in pd or pd.startswith("save ")):
            e = "Saved Shot"
        elif p == "shot" and (" missed, " in pd or " wide " in pd or pd.endswith(" wide.") or pd.endswith(" missed.")  or pd.endswith(" wide") or pd.endswith(" high.") or pd.endswith(" high") or "high {" in pd):
            e = "Missed Shot"
        elif p == "shot" and (pd.endswith(" defensive save.") or pd.endswith(" defensive save") or " defensive save {" in pd):
            e = "Blocked Shot"
        elif p == "shot" and (pd.endswith(" blocked.") or pd.endswith(" blocked") or " blocked {" in pd):
            e = "Blocked Shot"
        elif p == "shot" and ("hit post " in pd or pd.endswith(" hit post.") or pd.endswith(" hit post")):
            e = "Pipe Shot"
        elif p == "shot" and (pd.endswith(" hit crossbar") or pd.endswith(" hit crossbar.") or " hit crossbar {" in pd):
            e = "Pipe Shot"
        elif p == "goal" and " assist by " in pd:
            e = "Assisted Goal"
        elif p == "goal" and " assist by " not in pd:
            e = "Unassisted Goal"
        elif p == "turnover" and "(caused by " in pd:
            e = "Forced Turnover"
        elif "turnover" in p and p.startswith("[") and  "(caused by " in pd:
            e = "Forced Turnover"
        elif p.strip() == "turnover" and "(caused by " not in pd:
            e = "Unforced Turnover"
        elif "turnover" in p and p.startswith("[") and "(caused by " not in pd:
            e = "Unforced Turnover"
        elif p == "ground ball pickup":
            e = "Ground Ball"
        elif p.startswith("faceoff"):
            e = "Faceoff Win"
        elif p == "draw control":
            e = "Faceoff Win"
        elif p in ['bench misconduct', "foul"]:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "too many players/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "too many players/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "offside000" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "minor/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "bench misconduct":
            e = "Penalty - 30 sec"
        elif p == "penalty" and "pushing/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "holding/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "illegal body check/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "offside/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "offside/000" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "cross-check/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and ("/0:30)" in pd or "/0:00)" in pd or "/00:00)" in pd):
            e = "Penalty - 30 sec"
        elif p == "penalty" and "chck/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "(yellow card/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "(c/0:00" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "slsh/0:00" in pd:
            e = "Penalty - 1 min"
        elif p == "penalty" and "slashing/0:00" in pd:
            e = "Penalty - 1 min"
        elif p == "penalty" and "SLA`/1:00" in pd:
            e = "Penalty - 1 min"
        elif p == "penalty" and "1:30" in pd:
            e = "Penalty - 90 sec"
        elif p == "penalty" and "130" in pd:
            e = "Penalty - 90 sec"
        elif p == "penalty" and "0:30" in pd:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "030" in pd:
            e = "Penalty - 30 sec"
        elif "empty net, foul" in p:
            e = "Penalty - 30 sec"
        elif p == "penalty" and "1:00" in pd:
            e = "Penalty - 1 min"
        elif p == "penalty" and "100" in pd:
            e = "Penalty - 1 min"
        elif p == "penalty" and "2:00" in pd:
            e = "Penalty - 2 min"
        elif p == "penalty" and "200" in pd:
            e = "Penalty - 2 min"
        elif p == "penalty" and "3:00" in pd:
            e = "Penalty - 3 min"
        elif p == "penalty" and "300" in pd:
            e = "Penalty - 3 min"
        elif p == "penalty" and "by targeting" in full_detail:
            e = "Penalty - 3 min"
        elif p == "unsportsmanlike":
            e = "Penalty - 1 min"
        elif p == "yellow card" and misc['league'] in ['NCAA D1 Men', 'NCAA D2 Men', 'NCAA D3 Men']:
            e = "Penalty - 1 min"
        elif p == "red card" and misc['league'] in ['NCAA D1 Men', 'NCAA D2 Men', 'NCAA D3 Men']:
            e = "Penalty - 3 min"
        
        
        elif (p.startswith("yellow card") or p.startswith("red card") or p.startswith("green card")) and "(1:00)" in p and misc['league'] in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = "Penalty - 1 min"
        elif (p.startswith("yellow card") or p.startswith("red card") or p.startswith("green card")) and "(2:00)" in p and misc['league'] in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = "Penalty - 2 min"
        elif (p.startswith("yellow card") or p.startswith("red card") or p.startswith("green card")) and "(3:00)" in p and misc['league'] in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = "Penalty - 3 min"
        elif p == "yellow card" and misc['league'] in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = "Card"
        elif p == "red card" and misc['league'] in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = "Card"
        elif p == "green card" and misc['league'] in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = "Card"

        elif "at goalie" in p:
            e = "Goalie Change"
        elif p == "timeout" or (p.startswith("[") and p.endswith("timeout")):
            e = "Timeout"
        elif p == "30-second clock warning" or p == "second clock warning" or p == "shot clock warning":
            e = "Shot Clock On"
        elif p == "30-second clock violation" or p == "second clock violation" or p == "shot clock violation" or p == "clock violation":
            e = "Shot Clock Violation"
        elif " substitution" in p:
            e = "Substitution"
        elif "free position attempt" == p and misc['league'] in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = "Free Position Attempt"
        elif "free position attempt" == p and misc['league'] not in ['NCAA D1 Women', 'NCAA D2 Women', 'NCAA D3 Women']:
            e = None
        elif p == "shot":
            e = "Missed Shot"
        if e == "???":

            msg = "Unable to assign the following play to any play type (%s)...\n\n" % ("url unknown" if misc is None or 'url' not in misc else misc['url'])
            msg += "\n{:<15}{}".format("p", p)
            msg += "\n{:<15}{}".format("pd", pd)
            msg += "\n{:<15}{}".format("full_detail", full_detail)
            msg += "\nSkip this play (Y/N to exit): "

        return e, msg

def get_twitter_handles(cursor):
    cursor.execute("Select name, IFNULL(twitter_handle, ''), display_name, ID from LaxRef_Teams where active=1")
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'Team': r[0],'handle': r[1], 'display_name': r[2], "TeamID": r[3]})
    return results

def get_twitter_tracking_tags(cursor):
    cursor.execute("Select twitter_handle, campaign_content from GA_Tracking_Tags where campaign_source='twitter'")
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'handle': r[0],'code': r[1]})
    return results

def translate_alt_teams(home_team_full, away_team_full, alt_team1, alt_team2, league, print_it=True):

    if print_it:
        print("Translate Alt Teams\n-----------------------------\n\t Home team full: %s\n\t Away Team Full: %s\n\t Alt Team 1: %s\n\t Alt Team 2: %s\n" % (home_team_full, away_team_full, alt_team1, alt_team2))
    
    USEFILE=0
    if USEFILE:
        pass
    else:
        mysql_conn, cursor = zc.mysql_connect("LR")
        query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(home_team) and home_team=%s group by home_team order by 2 desc"
        param = [league, alt_team1]
        #print("\nQuery %s w/ %s" % (query, param))
        cursor.execute(query, param)
        res = cursor.fetchall()
    home_teams = []
    home_team_counts = []
    away_teams = []
    away_team_counts = []
    #print("Alt Team 1 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(confirmed_home_team) and  home_team=%s group by confirmed_home_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 2 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(home_team) and  home_team=%s group by home_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 2 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(home_team) and  alt_home_team=%s group by home_team order by 2 desc"
    param = [league, alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()

    #print("Alt Team 3 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(home_team) and  alt_home_team=%s group by home_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(confirmed_home_team) and  alt_home_team=%s group by confirmed_home_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(confirmed_home_team) and  alt_home_team=%s group by confirmed_home_team order by 2 desc"
    param = [league, alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(confirmed_home_team) and  alt_home_team=%s group by confirmed_home_team order by 2 desc"
    param = [league, alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(alt_home_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(alt_home_team) and  home_team=%s group by alt_home_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 5 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]

    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(away_team) and  away_team=%s group by away_team order by 2 desc"
    param = [league, alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 1 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(away_team) and  away_team=%s group by away_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 2 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(away_team) and  alt_away_team=%s group by away_team order by 2 desc"
    param = [league, alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 3 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(away_team) and  alt_away_team=%s group by away_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(alt_away_team, ''), count(1) from LaxRef_Games where league=%s and status like 'complete%%' and not isnull(alt_away_team) and  away_team=%s group by alt_away_team order by 2 desc"
    param = [league, alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 5 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    cursor.close(); mysql_conn.close()

    alt_away_team = None
    alt_home_team = None
    if print_it:
        print("\nAlt Team 2 Options\n---------------------------------")
    for team, count in zip(away_teams, away_team_counts):
        if team is not None and home_team_full is not None and team.title().strip().replace("St.", "State") == home_team_full.title().strip().replace("St.", "State"):
            alt_home_team = alt_team2
            #print("Because %s matched %s, set the alt_home_team to %s" % (team, home_team_full, alt_home_team))
            break
        if team is not None and away_team_full is not None and team.title().strip().replace("St.", "State") == away_team_full.title().strip().replace("St.", "State"):
            alt_away_team = alt_team2
            #print("Because %s matched %s, set the alt_away_team to %s" % (team, away_team_full, alt_away_team))
            break

    if print_it:
        print("\nAlt Team 1 Options\n---------------------------------")
    for team, count in zip(home_teams, home_team_counts):
        if print_it:
            print("%s - %d" % (team, count))
        if home_team_full is not None and team.title().strip().replace("St.", "State") == home_team_full.title().strip().replace("St.", "State"):
            alt_home_team = alt_team1
            #print("Because %s matched %s, set the alt_home_team to %s" % (team, home_team_full, alt_home_team))
            break
        if away_team_full is not None and team.title().strip().replace("St.", "State") == away_team_full.title().strip().replace("St.", "State"):
            alt_away_team = alt_team1
            #print("Because %s matched %s, set the alt_away_team to %s" % (team, away_team_full, alt_away_team))
            break


    if alt_home_team is not None and alt_away_team is None:

        alt_away_team = alt_team1 if alt_home_team == alt_team2 else alt_team2
        #print("Alt Home team was %s, set alt_away_team to %s" % (alt_home_team, alt_away_team))
    elif alt_home_team is None and alt_away_team is not None:

        alt_home_team = alt_team1 if alt_away_team == alt_team2 else alt_team2
        #print("Alt Away team was %s, set alt_home_team to %s" % (alt_away_team, alt_home_team))
    return alt_home_team.strip() if alt_home_team is not None else None, alt_away_team.strip() if alt_away_team is not None else None

def translate_alt_teams_fast(home_team_full, away_team_full, alt_team1, alt_team2, print_it=True):
    if print_it:
        print("Translate Alt Teams\n-----------------------------\n\t Home team full: %s\n\t Away Team Full: %s\n\t Alt Team 1: %s\n\t Alt Team 2: %s\n" % (home_team_full, away_team_full, alt_team1, alt_team2))
    mysql_conn, cursor = zc.mysql_connect("LR")
    query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(home_team) and home_team=%s group by home_team order by 2 desc"
    param = [alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    home_teams = []
    home_team_counts = []
    away_teams = []
    away_team_counts = []
    #print("Alt Team 1 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(confirmed_home_team) and  home_team=%s group by confirmed_home_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 2 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(home_team) and  home_team=%s group by home_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 2 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(home_team) and  alt_home_team=%s group by home_team order by 2 desc"
    param = [alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()

    #print("Alt Team 3 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(home_team) and  alt_home_team=%s group by home_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(confirmed_home_team) and  alt_home_team=%s group by confirmed_home_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(confirmed_home_team) and  alt_home_team=%s group by confirmed_home_team order by 2 desc"
    param = [alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(confirmed_home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(confirmed_home_team) and  alt_home_team=%s group by confirmed_home_team order by 2 desc"
    param = [alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(alt_home_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(alt_home_team) and  home_team=%s group by alt_home_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 5 Home Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]

    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(away_team) and  away_team=%s group by away_team order by 2 desc"
    param = [alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 1 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(away_team) and  away_team=%s group by away_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 2 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(away_team) and  alt_away_team=%s group by away_team order by 2 desc"
    param = [alt_team1]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 3 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in home_teams:
            home_teams.append(r[0])
            home_team_counts.append(0)
        home_team_counts[home_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(away_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(away_team) and  alt_away_team=%s group by away_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 4 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    query = "SELECT IFNULL(alt_away_team, ''), count(1) from LaxRef_Games where status like 'complete%%' and not isnull(alt_away_team) and  away_team=%s group by alt_away_team order by 2 desc"
    param = [alt_team2]
    #print("\nQuery %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res = cursor.fetchall()
    #print("Alt Team 5 Away Team Options\n---------------------------------")
    for r in res:
        #print("%s - %d" % (r[0], r[1]))
        if r[0] not in away_teams:
            away_teams.append(r[0])
            away_team_counts.append(0)
        away_team_counts[away_teams.index(r[0])] += r[1]
    cursor.close(); mysql_conn.close()

    alt_away_team = None
    alt_home_team = None
    if print_it:
        print("Alt Team 2 Options\n---------------------------------")
    for team, count in zip(away_teams, away_team_counts):
        if print_it:
            print("%s - %d" % (team, count))
        if team.title() == home_team_full.title():
            alt_home_team = alt_team2
            #print("Because %s matched %s, set the alt_home_team to %s" % (team, home_team_full, alt_home_team))
            break
        if team.title() == away_team_full.title():
            alt_away_team = alt_team2
            #print("Because %s matched %s, set the alt_away_team to %s" % (team, away_team_full, alt_away_team))
            break

    if print_it:
        print("Alt Team 1 Options\n---------------------------------")
    for team, count in zip(home_teams, home_team_counts):
        if print_it:
            print("%s - %d" % (team, count))
        if team.title() == home_team_full.title():
            alt_home_team = alt_team1
            #print("Because %s matched %s, set the alt_home_team to %s" % (team, home_team_full, alt_home_team))
            break
        if team.title() == away_team_full.title():
            alt_away_team = alt_team1
            #print("Because %s matched %s, set the alt_away_team to %s" % (team, away_team_full, alt_away_team))
            break


    if alt_home_team is not None and alt_away_team is None:

        alt_away_team = alt_team1 if alt_home_team == alt_team2 else alt_team2
        #print("Alt Home team was %s, set alt_away_team to %s" % (alt_home_team, alt_away_team))
    elif alt_home_team is None and alt_away_team is not None:

        alt_home_team = alt_team1 if alt_away_team == alt_team2 else alt_team2
        #print("Alt Away team was %s, set alt_home_team to %s" % (alt_away_team, alt_home_team))
    return alt_home_team, alt_away_team

def clean_player_name(player, team=None):
    if player.lower() == "td ierlan":
        return "TD Ierlan"
    if player.lower() == "jt giles-harris":
        return "JT Giles-Harris"
    if player.lower() == "bo bowhunter":
        return "Bo BowHunter"

    tokens = player.split(" ")
    for i, t in enumerate(tokens):
        if t.upper() == t and len(t) > 2:
            tokens[i] = t.title()
        elif len(t)==2 and t.upper() not in ['TY', 'BO']:
            tokens[i] = t.upper()
    #if player != " ".join(tokens):
    #    print "Started with {:<30} ended with {:<30}".format(player, " ".join(tokens))
    return " ".join(tokens)

def get_laxpower_forum(cursor, team):
    query = "SELECT twitter_handle from GA_Tracking_Tags where email_campaign_descriptor like %s and campaign_source='LaxPower Forums'"
    param = ["%s%%" % team]
    cursor.execute(query, param)
    res = cursor.fetchone()
    if res is not None:
        res = res[0]
    return res

def get_IL_win_pct():
    url = "https://insidelacrosse.com/league/DI/teams"


    print("Make request...")
    response = requests.get(url, timeout=20)
    #print(response.content)
    regex = re.compile(r'<tr><td><a href\=\"\/team\/.*?\">(.*?)</a></td><td>([0-9]+)</td><td>([0-9]+)</td>')
    matches = re.findall(regex, response.content)
    total_wins = 0
    total_losses = 0
    IL_teams = []
    for m in matches:
        #print("Match: %s has %s wins and %s losses" % m)
        team_name = m[0]
        team_name = "Detroit" if team_name == "Detroit Mercy" else team_name
        team_name = "Boston U" if team_name == "Boston University" else team_name
        team_name = "Massachusetts-Lowell" if team_name == "UMass Lowell" else team_name
        team_name = "Massachusetts" if team_name == "UMass" else team_name
        team_name = "Mount St Marys" if team_name == "Mount St Mary's" else team_name
        team_name = "Hobart and William" if team_name == "Hobart" else team_name
        team_name = "Loyola MD" if team_name == "Loyola" else team_name
        team = {'team': team_name, 'win_pct': 0.0 if (float(m[1]) + float(m[2])) == 0 else float(m[1])/(float(m[1]) + float(m[2]))}
        IL_teams.append(team)
    return IL_teams

def create_charts(fig, plt, charts):
    all_args = []

    colors = ['r', 'b', 'g', 'c', 'm', 'y', 'k', 'w']

    for c in charts:
        fg_color = '(255,255,255,255)' if 'fg_color' not in c else c['fg_color']
        bg_color = '(0,0,165,255)' if 'bg_color' not in c else c['bg_color']

        if 'second_axis' in c and c['second_axis']:
            if 'axes_dim' in c:
                ax1 = fig.add_axes(c['axes_dim'])
            else:
                ax1 = fig.add_axes((.15, .2, .75, .7))
        else:
            if 'axes_dim' in c:
                ax1 = fig.add_axes(c['axes_dim'])
            else:
                ax1 = fig.add_axes((.15, .2, .8, .7))

        if True:
            ax1.set_title(" " + c['title_str'][0:1], loc='left')
        else:
            ax1.set_title(c['title_str'], loc='left')
        if c['chart_type'] == "hist":
            if c['xlim'] is not None:
                if c['xlim'][0] is not None and c['xlim'][1] is None:
                    plt.xlim(c['xlim'][0], max(c['x']))
                elif c['xlim'][0] is None and c['xlim'][1] is not None:
                    plt.xlim(min(c['x']), c['xlim'][1])
                else:
                    plt.xlim(c['xlim'][0], c['xlim'][1])
            ax1.hist(c['x'], bins=c['bins'])
            if c['ylabel_type'] == 'pct_of_total':
                l = ax1.yaxis.get_ticklocs().tolist()
                new_labels = ["" if ztc < 0 else "%d%%" % (100.0*float(ztc)/float(len(c['x']))) for ztc in l]
                #print (new_labels)
                plt.yticks(l, new_labels)
            ax1.set_xlabel(c['xlabel']); ax1.set_ylabel(c['ylabel'])


        elif c['chart_type'] == "bar":
            if 'y_minor' in c:

                ax1.set_yticks(c['y_minor'], minor=True)
                ax1.yaxis.grid(True, which='minor', c=c['y_minor_col'] if 'y_minor_col' in c else "#EEEEEE")
            if 'x_minor' in c:

                ax1.set_xticks(c['x_minor'], minor=True)
                ax1.xaxis.grid(True, which='minor', c=c['x_minor_col'] if 'x_minor_col' in c else "#EEEEEE")

            if isinstance(c['x'][0], list):
                bar_width = 1.0/float(1+len(c['x']))*.95
                bar_offset = 1.0/float(1+len(c['x']))

                for i, (x, y, l) in enumerate(zip(c['x'], c['y'], c['labels'])):
                    if 'labels' in c and c['labels'] is not None:
                        ax1.bar([z + bar_offset*i for z in x], y, color=colors[i%8], width=bar_width, label=l, alpha=.5, align='center')
                    else:
                        ax1.bar([z + bar_offset*i for z in x], y, color=colors[i%8], width=bar_width, alpha=.5, align='center')
            else:
                if 'bar_colors' in c and c['bar_colors'] is not None:

                    if c['labels'] is not None:
                        ax1.bar(c['x'], c['y'], align='center', label=c['labels'], color=c['bar_colors'])
                    else:
                        ax1.bar(c['x'], c['y'], align='center', color=c['bar_colors'])

                else:
                    if c['labels'] is not None:
                        ax1.bar(c['x'], c['y'], align='center', label=c['labels'], alpha=.5)
                    else:
                        ax1.bar(c['x'], c['y'], align='center', alpha=.5)

            ax1.set_xlabel(c['xlabel']); ax1.set_ylabel(c['ylabel'])

            if c['xlim'] is not None:
                if c['xlim'][0] is not None and c['xlim'][1] is None:
                    plt.xlim(c['xlim'][0], max(c['x']))
                elif c['xlim'][0] is None and c['xlim'][1] is not None:
                    plt.xlim(min(c['x']), c['xlim'][1])
                else:
                    plt.xlim(c['xlim'][0], c['xlim'][1])

            # Y ticks
            if c['ylabel'] == "":
                plt.yticks([])
            else:
                if c['ylabel_type'] == 'pct':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'pct_of_total':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (100*ztc/sum(c['y'])) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'int':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [int(ztc) for ztc in l], size=8)
                elif c['ylabel_type'] == '+int':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [int(ztc) if ztc >= 0 else "" for ztc in l], size=8)
                elif c['ylabel_type'] == '+log':
                    ax1.set_yscale('log')
                    l = ax1.yaxis.get_ticklocs().tolist()
                    tmp = []
                    for t in l:
                        s = str(int(t))
                        if s.endswith("000000000"):
                            tmp.append("%d%s" % (int(t/1000000000), "B"))
                        elif s.endswith("000000"):
                            tmp.append("%d%s" % (int(t/1000000), "M"))
                        elif s.endswith("000"):
                            tmp.append("%d%s" % (int(t/1000), "K"))
                        else:
                            tmp.append(int(t))
                    plt.yticks(l, tmp, size=8)
                else:
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)

            # X ticks
            if c['xlabel'] == "":
                plt.xticks([])
            else:
                if c['xlabel_type'] == 'pct':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.xticks(l, new_labels, size=8)
                elif c['xlabel_type'] == 'int':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) for ztc in l], size=8)
                elif c['xlabel_type'] == 'custom':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [ztc for ztc in c['custom_x_labels']], size=8)
                elif c['xlabel_type'] == '+int':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) if ztc >= 0 else '' for ztc in l], size=8)
                else:
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)
            if 'annotations' in c:
                for a in c['annotations']:
                    plt.annotate(a['txt'], a['loc'], fontsize=7 if 'size' not in a else a['size'])
        elif c['chart_type'] == "line":
            #for x, y in zip(c['x'], c['y']):
            #    print x, y
            #zc.exit("laxref0018")
            if isinstance(c['x'][0], list):
                for i, (x, y, l) in enumerate(zip(c['x'], c['y'], c['labels'])):
                    if isinstance(c['color1'], list):
                        ax1.plot(x, y, color=c['color1'][i], label=l, linewidth=(4.0 if 'linewidth' not in c else c['linewidth']))
                    else:
                        ax1.plot(x, y, label=l, linewidth=(4.0 if 'linewidth' not in c else c['linewidth']))
            else:
                ax1.plot(c['x'], c['y'], color=c['color1'], label=c['labels'], linewidth=(4.0 if 'linewidth' not in c else c['linewidth']))
            if c['xlim'] is not None:
                if c['xlim'][0] is not None and c['xlim'][1] is None:
                    if isinstance(c['x'][0], list):
                        plt.xlim(c['xlim'][0], max([max(x) for x in c['x']]))
                    else:
                        plt.xlim(c['xlim'][0], max(c['x']))
                elif c['xlim'][0] is None and c['xlim'][1] is not None:
                    plt.xlim(min(c['x']), c['xlim'][1])
                else:
                    plt.xlim(c['xlim'][0], c['xlim'][1])
            if c['ylim'] is not None:
                if c['ylim'][0] is not None and c['ylim'][1] is None:
                    if isinstance(c['y'], list):
                        plt.ylim(c['ylim'][0], max([max(x) for x in c['y']]))
                    else:
                        plt.ylim(c['ylim'][0], max(c['y']))
                elif c['ylim'][0] is None and c['ylim'][1] is not None:
                    plt.ylim(min(c['y']), c['ylim'][1])
                else:
                    plt.ylim(c['ylim'][0], c['ylim'][1])
            # Y ticks
            if c['ylabel'] == "":
                plt.yticks([])
            else:
                if c['ylabel_type'] == 'pct':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'pct_of_total':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (100*ztc/sum(c['y'])) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'int':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [int(ztc) for ztc in l], size=8)
                elif c['ylabel_type'] == 'decimal':
                    locs = ax1.yaxis.get_ticklocs()
                    if isinstance(locs, list):
                        for l in locs:
                            l_ = l.tolist()
                            plt.yticks(l_, ["%f" % ztc for ztc in l_], size=8)
                    else:
                        l_ = locs.tolist()
                        plt.yticks(l_, [float(ztc) for ztc in l_], size=8)
                elif c['ylabel_type'] == '+int':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, ["%s" % "{:,}".format(int(ztc)) if ztc >= 0 else "" for ztc in l], size=8)
                elif c['ylabel_type'] == '+log':
                    ax1.set_yscale('log')
                    l = ax1.yaxis.get_ticklocs().tolist()
                    tmp = []
                    for t in l:
                        s = str(int(t))
                        if s.endswith("000000000"):
                            tmp.append("%d%s" % (int(t/1000000000), "B"))
                        elif s.endswith("000000"):
                            tmp.append("%d%s" % (int(t/1000000), "M"))
                        elif s.endswith("000"):
                            tmp.append("%d%s" % (int(t/1000), "K"))
                        else:
                            tmp.append(int(t))
                    plt.yticks(l, tmp, size=8)
                else:
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)

            # X ticks
            if c['xlabel'] == "":
                plt.xticks([])
            else:
                if c['xlabel_type'] == 'pct':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.xticks(l, new_labels, size=8)
                elif c['xlabel_type'] == 'int':
                    print (ax1.xaxis.get_ticklocs())
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) for ztc in l], size=8)
                elif c['xlabel_type'] == 'time':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    #plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)
                    plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b-%d %I%p") for ztc in l], size=8)
                elif c['xlabel_type'] .startswith( 'date'):
                    date_format = "%b %d"
                    if ":" in c['xlabel_type']:
                        date_format = c['xlabel_type'].split(":")[-1]
                    l = ax1.xaxis.get_ticklocs().tolist()
                    #plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)
                    plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime(date_format) for ztc in l], size=8)

                elif c['xlabel_type'] == '+int':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) if ztc >= 0 else '' for ztc in l], size=8)
                elif c['xlabel_type'] == 'none':
                    pass
                else:
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)
            if 'y_minor' in c:

                ax1.set_yticks(c['y_minor'], minor=True)
                ax1.yaxis.grid(True, which='minor')


            if 'x_minor' in c:
                #print("Draw vertical line at %s" % str(c['x_minor']))
                ax1.set_xticks(c['x_minor'], minor=True)
                ax1.xaxis.grid(True, which='minor')
                #print("Write label at %s" + str((c['x_minor'][0], min([min(z) for z in c['y']]) + .03*float((max([max(z) for z in c['y']]) - min([min(z) for z in c['y']]))))))
                #plt.annotate("Memorial Day", (c['x_minor'][0], min([min(z) for z in c['y']]) + .03*float((max([max(z) for z in c['y']]) - min([min(z) for z in c['y']])))), fontsize=7)
            ax1.set_xlabel(c['xlabel']); ax1.set_ylabel(c['ylabel'])

            if 'second_axis' in c and c['second_axis']:
                ax2 = ax1.twinx()
                if isinstance(c['x_axis2'][0], list):
                    for i, (x, y, l) in enumerate(zip(c['x_axis2'], c['y_axis2'], c['labels_axis2'])):
                        if isinstance(c['color1_axis2'], list):
                            ax2.plot(x, y, color=c['color1_axis2'][i], label=l, linewidth=(4.0 if 'linewidth' not in c else c['linewidth']))
                        else:
                            ax2.plot(x, y, label=l, linewidth=(4.0 if 'linewidth' not in c else c['linewidth']))
                else:
                    ax2.plot(c['x_axis2'], c['y_axis2'], color=c['color1_axis2'], label=c['labels_axis2'], linewidth=(4.0 if 'linewidth' not in c else c['linewidth']))


                #l = ax2.yaxis.get_ticklocs().tolist()
                #plt.yticks(l, ["{:,}".format(int(ztc)) if ztc >= 0 else "" for ztc in l], size=8)
                # Y ticks
            # X ticks
            if 'second_axis' in c and c['second_axis']:
                if c['xlabel_type'] == 'pct':
                    l = ax2.xaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.xticks(l, new_labels, size=8)
                elif c['xlabel_type'] == 'int':
                    print (ax2.xaxis.get_ticklocs())
                    l = ax2.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) for ztc in l], size=8)
                elif c['xlabel_type'] == 'time':
                    l = ax2.xaxis.get_ticklocs().tolist()
                    #plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)
                    plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b-%d %I%p") for ztc in l], size=8)
                elif c['xlabel_type'] == 'date':
                    l = ax2.xaxis.get_ticklocs().tolist()
                    #plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)
                    plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)

                elif c['xlabel_type'] == '+int':
                    l = ax2.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) if ztc >= 0 else '' for ztc in l], size=8)
                elif c['xlabel_type'] == 'none':
                    pass
                else:
                    l = ax2.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)


                if c['ylabel_type'] == 'pct':
                    l = ax2.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'pct_of_total':
                    l = ax2.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (100*ztc/sum(c['y'])) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'int':
                    l = ax2.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [int(ztc) for ztc in l], size=8)
                elif c['ylabel_type'] == 'decimal':
                    locs = ax2.yaxis.get_ticklocs()
                    if isinstance(locs, list):
                        for l in locs:
                            l_ = l.tolist()
                            plt.yticks(l_, ["%f" % ztc for ztc in l_], size=8)
                    else:
                        l_ = locs.tolist()
                        plt.yticks(l_, [float(ztc) for ztc in l_], size=8)
                elif c['ylabel_type'] == '+int':
                    l = ax2.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, ["%s" % "{:,}".format(int(ztc)) if ztc >= 0 else "" for ztc in l], size=8)
                elif c['ylabel_type'] == '+log':
                    ax2.set_yscale('log')
                    l = ax2.yaxis.get_ticklocs().tolist()
                    tmp = []
                    for t in l:
                        s = str(int(t))
                        if s.endswith("000000000"):
                            tmp.append("%d%s" % (int(t/1000000000), "B"))
                        elif s.endswith("000000"):
                            tmp.append("%d%s" % (int(t/1000000), "M"))
                        elif s.endswith("000"):
                            tmp.append("%d%s" % (int(t/1000), "K"))
                        else:
                            tmp.append(int(t))
                    plt.yticks(l, tmp, size=8)
                else:
                    l = ax2.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)


        elif c['chart_type'] == "scatter":
            if isinstance(c['x'][0], list):
                for i, (x, y) in enumerate(zip(c['x'], c['y'])):
                    if c['labels'] is not None:

                        ax1.scatter(x,y,label=c['labels'][i], s=(1 if 'dotsize' not in c else c['dotsize']), c=colors[i%8])
                    else:
                        ax1.scatter(x,y,s=(1 if 'dotsize' not in c else c['dotsize']), c=colors[i%8])
            else:
                ax1.scatter(c['x'],c['y'],s=(1 if 'dotsize' not in c else c['dotsize']), c=c['color1'])
            #print("\n%s" % c['title_str'])
            #print(c['x'])
            #print(c['x2'])
            #print(c['y'])
            if 'x2' in c and c['x2'] is not None:
                if 'y2' in c:
                    ax1.scatter(c['x2'],c['y2'],s=1, c=c['color2'])
                else:
                    ax1.scatter(c['x2'],c['y'],s=60, c=c['color2'])
            ax1.set_xlabel(c['xlabel'], size=8); ax1.set_ylabel(c['ylabel'], size=8)
            if c['xlim'] is not None:
                if c['xlim'][0] is not None and c['xlim'][1] is None:
                    plt.xlim(c['xlim'][0], max(c['x']))
                elif c['xlim'][0] is None and c['xlim'][1] is not None:
                    plt.xlim(min(c['x']), c['xlim'][1])
                else:
                    plt.xlim(c['xlim'][0], c['xlim'][1])

            if c['ylim'] is not None:
                if c['ylim'][0] is not None and c['ylim'][1] is None:
                    plt.ylim(c['ylim'][0], max(c['y']))
                elif c['ylim'][0] is None and c['ylim'][1] is not None:
                    plt.ylim(min(c['y']), c['ylim'][1])
                else:
                    plt.ylim(c['ylim'][0], c['ylim'][1])

            if c['labels'] is not None:
                def convert_to_coord(x, y, xlim, ylim):
                    new_x = int(640*float(x - xlim[0])/float(xlim[1] - xlim[0]))
                    new_y = int(480*float(y - ylim[0])/float(ylim[1] - ylim[0]))
                    return new_x, new_y
                def convert_to_loc(x, y, xlim, ylim):
                    old_x = (float(x) * float(xlim[1] - xlim[0]))/640.0 + float(xlim[0])
                    old_y = (float(y) * float(ylim[1] - ylim[0]))/480.0 + float(ylim[0])
                    return old_x, old_y
                # Annotations
                grid = []
                for g in range(640):
                    grid.append([False] * 480)
                for x, y in zip(c['x'], c['y']):
                    if x is not None:
                        nx, ny = convert_to_coord(x, y, ax1.get_xlim(), ax1.get_ylim())
                        #print(" (%.3f, %.3f) converts to (%.3f, %.3f)" % (x, y, nx, ny))
                        for x_ in range(-10, 10):
                            for y_ in range(-10, 10):
                                if -1 < nx+x_ < 640 and -1 < ny+y_ < 480:
                                    grid[nx+x_][ny+y_] = True
                pix_per_char = 17
                for i, txt in enumerate(c['labels']):
                    if c['x'][i] is not None:

                        if c['label_x_loc'] is not None:
                            starting_point = (c['label_x_loc'], c['y'][i])
                        else:
                            starting_point = (c['x'][i] + c['xlabel_off'], c['y'][i])

                        overlap = False
                        nx, ny = convert_to_coord(starting_point[0], starting_point[1], ax1.get_xlim(), ax1.get_ylim())
                        for x in range(nx, min(640, nx + pix_per_char*len(txt))):
                            for y in range(ny, min(480, ny + pix_per_char)):
                                if grid[x][y]:
                                        overlap = True
                                        break
                        if overlap:
                            #print("I think that %s is going to overlap with an existing dot." % (txt))
                            for y_adj in range(-10,-10) + range(0,20):
                                adj_ny = ny + y_adj
                                overlap = False
                                for x in range(nx, min(640, nx + pix_per_char*len(txt))):
                                    for y in range(adj_ny, min(480, adj_ny + pix_per_char)):
                                        if grid[x][y]:
                                                overlap = True
                                                break
                                if not overlap:
                                    starting_point = convert_to_loc(nx, adj_ny , ax1.get_xlim(), ax1.get_ylim())
                                    #print(" (%d,%d) doesn't appear to overlap, so convert it to (%.3f, %.3f)" % (nx, adj_ny, starting_point[0], starting_point[1]))
                                    break

                        plt.annotate(txt, starting_point, fontsize=7 if 'labelsize' not in c else c['labelsize'])
                        nx, ny = convert_to_coord(starting_point[0], starting_point[1], ax1.get_xlim(), ax1.get_ylim())
                        #print(" (%.3f, %.3f) converts to (%.3f, %.3f)" % (starting_point[0], starting_point[1], nx, ny))
                        for x_ in range(0, pix_per_char*len(txt)):
                            for y_ in range(0, pix_per_char):
                                #if txt == "Yale" and y_ == 0:
                                #    print("  (%d,%d) if off limits." % (nx+x_, ny))

                                if -1 < nx+x_ < 640 and -1 < ny+y_ < 480:
                                    grid[nx+x_][ny+y_] = True

                    else:
                        print("Excluding %s data point from %s" % (txt, c['path']))

            # Y ticks
            if c['ylabel'] == "":
                plt.yticks([])
            else:
                if c['ylabel_type'] == 'pct':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'pct_of_total':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (100*ztc/sum(c['y'])) for ztc in l]
                    plt.yticks(l, new_labels, size=8)
                elif c['ylabel_type'] == 'int':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [int(ztc) for ztc in l], size=8)
                elif c['ylabel_type'] == 'decimal':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [float(ztc) for ztc in l], size=8)
                elif c['ylabel_type'] == '+int':
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, ["%s" % "{:,}".format(int(ztc)) if ztc >= 0 else "" for ztc in l], size=8)
                elif c['ylabel_type'] == '+log':
                    ax1.set_yscale('log')
                    l = ax1.yaxis.get_ticklocs().tolist()
                    tmp = []
                    for t in l:
                        s = str(int(t))
                        if s.endswith("000000000"):
                            tmp.append("%d%s" % (int(t/1000000000), "B"))
                        elif s.endswith("000000"):
                            tmp.append("%d%s" % (int(t/1000000), "M"))
                        elif s.endswith("000"):
                            tmp.append("%d%s" % (int(t/1000), "K"))
                        else:
                            tmp.append(int(t))
                    plt.yticks(l, tmp, size=8)
                else:
                    l = ax1.yaxis.get_ticklocs().tolist()
                    plt.yticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)

            # X ticks
            if c['xlabel'] == "":
                plt.xticks([])
            else:
                if c['xlabel_type'] == 'pct':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    new_labels = ["" if ztc < 0 else "%d%%" % (ztc) for ztc in l]
                    plt.xticks(l, new_labels, size=8)
                elif c['xlabel_type'] == 'int':
                    print (ax1.xaxis.get_ticklocs())
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) for ztc in l], size=8)
                elif c['xlabel_type'] == 'time':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    #plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)
                    plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b-%d %I%p") for ztc in l], size=8)
                elif c['xlabel_type'] == 'date':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    #plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)
                    plt.xticks(l, [(datetime.strptime("0001-01-01", "%Y-%m-%d") + datetime.timedelta(days=float(ztc))).strftime("%b %d") for ztc in l], size=8)

                elif c['xlabel_type'] == '+int':
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [int(ztc) if ztc >= 0 else '' for ztc in l], size=8)
                elif c['xlabel_type'] == 'none':
                    pass
                else:
                    l = ax1.xaxis.get_ticklocs().tolist()
                    plt.xticks(l, [ztc if ztc >= 0 else "" for ztc in l], size=8)
            if 'y_minor' in c:
                ax1.set_yticks(c['y_minor'], minor=True)
                ax1.yaxis.grid(True, which='minor')

            if 'x_minor' in c:
                ax1.set_xticks(c['x_minor'], minor=True)
                ax1.xaxis.grid(True, which='minor')


        if 'second_axis' in c and c['second_axis']:
            h1, l1 = ax1.get_legend_handles_labels()
            h2, l2 = ax2.get_legend_handles_labels()
            ax1.legend(h1+h2, l1+l2, loc='best', fontsize=8)
        else:
            if 'no-legend' not in c:
                ax1.legend(loc='best', fontsize=8)

        if 'y_invert' in c:
            ax1.invert_yaxis()

        fig.text(.02, .02, c['caption'], size=8)
        plt.savefig(c['path'])
        plt.clf()

        if 'title_str' in c and c['title_str'] is not None:
            # Create the temp png file that shows the header for the plot
            all_args.append(['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-notrim', '-text', c['title_str'], '-font', 'Oswald', '-fontsize', '20' if 'title_font' not in c or c['title_font'] is None else c['title_font'], '-fontcolor', fg_color, '-fillcolor', bg_color, '-y', '38' if 'title_height' not in c or c['title_height'] is None else c['title_height'], '-x', '641' if 'title_length' not in c or c['title_length'] is None else "%s" % (c['title_length'])])
            # Overlay the temp header png onto the actual plot
            all_args.append([magick_path if windows else '', 'composite', '-geometry', '+80+16' if 'title_loc' not in c or c['title_loc'] is None else c['title_loc'], os.path.join(zc_fldr, 'draw_text_header.png'), c['path'], c['path']])

    return all_args


def get_adj_odds(section, adjusted_diff, win_odds_data, win_odds_ID):
    odds = 0
    loc = 22 + adjusted_diff
    loc = max(0, min(loc, 41))
    section = min(section, 59)
    #print "Loc: %f" % loc

    lower_limit = 20. - 6.*(min(float(section), 30.)/30.)
    upper_limit = 24. + 6.*(min(float(section), 30.)/30.)


    if section in win_odds_ID:
        win_odds_row = win_odds_data[win_odds_ID.index(section)].split(",")

        for i, o_ in enumerate(win_odds_row[:-1]):
            next_val = win_odds_row[i+1]
            prior_val = win_odds_row[i-1] if i > 0 else None
            point = (loc-i)

            if o_ != "":
                o = float(o_)

                if loc > i and loc <= i+1:
                    if o == 1.0 or (next_val in [None, ""] and loc > upper_limit):
                        return 1.0
                    elif o == 0.0 or (prior_val in [None, ""] and loc < lower_limit):
                        return 0.0
                    elif o > .75 and (next_val in [None, ""] and loc > 23):
                        res = (1. - float(o))*point + float(o)
                        #print "Res: %.3f" % res
                        return res
                    else:
                        try:
                            
                            odds = (float(next_val) - float(o))*point + float(o)
                            if '--debug-wp-calc' in sys.argv: 
                                print ("\t{:<25}{:<25}{:<25}{:<25}".format("next_val: %.3f" % float(next_val), "o: %.3f" % float(o), "point: %.3f" % float(point), "odds: %.3f" % float(odds)))
                        except ValueError:
                            print("In Get Adj Odds: Error converting adjusted_diff: %s, prior_val: %s, next_val: %s, o:%s, loc:%s" % (adjusted_diff, prior_val, next_val, o, loc))
                            print("\tSection: %d" % (section))
                            print("\tPoint: %.3f-%.3f=%.3f" % (loc, i, point))
                            print("\tLoc: %d" % (loc))
                            zc.exit("laxref0019")
                        return odds
            elif o_ == "" and (next_val not in [None, ""] and loc < 20):
                if loc > i and loc <= i+1:
                    res = (float(next_val))*point
                    #print("\tSection: %d" % (section))
                    #print "Res: %.3f * %.3f = %.3f" % ((float(next_val)),point, res)
                    #print "Res: %.3f" % res
                    #print "Loc: %.3f" % loc
                    #print "i: %d" % i
                    #print "Point: %.3f" % point
                    #zc.exit("laxref0020")
                    return res
            elif loc < lower_limit:
                return 0.
            elif loc > upper_limit:
                return 1.
         
        if '--debug-wp-calc' in sys.argv: 
            print("A)")
            #print ("A) Loc: %d" % loc)
            #print (win_odds_data[win_odds_ID.index(section)].split(",")[:-1])
            #print ("Win Odds Row\n--------------------------")
            #print (win_odds_row , "\n")
            #print ("Loc: %.3f" % loc)
        return -1
    else:
        return  -1

def get_adj_db_odds(section, diff, adjusted_diff, game_data):
    odds = 0
    loc = -1.0 * adjusted_diff
    section = min(section, game_data['sections'] - 1)


    #zc.print_dict(game_data['league_db_win_odds'])
    #print ("Loc: %f" % loc)

    if '--debug-wp-calc' in sys.argv: 
        print ("\n------------------------------------------------\nSection: {:.3f}\nGame State: {:.3f}\nAdjusted Diff: {:.3f}\n------------------------------------------------".format(
        section, diff, adjusted_diff
        ))
    if section in [z['game_section'] for z in game_data['league_db_win_odds']]:
        win_odds_data = [z for z in game_data['league_db_win_odds'] if z['game_section'] == section if z['win_odds'] is not None]
        next_val = None
        prior_val = None
        tmp = [z for z in win_odds_data if z['deficit'] > loc]
        if len(tmp) > 0:
            next_val = tmp[0]
        tmp = [z for z in win_odds_data if z['deficit'] < loc]
        if len(tmp) > 0:
            prior_val = tmp[-1]

        #print ("\n\nwin_odds_data")
        #zc.print_dict(win_odds_data)
        #for i, o_ in enumerate(win_odds_row[:-1]):
        
        if next_val is None:
            # There are no games with a higher deficit than this game
            if loc > 0:
                if '--debug-wp-calc' in sys.argv: 
                    print (" no games found with a deficit higher than %.3f in section %d; set WP to 0%%" % (loc, section))
                return 0.0
            else:
                if '--debug-wp-calc' in sys.argv: 
                    print (" [THIS SHOULD NOT HAPPEN] no games found with a deficit lower than %.3f in section %d; set WP to 100%%" % (loc, section))
                return 1.0
        elif prior_val is None:
            # There are no games with a higher deficit than this game
            if loc > 0:
                if '--debug-wp-calc' in sys.argv: 
                    print (" [THIS SHOULD NOT HAPPEN] no games found with a deficit higher than %.3f in section %d; set WP to 0%%" % (loc, section))
                return 0.0
            else:
                if '--debug-wp-calc' in sys.argv: 
                    print (" no games found with a deficit lower than %.3f in section %d; set WP to 100%%" % (loc, section))
                return 1.0
        elif next_val is not None and prior_val is not None:
            #next_val = win_odds_row[i+1]
            #prior_val = win_odds_row[i-1] if i > 0 else None
            
            point = (loc - prior_val['deficit'])

            #print ("\nNext Val"); zc.print_dict(next_val)
            #print ("\nPrior Val"); zc.print_dict(prior_val)

            try:
                
                odds = (next_val['win_odds'] - prior_val['win_odds'])*point + prior_val['win_odds']
                if '--debug-wp-calc' in sys.argv: 
                    print ("\t{:<25}{:<25}{:<25}{:<25}{:<25}".format("adj Diff: %.3f" % loc, "next odds: %.3f" % next_val['win_odds'], "prior odds: %.3f" % prior_val['win_odds'], "point: %.3f" % float(point), "odds: %.3f" % float(odds)))
            except ValueError:
                print("In Get Adj Odds: Error converting adjusted_diff: %s, prior_val: %s, next_val: %s, o:%s, loc:%s" % (adjusted_diff, prior_val, next_val, o, loc))
                print("\tSection: %d" % (section))
                print("\tPoint: %.3f-%.3f=%.3f" % (loc, i, point))
                print("\tLoc: %d" % (loc))
                zc.exit("laxref0019")
            return odds
            
         
        return -1
    else:
        return  -1


def get_box_score_positions(html):
    #Prepare data
    regexes = []
    regexes.append({'regex': re.compile(r'(<td[^\>]*?>(?:<a[^>]*?>)?([^>]*?)(?:</a>)?</td><td[^>]*?>([A-Z])</td>)')})
    html = "".join([z.strip() for z in html.split("\n") if z.strip() != ""])



    res = []
    for r in regexes:
        matches = [{'html': z[0], 'player': z[1], 'position': z[2]} for z in re.findall(r['regex'], html)]

        for m in matches:

            if "," in m['player']:
                tokens = [z.strip() for z in m['player'].split(",") if z.strip() != ""]
                tokens = tokens[-1].split(" ") + tokens[0].split(" ")
                m['player'] = " ".join(tokens)
            m['player_hash'] = hash_player_name(m['player'])
            if m['player_hash'] not in [z['player_hash'] for z in res]:
                res.append({'player_hash': m['player_hash'], 'position': m['position']})

    return res

def convert_pct_complete_to_time_str(pct_complete, year, league="NCAA D1 Men"):
    quarter_str = ""; minute_str = ""; second_str = ""
    time_str = ""
    if pct_complete == 1.0:
        time_str = "End-of-Reg"
    else:
        if league in ["NCAA D1 Men", "NCAA D2 Men", "NCAA D3 Men"]:
            if pct_complete < 1.0:
                quarter = int((pct_complete)/.25 + 1)
                quarter_str = "Q%d" % quarter
                seconds_elapsed = pct_complete * 3600.0
                minutes_elapsed = int(seconds_elapsed / 60)
                minutes_left = 15 - minutes_elapsed%15
                seconds_left = 60 - int(seconds_elapsed)%60 if seconds_elapsed%900 > 0 else 0
                if int(seconds_left) == 60:
                    seconds_left = 0

                elif int(seconds_left) > 0:
                    minutes_left -= 1

                minute_str = "%d" % minutes_left
                second_str = "%02d" % seconds_left
            else:
                quarter = int((pct_complete-1.0)/.06666666666666666666666666666666 + 1) + 4
                quarter_str = "%dOT" % (quarter-4) if quarter > 5 else "OT"
                seconds_elapsed = pct_complete * 3600.0
                minutes_elapsed = int(seconds_elapsed / 60)
                minutes_left = 4 - (minutes_elapsed-60)%4
                seconds_left = 60 - int(seconds_elapsed)%60 if (seconds_elapsed-3600)%240 > 0 else 0
                if int(seconds_left) == 60:
                    seconds_left = 0

                elif int(seconds_left) > 0:
                    minutes_left -= 1

                minute_str = "%d" % minutes_left
                second_str = "%02d" % seconds_left

        elif league in ["NCAA D1 Women", "NCAA D2 Women", "NCAA D3 Women"]:
            if pct_complete < 1.0:
                if year in [2022] or year > 2022:
                    quarter = int((pct_complete)/.25 + 1)
                    quarter_str = "Q%d" % quarter
                    seconds_elapsed = pct_complete * 3600.0
                    minutes_elapsed = int(seconds_elapsed / 60)
                    minutes_left = 15 - minutes_elapsed%15
                else:
                    quarter = int((pct_complete)/.50 + 1)
                    quarter_str = "H%d" % quarter
                    seconds_elapsed = pct_complete * 3600.0
                    minutes_elapsed = int(seconds_elapsed / 60)
                    minutes_left = 30 - minutes_elapsed%30
                seconds_left = 60 - int(seconds_elapsed)%60 if seconds_elapsed%1800 > 0 else 0
                if int(seconds_left) == 60:
                    seconds_left = 0

                elif int(seconds_left) > 0:
                    minutes_left -= 1

                minute_str = "%d" % minutes_left
                second_str = "%02d" % seconds_left
            else:
                overtime_minutes = 3
                if year in [2018, 2019, 2021, 2022] or year > 2022:
                    overtime_minutes = 6
                quarter = int((pct_complete-1.0)/.06666666666666666666666666666666 + 1) + 2
                quarter_str = "%dOT" % (quarter-3) if quarter > 3 else "OT"
                seconds_elapsed = pct_complete * 3600.0
                minutes_elapsed = int(seconds_elapsed / 60)
                minutes_left = overtime_minutes - (minutes_elapsed-60)%overtime_minutes
                seconds_left = 60 - int(seconds_elapsed)%60 if (seconds_elapsed-3600)%300 > 0 else 0
                if int(seconds_left) == 60:
                    seconds_left = 0

                elif int(seconds_left) > 0:
                    minutes_left -= 1

                minute_str = "%d" % minutes_left
                second_str = "%02d" % seconds_left

        time_str = "%s %s:%s" % (quarter_str, minute_str, second_str)
    if '--time-str-debug' in sys.argv or time_str in [":"]:
        print("\n\nPct Complete: %.3f" % pct_complete)
        print("\tquarter: %d" % quarter)
        print("\tminutes_elapsed: %f" % minutes_elapsed)
        print("\tseconds_elapsed: %f" % seconds_elapsed)
        print("\tminutes_left: %f" % minutes_left)
        print("\tseconds_left: %f" % seconds_left)
        print("(%s) Time str: %s" % (league, time_str))

    return time_str


def get_team_colors(cursor):
    cursor.execute("Select name, IFNULL(fg_color, '(255,255,255,255)'), IFNULL(bg_color, '(0,0,0,255)'), ID from LaxRef_Teams where active=1")
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'Team': r[0],'TeamID': r[3],'fg_color': r[1],'bg_color': r[2]})
    return results


def get_season_value(cursor, year, team):
    query = "SELECT team, url_week, votes from LaxRef_Rankings where team=%s and year=%s and active=1 order by week asc"
    param = [team, year - 2000]
    cursor.execute(query, param)
    res = cursor.fetchall()
    exponential = 1
    inc = .08
    total_season_value = 0
    for r in res:
        total_season_value += r[2] * exponential
        exponential *= (1 + inc)

    return total_season_value

def get_team_url(cursor):
    cursor.execute("Select name, IL_url, ID from LaxRef_Teams where active=1")
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'Team': r[0],'url': r[1], 'TeamID': r[2]})
    return results

def get_team_conference(cursor, yr=datetime.now().year):
    cursor.execute("Select a.name, c.name conference, b.league, a.ID from LaxRef_Teams a, LaxRef_Team_Seasons b, LaxRef_Conferences c where a.ID=b.conference_ID and a.active and b.active and b.team_ID=a.ID and b.year=%s", [yr])
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'Team': r[0],'conference': r[1],'league': r[2], 'TeamID': r[3]})
    return results

def get_team_LR_post_IDs(cursor):
    cursor.execute("Select name, laxref_post_ID, ID from LaxRef_Teams where active=1")
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'Team': r[0],'post_ID': r[1], 'TeamID': r[2]})
    return results

def get_team_LR_team_urls(cursor):
    cursor.execute("Select name, laxref_team_url, ID from LaxRef_Teams where active=1")
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'Team': r[0],'url': r[1], 'TeamID': r[2]})
    return results

def get_team_elo(cursor, year=datetime.now().year):
    cursor.execute("Select a.name, b.elo_rating, a.display_name, a.ID from LaxRef_Teams a, LaxRef_Team_Seasons b where a.ID=b.team_ID and year=%s and a.active=1", [year])
    results = []
    res = cursor.fetchall()
    for r in res:
        results.append({'Team': r[0],'elo': r[1],'display_name': r[2], 'TeamID': r[3]})
    return results



def write_game_recap(game):
    # things to have in a recap
    """

    1. Stand out players - based on EGA
    2. Decisive stretch of the game
        2a. Scoring droughts
    3. Streaks (if relevant)
    4. Goalie stats
    5. Location/Weather
    6. Coming in to this game...
    7. Up next for each team
    8. ELO preview (what did ELO expect)
    9. Strength of Record results if interesting
    10. Conference record/standings as a result of this one
    11. If later in the season, what sort of selection day impact did the game have?
    12. Shot clock impacts
    13. Face-off impacts


    """
    game['recap_plain_text'] = "TBD"
    game['recap_html'] = "TBD"

    recap = {'intro': None, 'img': None, 'sections': []}
    recap['img'] = "<!--div id='img_div'></div-->"


    recap['intro'] = {'body': 'Two teams met on a field.'}
    recap['intro']['body'] = "<div id='intro_div'>%s</div>" % recap['intro']['body']

    basic_recap = {'heading': 'The game was played', 'body': 'And someone won it...'}
    recap['sections'].append(basic_recap)

    recap['sections'].append({'heading': 'The team scored goals.', 'body': 'Because they scored more goals, they won.'})

    game['recap_html'] = "%s\n\n\n%s\n\n\n%s" % (recap['intro']['body'], recap['img'], "\n\n\n\n".join(["<h3 id='section%d'>%s</h3>\n\n<div>%s</div>" % (i+1, z['heading'], z['body']) for i, z in enumerate(recap['sections'])]))

    print ("\n\nRecap:\n-----------------------------------\n%s\n\n" % game['recap_html'])

    return game


def add_player_stats_to_game_dict(game):
    stars = []
    

    if '--test-star-IDs' in sys.argv:
        zc.print_dict(game['home_team']['players'][0])
        
        #zc.exit("STAR IDs TEST")

    for itz, team in enumerate([game['home_team'], game['away_team']]):
        #print "\n\n%s stars"% team['confirmed_team']

        lookup_tmp_confirmed_home = game['home_team']['confirmed_team'].upper() if game['home_team']['confirmed_team'] is not None else "[NONE]"
        lookup_tmp_confirmed_away = game['away_team']['confirmed_team'].upper() if game['away_team']['confirmed_team'] is not None else "[NONE]"
        lookup_tmp_alt_home_team = game['alt_home_team'].upper() if game['alt_home_team'] is not None else "[NONE]"
        lookup_tmp_alt_away_team = game['alt_away_team'].upper() if game['alt_away_team'] is not None else "[NONE]"
        lookup_tmp_home_team_name = game['home_team_name'].upper() if game['home_team_name'] is not None else "[NONE]"
        lookup_tmp_away_team_name = game['away_team_name'].upper() if game['away_team_name'] is not None else "[NONE]"
        tmp_star_players = [z for z in team['players'] if z['player'].upper() not in [lookup_tmp_confirmed_home, lookup_tmp_confirmed_away, lookup_tmp_alt_home_team, lookup_tmp_alt_away_team, lookup_tmp_home_team_name, lookup_tmp_away_team_name]]
        
        total_cnt = 0.
        for player in tmp_star_players:
            total_cnt += sum([1. for z in player['play_log']])
        for ife, player in enumerate(tmp_star_players):
            star = {}
            star['goals_added_by_quarter'] = player['EGA_by_quarter'][0:3]+[sum(player['EGA_by_quarter'][3:])]
            star['assists'] = len([1 for z in player['play_log'] if z['play_type'] == "Assist"])
            star['shots'] = len([1 for z in player['play_log'] if z['play_type'].endswith("Goal") or z['play_type'].endswith("Shot")])
            star['goals'] = len([1 for z in player['play_log'] if z['play_type'].endswith("Goal")])
            star['gbs'] = len([1 for z in player['play_log'] if z['play_type'] == "Ground Ball"])
            star['tos'] = len([1 for z in player['play_log'] if z['play_type'].endswith("Turnover")and z['play_type'] != "Caused Turnover"])
            star['fo'] = len([1 for z in player['play_log'] if z['play_type'].endswith("Faceoff Win")])
            star['cnt'] = sum([1. for z in player['play_log']])
            player['n_shots'] = star['shots']
            player['cnt'] = star['cnt']
            player['n_goals'] = star['goals']
            player['n_assists'] = star['assists']
            player['n_gbs'] = star['gbs']
            player['n_tos'] = star['tos']
            player['n_fo'] = star['fo']
            star['team_play_shares'] = star['cnt'] / total_cnt if total_cnt > 0 else None
            star['goals_added'] = player['EGA']
            star['uaEGA'] = None
            if star['team_play_shares'] is not None and star['team_play_shares'] > 0:
                star['uaEGA'] = star['goals_added'] / star['team_play_shares'] * .05
            star['player'] = player['player']
            star['team'] = team['confirmed_team']
            star['team_ID'] = team['ID']
            star['player_ID'] = None if 'ID' not in player else player['ID']
            if '--test-star-IDs' in sys.argv:
                print ("wpqs; {:<40}{:<10}{:>10}".format(player['player'], star['player_ID'], "%.2f" % player['EGA']))
            stars.append(star)
        
    ended = time.time()

    if '--test-star-IDs' in sys.argv:
        zc.exit("STAR IDs TEST")
        
    game['player_summaries'] = stars
    
    return game
    
def get_all_team_elo_ratings(teams, date, src=None):

    elos = [{'display_name': z['display_name'], 'ID': z['ID'], 'starting_elo': None, 'ending_elo': None} for z in teams]
    for e in elos:
        path = os.path.join(os.path.join(lr_fldr, 'Post_021', 'Teams', "team%04d_2015_%d_ELO_Rating.csv" % (e['ID'], datetime.now().year -2000)))
        #print "Look up the data in path: %s" % path
        if os.path.isfile(path):
            lines = list(filter(None, open(path, 'r').read().split("\n")))[1:]

            if date in [l.split(",")[0].replace(" 00:00:00", "") for l in lines]:

                date_id = [l.split(",")[0].replace(" 00:00:00", "") for l in lines].index(date)
                e['starting_elo'] = int(lines[date_id].split(",")[1])
                e['ending_elo'] = int(lines[date_id].split(",")[2])
            else:
                max_date = datetime.strptime(lines[-1].split(",")[0], "%Y-%m-%d %H:%M:%S")
                if isinstance(date, str):
                    date = datetime.strptime(date, "%Y-%m-%d")
                #if date > max_date: # If it's a game in the future
                #    print("That is in the future")
                #    print("ELO is %d" % int(lines[-1].split(",")[2]))
                e['starting_elo'] = int(lines[-1].split(",")[1])
                e['ending_elo'] = int(lines[-1].split(",")[2])

        else:

            if src is None:

                err_msg = (" ELO File missing : %s\n\nSrc unknown..." % path)
            else:

                err_msg = (" In %s, ELO File missing : %s" % (src, path))
            zc.send_telegram(err_msg, bot_token)
            e['starting_elo'] = "???"
            e['ending_elo'] = "???"

    return elos

def get_recent_games(days_back=7, cursor=None):
    reconnect = False
    if cursor is None:
        reconnect = True
        mysql_conn, cursor = zc.mysql_connect()
    cutoff_date = datetime.today() - datetime.timedelta(days=days_back)

    query = "SELECT ID, confirmed_home_team, home_score, confirmed_away_team, away_score, game_date from LaxRef_Games where status like 'complete%%' and active=1 and game_type != 'Non-Division' and game_date>=STR_TO_DATE(%s, '%%Y-%%m-%%d %%H:%%i:%%s')"
    print("Query %s" % (query))
    param = [cutoff_date.strftime("%Y-%m-%d %H:%M:%S")]
    cursor.execute(query, param)
    res = cursor.fetchall()
    games = []
    for r in res:
        g = {'home': r[1], 'home_score': r[2], 'away': r[3], 'away_score': r[4], 'ID': r[0], 'date': r[5].strftime("%a %b %d"), 'date_val': r[5]}
        games.append(g)
    games = sorted(games, key=lambda x:x['date_val'], reverse=True)

    if reconnect:
        cursor.close(); mysql_conn.close()
    return games

def get_LR_scoreboard_games(today_dt, use_ideal, show_links=False):
    #print (today_dt)


    # Fill each machine
    machines = json.loads(open(os.path.join(lr_fldr, "Logs", "liveStatsMachines.json"), 'r').read())
    machines = sorted([z for z in machines if z['active']], key=lambda x:x['seq'])
    for m in machines:
        if 'latest_end_hour' not in m:
            m['latest_end_hour'] = None
        if 'max_games' not in m:
            m['max_games'] = 10
            
    cursor = zc.zcursor("LR")
    db_games = cursor.dqr("SELECT a.ID, b.ID 'gs_ID', IFNULL(b.url, '') 'url', b.auto_tweet, b.auto_final, b.auto_reddit, b.neutral_site, a.tournament_slot_ID, a.status, b.game_file, b.assigned_to, a.game_date, e.elo_rating 'home_elo', f.elo_rating 'away_elo', e.schedule_url 'home_schedule_url', f.schedule_url 'away_schedule_url', c.display_name 'display_home', d.display_name 'display_away', lax_power_url, bitly_link, a.league, IFNULL(e.PRO_customer, 0) home_is_PRO_customer, IFNULL(f.PRO_customer, 0) away_is_PRO_customer from LaxRef_Games a, LaxRef_Game_Streams b, LaxRef_Teams c, LaxRef_Teams d, LaxRef_Team_Seasons e, LaxRef_Team_Seasons f where a.zgame_year=%s and (e.league like 'NCAA%%' and f.league like 'NCAA%%') and c.ID=e.team_ID and d.ID=f.team_ID and e.year=f.year and e.year=YEAR(a.game_date) and a.home_ID=c.ID and a.away_ID=d.ID and b.active and b.game_ID=a.ID and DATE(a.game_date)=%s and a.active order by a.game_date asc", [today_dt.year, today_dt.strftime("%Y-%m-%d")])
    db_live_games = cursor.dqr("SELECT a.ID, b.ID 'live_ID', b.home_score, b.away_score, b.plays_uploaded, b.reddit_summary, b.last_update, b.pct_complete from LaxRef_Games a, LaxRef_Active_Live_WP_Games b where a.zgame_year=%s and b.active and b.game_ID=a.ID and DATE(a.game_date)=%s and a.active order by game_date asc", [today_dt.year, today_dt.strftime("%Y-%m-%d")])
    cursor.close()

    
    for i, game in enumerate(db_games):
        game['live'] = None
        game['assigned'] = 0
        if game['ID'] in [z['ID'] for z in db_live_games]:
            game['live'] = db_live_games[ [z['ID'] for z in db_live_games].index(game['ID']) ]
        game['total_elo'] = game['home_elo'] + game['away_elo']
        if game['league'] == "NCAA D1 Men":
            game['total_elo'] *= 1.5
        elif game['league'] in ["NCAA D1 Women"]:
            game['total_elo'] *= 1.4
        elif game['league'] in ["NCAA D3 Men"]:
            game['total_elo'] *= 1.0
        else:
            game['total_elo'] *= .6
            
        game['PRO_Customer'] = game['home_is_PRO_customer'] or game['away_is_PRO_customer']
        
        game['score'] = game['total_elo'] + game['PRO_Customer'] * 2000.
        game['window'] = None
    
    windows = {'game_windows': [{'machine': None, 'machine_seq': None, 'ID': z, 'games_per_half_hour': [0.]*48, 'game_IDs': [], 'first_dt': None} for z in range(60)], 'game_window': 0, 'last_time': None}
    
    db_games = sorted(db_games, key=lambda x:x['score'], reverse=True)
    
    for i, m in enumerate(machines):
    
        if use_ideal:
            limit_tag = 'ideal_parallel_games'
        else:
            limit_tag = 'max_parallel_games'
            
        # Every machine has a different limit in terms of the number of games that can be processed; set limit to that value for the given machine, and distinguish between whether we are trying to make it ideal or whether we are needing to accomodate more games/volume    
        m['game_windows'] = [{'max_concurrent_games': None, 'machine_seq': z, 'seq': z, 'ID': z, 'games_added': 0, 'max_games_per_execution': m['max_games'], 'games_per_window_limit': m[limit_tag], 'games_per_half_hour': [0.]*48, 'game_IDs': [], 'wait_until': None, 'starts': None, 'ends': None} for z in range(0,m['n_windows'])]
        m['last_time'] = None
    
    n_machines = len(machines)
    for i, game in enumerate(db_games):

        cur_machine = 0; cur_window = 0;
        
        half_hour = (game['game_date'].hour * 2 + game['game_date'].minute / 30)
        end_hour = game['game_date'].hour + 2

        if 'complete' not in game['status']:
            
            # For each game, cycle through the available machines and their game_windows (i.e. an execution of live_win_odds.py) and try to find a slot for the game withing the limits ideal or maximal. If you can't, the game will remain unassigned
            while cur_machine < n_machines:
                machine = machines[cur_machine]
                
                if machine['latest_end_hour'] is None or end_hour < machine['latest_end_hour']:
                    for tmp_window in machine['game_windows']:
                    
                    
                        passed = True
                        # 5 because we assume games are 2.5 hours; and we have each time window equaling 30 minutes
                        for iw in range(5):
                            if tmp_window['games_per_half_hour'][min(47, int(iw + half_hour))] + 1 > tmp_window['games_per_window_limit']:
                                passed=False
                                break
                        if passed:
                            for iw in range(5):
                                tmp_window['games_per_half_hour'][min(47, int(iw + half_hour))] += 1
                                if tmp_window['max_concurrent_games'] is None or tmp_window['max_concurrent_games'] < tmp_window['games_per_half_hour'][min(47, int(iw + half_hour))]:
                                    tmp_window['max_concurrent_games'] = tmp_window['games_per_half_hour'][min(47, int(iw + half_hour))]
                            #print game['game_date'], half_hour, w, tmp_window['games_per_half_hour'][half_hour:half_hour + 5]
                            if tmp_window['starts'] is None or tmp_window['starts'] > game['game_date']:
                                tmp_window['starts'] = game['game_date']
                            
                            if tmp_window['ends'] is None or tmp_window['ends'] < (game['game_date'] + timedelta(seconds=2.5*3600.)):
                                tmp_window['ends'] = (game['game_date'] + timedelta(seconds=2.5*3600.))
         
                            
                            if tmp_window['games_added'] < tmp_window['max_games_per_execution']:
                                tmp_window['game_IDs'].append(game['ID'])
                                tmp_window['games_added'] = len(tmp_window['game_IDs'])
                                game['window'] = tmp_window['seq']
                                game['assigned'] = 1
                            
                                break
                     
                cur_machine += 1        
                if game['assigned']:
                    break
                
        game['league_tag'] = 'MLAX' if game['league'] == "NCAA D1 Men" else "WLAX"
        game['status_str'] = ("FINAL (ID #%d - %s)" % (game['ID'], game['league_tag'])) if "complete" in game['status'] else "%s (ID #%d - %s)" % (game['game_date'].strftime("%I:%M %p").replace(" 0", " "), game['ID'], game['league_tag'])
        if game['status_str'].startswith("0"): game['status_str'] = game['status_str'][1:]

        game['team1score'] = "" if game['live'] is None else game['live']['away_score']
        game['team2score'] = "" if game['live'] is None else game['live']['home_score']
        game['display_team1'] = game['display_away']
        game['display_team2'] = game['display_home']
        game['final'] = 1 if "complete" in game['status'] else 0

        game['in_db'] = "YES!" if "complete" in game['status'] else "No"
        game['dt'] = today_dt.strftime("%Y%m%d")
        game['populate'] = "yes"
        game['game_time_str'] = game['game_date'].strftime("%I:%M %p") if game['game_date'] is not None else ""
        game['more_style'] = "background-color: #FFF; color: #000;" if game['url'] in ["", None, 'None'] else ("background-color: #FF0; color: #000;" if game['url'] in ["", None, 'None'] else "background-color: #0F0; color: #FFF;")

        game['auto_reddit'] = '' if game['auto_reddit'] in [0, '', None, 'None'] else "checked"
        game['neutral_site'] = '' if game['neutral_site'] in [0, '', None, 'None'] else "checked"


        if game['url'] is not None and (len(game['url'].split(" ")) > 1 or "|" in game['url'] or "statbroadcast.com/events" in game['url']):
            game['more_style'] = "background-color: #F00; color: #FFF;"

        if game['live'] is not None:
            wp_obj = game['live']
            game['wp_link'] = "https://lacrossereference.com/game-win-probabilities/%s/?utm_source=Social&utm_content=ztclaxpower" % game['game_file']
            game['plays_uploaded'] = wp_obj['plays_uploaded']
            game['pct_complete'] = wp_obj['pct_complete']
            game['last_update'] = wp_obj['last_update']
            if game['last_update'] is not None and (time.time() - game['last_update']) > 60 and game['pct_complete'] is not None and game['pct_complete'] > .97:
                game['final'] = True
            game['reddit_summaries'] = [z.replace("\n", "<br>") for z in wp_obj['reddit_summary'].split("|")] if wp_obj['reddit_summary'] is not None else []

            if show_links:
                try:
                    game['wp_link'] = goo_shorten_url(game['wp_link'])
                except Exception:
                    pass
        game['tweet_command'] = None
        tmp_url = game['url']
        if tmp_url is not None and "&" in tmp_url:
            tmp_url = tmp_url.split("&")[0]

        if "complete" not in game['status']:
            game['command'] = 'python live_win_odds.py --game-ID %d -upload --include-top-stars --goal-viz-tes' % (game['ID'])
            if game['auto_tweet'] == 1:
                game['tweet_command'] = 'python live_win_odds_tweeter.py --game-ID %d --testing-auto-start' % (game['ID'])
        else:
            game['command'] = 'python live_win_odds.py --game-ID %d -upload -url "%s" --include-top-stars--goal-viz-tes --use-db-plays' % (game['ID'], tmp_url)


    unassigned = [z for z in db_games if not z['assigned']]
    if not use_ideal and len(unassigned) > 0:
        
        zc.print_dict(unassigned)
        print ("%d games are unassigned" % len(unassigned))
        m = machines[-1]
        
        tmp_list = [z['ends'] for z in m['game_windows'] if z['ends'] is not None]
        
        if len(tmp_list) > 0:
            tmp = min(tmp_list)
            starts = tmp + timedelta(minutes=90)
        else:
            starts = datetime.now() + timedelta(minutes=60)
        
        gw = {'max_concurrent_games': len(unassigned), 'machine_seq': 99, 'seq': 99, 'ID': 99, 'games_added': 0, 'max_games_per_execution': m['max_games'], 'games_per_window_limit': m[limit_tag], 'games_per_half_hour': [0.]*48, 'game_IDs': [z['ID'] for z in unassigned], 'wait_until': starts.strftime("%H:%M"), 'starts': None, 'ends': None}
        
        gw['starts'] = min([game['game_date'] for game in unassigned])
        gw['ends'] = gw['starts'] + timedelta(seconds=3600.*2.5)
        
        m['game_windows'].append(gw)
        
    db_games = sorted(db_games, key=lambda x:x['game_date'])
    captured_cnt = sum([1 for z in db_games if 'complete' in z['status']])
    final_cnt = sum([1 for z in db_games if "completed" in z['status']])

    commands = "Commands..."

    windows['game_windows'] = [z for z in windows['game_windows'] if len(z['game_IDs']) > 0]
    for g in windows['game_windows']:

        g['command'] = "python live_win_odds.py --game-ID \"%s\" --start-at \"%s\"" % ("|".join(map(str, g['game_IDs'])), (g['first_dt']-timedelta(seconds=1200)).strftime("%H:%M"))
    windows['commands'] = "<BR>".join([z['command'] for z in windows['game_windows']])
    
    
    #zc.print_dict(game_windows)
    return db_games, captured_cnt, final_cnt, [windows], machines
    
def xor(a, b):
    if a and not b:
        return 1
    elif not a and b:
        return 1
    else:
        return 0
        
def rule_30(specs):
    import time, PIL
    from PIL import Image
    lrp_fldr = os.path.join(lr_fldr, "LRP", "LRP_flask")
    sys.path.insert(0, lrp_fldr)
    #import zacks_graphics
    #from zacks_graphics import PIL_test, SITE_BLUE, SITE_GREEN, standalone_PIL_add_image
    zc.print_dict(specs)
    
    final_w = specs['width']*2
    final_h = specs['height']
    
    args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-o', specs['fname'], '-notrim', '-topmargin', "0", '-text', '', '-font', 'Oswald', '-fontsize', '12', '-fontcolor', '(40,40,40,255)', '-fillcolor', '(255,255,255,255)', '-y', "%d" % (final_h), '-x', '%d' % (specs['width'])]
    proc = subprocess.Popen(args, stdout=subprocess.PIPE); time.sleep(1)
    
    cutout_w = specs['width'] * .60; cutout_h = cutout_w / 1.61803398875
    if 'cutout-width' in specs:
        cutout_w = specs['cutout-width']
    cutout_w_border = (specs['width'] - cutout_w)/2.
    cutout_h_border = (final_h - cutout_h)/2.
    
    
    
    title_pixels = None
    title_font = 36
    title_bits = None
    
    
    if 'title' in specs:
        if len(specs['title']) > 24: 
            title_font = 22
        elif len(specs['title']) > 18: 
            title_font = 28
            
        if 'title-font' in specs:
            title_font = specs['title-font']
        fg_color = '(%s,255)' % specs['fg_color'] if 'fg_color' in specs else '(24,154,211,255)'
        args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-o', "rule30_title.png", '-notrim', '-center', '-topmargin', "0", '-text', specs['title'], '-font', 'Oswald', '-fontsize', "%d" % title_font, '-fontcolor', fg_color, '-fillcolor', '(255,255,255,255)', '-y', "%d" % (cutout_h/3), '-x', '%d' % (cutout_w - 20)]
        print (args)
        proc = subprocess.Popen(args, stdout=subprocess.PIPE); time.sleep(1.5)
        img = Image.open("rule30_title.png")
        title_pixels = img.load()
        title_w, title_h = img.size
        title_bits = [[None] * title_w for z in range(title_h)]
        for a in range(title_h):
            for b in range(title_w):
                title_bits[a][b] = title_pixels[b, a]

    fg_color = '(%s,255)' % specs['fg_color'] if 'fg_color' in specs else '(24,154,211,255)'
    sub_title_rh = title_font * 5 / 6
    sub_title_font = title_font * 2 / 3
    subtitle_pixels = None
    if 'sub_title' in specs and specs['sub_title'] is not None:
        
        print ("sub y", cutout_h, cutout_h*2/3, cutout_h*8/10)
        args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-o', "rule30_sub_title.png", '-notrim', '-center', '-topmargin', "0", '-text', specs['sub_title'], '-rowheight', '%d' % sub_title_rh, '-font', 'Oswald', '-fontsize', '%d' % sub_title_font, '-fontcolor', fg_color, '-fillcolor', '(255,255,255,255)', '-y', "%d" % (185), '-x', '%d' % (cutout_w - 40)]
        print (args)
        proc = subprocess.Popen(args, stdout=subprocess.PIPE); time.sleep(1.5)
        img = Image.open("rule30_sub_title.png")
        subtitle_pixels = img.load()
        subtitle_w, subtitle_h = img.size
        subtitle_bits = [[None] * subtitle_w for z in range(subtitle_h)]
        for a in range(subtitle_h):
            for b in range(subtitle_w):
                subtitle_bits[a][b] = subtitle_pixels[b, a]

    
    img = Image.open(specs['fname'])
    pixels = img.load()
    width, height = img.size

    bits = [[None] * final_w for z in range(final_h)]
    
    top_i = 0; seed_l = len(specs['seed'])
    print ("Seed: %s" % specs['seed'])
    while top_i < final_w:
        bits[0][top_i] = int(specs['seed'][ top_i % seed_l ])
        top_i += 1
    
    row_h = 1
    while row_h < final_h:
        for a in range(0, final_w):
            if a == 0:
                bits[row_h][a] = 0 # bits[row_h-1][a] or bits[row_h-1][a+1]
            elif a == final_w-1:
                bits[row_h][a] = xor(bits[row_h-1][a-1], bits[row_h-1][a])
            else:
                bits[row_h][a] = xor(bits[row_h-1][a-1], bits[row_h-1][a] or bits[row_h-1][a+1])
                
        row_h += 1
        
    for x in range(final_w):
        all_same = True
        y_loc = final_h - 1
        
        start_bit = bits[y_loc][x]
        
        while y_loc > 1:
            if bits[y_loc-1][x] == start_bit:
                bits[y_loc][x] = 0
            else:
                break
            y_loc -= 1
    
    # Black Border
    for a in range(0, final_h):
        bits[a][int(specs['width'])] = 2
        bits[a][-1] = 2
    for a in range(0, final_w):
        bits[final_h-1][a] = 2
        bits[-1][a] = 2
    
    print ("Final H: {} Height {}".format(final_h, final_h))
    for a in range(0, final_h):
        for b in range(specs['width'], final_w):
            
            b_loc = b - specs['width']
            in_cutout = specs['cutout'] and b_loc > cutout_w_border and b < (final_w - cutout_w_border) and a > cutout_h_border and a < (final_h - cutout_h_border)
            
            if specs['cutout'] and in_cutout:
                pixels[b_loc, final_h - 1 - a] = (255,255,255,255)
            elif bits[a][b] == 1:
                if 'fg_color' not in specs:
                    pixels[b_loc, final_h - 1 - a] = (24, 154, 211, 255)
                else:
                    tokens = [int(z) for z in fg_color[1:-1].split(",")]
                    pixels[b_loc, final_h - 1 - a] = (tokens[0], tokens[1], tokens[2], tokens[3])
            elif bits[a][b] == 2:
                pixels[b_loc, final_h - 1 - a] = (128,128,128,255)

            elif bits[a][b] == 0:
                pixels[b_loc, final_h - 1 - a] = (255,255,255,255)
    
    
    if title_bits is not None:
        title_offset = cutout_h * .45;
        if 'sub_title' in specs and specs['sub_title'] is not None:
            if subtitle_bits is not None:
                title_offset -= cutout_h * .35
        for a in range(0, title_h):
            for b in range(0, title_w):
                pixels[cutout_w_border + b + 10, cutout_h_border + a + title_offset] = title_bits[a][b]
    
    if 'sub_title' in specs and specs['sub_title'] is not None:
        if subtitle_bits is not None:
            
            subtitle_offset = cutout_h * .55;
            if '--subtitle-offset-pct' in sys.argv:
                subtitle_offset = cutout_h * float(sys.argv[sys.argv.index('--subtitle-offset-pct') + 1])
            for a in range(0, subtitle_h):
                for b in range(0, subtitle_w):
                    if cutout_h_border + a + subtitle_offset < final_h - cutout_h_border:
                        pixels[cutout_w_border + b + 20, cutout_h_border + a + subtitle_offset] = subtitle_bits[a][b]
          
    
    if 'team_ID_for_logo' in specs and specs['team_ID_for_logo'] is not None:
        spec = {'just_non_white': 1, 'TeamLogos_src': specs['gif_path'], 'width': 55, 'height': 55, 'x': specs['logo_x_loc'], 'y': specs['logo_y_loc']}
        img, error_msg = standalone_PIL_add_image(img, "", spec, specs)
        print ("error_msg: %s" % error_msg)
                    
    img.save(specs['fname'])
        
def PIL_rule_30(specs):
    import time, PIL
    from PIL import Image, ImageDraw
    lrp_fldr = os.path.join(lr_fldr, "LRP", "LRP_flask")
    sys.path.insert(0, lrp_fldr)
    import main
    import zacks_graphics
    from zacks_graphics import PIL_add_text, PIL_setup_specs, PIL_load_template, SITE_BLUE
    from zacks_graphics import PIL_add_text_box
    from zacks_graphics import PIL_add_image
    from zacks_graphics import PIL_get_text_size, PIL_draw_line
    from zacks_graphics import get_font
    #from zacks_graphics import SITE_BLUE, SITE_GREEN
    #from zacks_graphics import PIL_add_text_box, PIL_add_text
    zc.print_dict(specs)
    
    final_w = specs['width']*2
    final_h = specs['height']
    
    specs['primary_color'] = (255,221,0); specs['alt_color'] = (1,83,155)
    
    
    #args = ['python', os.path.join(zc_fldr, 'draw_text_header.py'), '-o', specs['fname'], '-notrim', '-topmargin', "0", '-text', '', '-font', 'Oswald', '-fontsize', '12', '-fontcolor', '(40,40,40,255)', '-fillcolor', '(255,255,255,255)', '-y', "%d" % (final_h), '-x', '%d' % (specs['width'])]
    #proc = subprocess.Popen(args, stdout=subprocess.PIPE); time.sleep(1)
    
    cutout_w = specs['width'] * .60; cutout_h = cutout_w / 1.61803398875
    if 'cutout-width' in specs:
        cutout_w = specs['cutout-width']
    cutout_w_border = (specs['width'] - cutout_w)/2.
    cutout_h_border = (final_h - cutout_h)/2.
    
    
    title_font = 36
    
    
    #im = Image.open(specs['template'])
    #pixels = im.load()
    
    error_msg = ""; log_msg = ""

    specs, log_msg, error_msg = PIL_setup_specs(specs, log_msg, error_msg)
    im, log_msg, error_msg, specs = PIL_load_template(specs, log_msg, error_msg)
    draw = ImageDraw.Draw(im)
    width, height = im.size
    specs['width'] = width; specs['height'] = height
    spec = {'text': "", 'anchor': 'end', 'calc': 'fit-inside', 'length': width - 60, 'height': height - 140, 'start_fs': 36, 'bg_color': (255,255,255), 'fg_color': (255, 255, 255), 'x': 30, 'y': 70}
    im, error_msg = PIL_add_text_box(im, error_msg, spec, specs)
    
    
    text = specs['title']
    spec = {'text': text, 'font-style': 'bold', 'start_fs': 120, 'anchor': "middle", 'calc': 'fit-inside', 'length': specs['width']-60, 'fg_color': SITE_BLUE, 'x': 30, 'y': 75, 'text-border': 2}
    im, fs, error_msg = PIL_add_text(im, error_msg, spec, specs)
    length, headline_height = draw.textsize(text, font=get_font(specs['font_src_%s_oswald' % spec['font-style']], fs))
    
    
    text = specs['sub_title']
    spec = {'text': text, 'font-style': 'regular', 'start_fs': 36, 'anchor': "middle", 'calc': 'fit-inside', 'length': specs['width']-60, 'fg_color': SITE_BLUE, 'x': 30, 'y': height - 60 - 90, 'text-border': 2}
    im, fs, error_msg = PIL_add_text(im, error_msg, spec, specs)
    length, headline_height = draw.textsize(text, font=get_font(specs['font_src_%s_oswald' % spec['font-style']], fs))
            
                    
    im.save(specs['fname'])
    
    if 'top_bucket' in specs:
        upload_file_obj = {'top_bucket': specs['top_bucket'], 'src': specs['fname'], 'fname': specs['fname'].split("\\")[-1], 'target_folder': specs['upload_folder']}
        upload_file(upload_file_obj)
        
def player_name_to_slug(player, seed, specs=None):
    slug = zc.remove_non_ascii(player.replace("'", "").replace("-", "").replace(" ", "-").replace("\t", "-").lower().strip())
    
    chars = [chr(z) for z in range(97, 97+26)]  + ["-"]
    remove_chars = ['&', '*', '/', '.', "_", ':', '#', ';', ',', '~', '{', '}', '?', '|', '[', ']', '(', ')'] + ["%d" % z for z in range(10)]
    slug = "".join([z for z in slug if z not in remove_chars and ord(z) > 32])
    
    if len([z for z in slug if z not in chars]) > 0:
        if specs is None:
            msg = "Error in creating a slug for %s, found an unexpected character: ord=%d" % (player, ord([z for z in slug if z not in chars][0]))
        else:
            msg = "Error in creating a slug for %s in game ID %d, found an unexpected character: ord=%d" % (player, specs['game_ID'], ord([z for z in slug if z not in chars][0]))
            cursor = zc.zcursor("LR")
            data = cursor.dqr("Select a.log_url, a.ID game_ID, a.game_date from LaxRef_Games a where a.active and a.ID=%s", [specs['game_ID']])[0]
            cursor.close()
            
            msg += "\n\nGame ID: %d" % data['game_ID']
            msg += "\nLog URL: %s" % data['log_url']
            msg += "\nGame DB Record: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % data['game_ID']
            msg += "\nDB Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % data['game_ID']
            msg += "\nAdmin_cockpit: https://pro.lacrossereference.com/admin_cockpit?dt=%s&game_ID=%d" % (data['game_date'].strftime("%Y%m%d"), data['game_ID'])
        print (msg)
        script_name = __file__.replace(".py", "").split("\\")[-1]; record_script_completion(script_name, success=False)
        zc.send_crash(msg, bot_token); zc.exit("laxref0021")
    
    random.seed(seed)
    slug += "-%03d" % (random.random() * 1000)
    random.seed(seed + 568)
    slug += "%03d" % (random.random() * 1000)
    
    return slug
    
def game_to_slug(home, away, seed, specs=None):
    home_slug = zc.remove_non_ascii(home.replace("'", "").replace("-", "").replace(" ", "-").replace("\t", "-").lower().strip())
    away_slug = zc.remove_non_ascii(away.replace("'", "").replace("-", "").replace(" ", "-").replace("\t", "-").lower().strip())
    if home_slug < away_slug:
        slug = "%s-%s" % (home_slug, away_slug)
    else:
        slug = "%s-%s" % (away_slug, home_slug)
        
    chars = [chr(z) for z in range(97, 97+26)]  + ["-"]
    remove_chars = ['&', '.', "_", ':', '#', ';', ',', '~', '{', '}', '?', '|', '[', ']', '(', ')'] + ["%d" % z for z in range(10)]
    slug = "".join([z for z in slug if z not in remove_chars and ord(z) > 32])
    
    if len([z for z in slug if z not in chars]) > 0:
        if specs is None:
            msg = "Error in creating a slug for %s, found an unexpected character: ord=%d" % (player, ord([z for z in slug if z not in chars][0]))
        else:
            msg = "Error in creating a slug for %s in game ID %d, found an unexpected character: ord=%d" % (player, specs['game_ID'], ord([z for z in slug if z not in chars][0]))
            cursor = zc.zcursor("LR")
            data = cursor.dqr("Select a.log_url, a.ID game_ID, a.game_date from LaxRef_Games a where a.active and a.ID=%s", [specs['game_ID']])[0]
            cursor.close()
            
            msg += "\n\nGame ID: %d" % data['game_ID']
            msg += "\nLog URL: %s" % data['log_url']
            msg += "\nGame DB Record: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % data['game_ID']
            msg += "\nDB Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % data['game_ID']
            msg += "\nAdmin_cockpit: https://pro.lacrossereference.com/admin_cockpit?dt=%s&game_ID=%d" % (data['game_date'].strftime("%Y%m%d"), data['game_ID'])
        
        print (msg)
        script_name = __file__.replace(".py", "").split("\\")[-1]; record_script_completion(script_name, success=False)
        zc.send_crash(msg, bot_token); zc.exit("laxref0022")
    
    random.seed(seed + time.time())
    slug += "-%03d" % (random.random() * 999.99999999)
    time.sleep(.005)
    random.seed(seed + 51683 + time.time())
    slug += "%02d" % (random.random() * 99.999999)
    
    return slug
    
def team_to_slug(team, league, seed, specs=None):
    slug = zc.remove_non_ascii(team.replace("'", "").replace("-", "").replace(" ", "-").replace("\t", "-").lower().strip()) + ("w" if "women" in league.lower() else "m")
        
    chars = [chr(z) for z in range(97, 97+26)]  + ["-"]
    remove_chars = ['&', '.', "_", ':', '#', ';', ',', '~', '{', '}', '|', '?', '[', ']', '(', ')'] + ["%d" % z for z in range(10)]
    slug = "".join([z for z in slug if z not in remove_chars and ord(z) > 32])
    
    if len([z for z in slug if z not in chars]) > 0:
        if specs is None:
            msg = "Error in creating a slug for %s, found an unexpected character: ord=%d" % (team, ord([z for z in slug if z not in chars][0]))
        else:
            msg = "Error in creating a slug for %s (game ID= %d), found an unexpected character: ord=%d" % (team, specs['game_ID'], ord([z for z in slug if z not in chars][0]))
            cursor = zc.zcursor("LR")
            data = cursor.dqr("Select a.log_url, a.ID game_ID, a.game_date from LaxRef_Games a where a.active and a.ID=%s", [specs['game_ID']])[0]
            cursor.close()
            
            msg += "\n\nGame ID: %d" % data['game_ID']
            msg += "\nLog URL: %s" % data['log_url']
            msg += "\nGame DB Record: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % data['game_ID']
            msg += "\nDB Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % data['game_ID']
            msg += "\nAdmin_cockpit: https://pro.lacrossereference.com/admin_cockpit?dt=%s&game_ID=%d" % (data['game_date'].strftime("%Y%m%d"), data['game_ID'])
        
        print (msg)
        script_name = __file__.replace(".py", "").split("\\")[-1]; record_script_completion(script_name, success=False)
        zc.send_crash(msg, bot_token); zc.exit("laxref0023")
    
    random.seed(seed + time.time())
    slug += "-%02d" % (random.random() * 99.99999999)
    time.sleep(.005)
    random.seed(seed + 51683 + time.time())
    slug += "%02d" % (random.random() * 99.999999)
    
    return slug
    
def create_scoreboard_data(settings):

        table_rows = []
        captured_games = 0
        total_final_games = 0
        win_probabilities_for_laxpower = []

        if settings['today_dt'] > datetime.today():
            url = "https://insidelacrosse.com/league/DI/calendar"
        else:
            url = "https://insidelacrosse.com/league/DI/scores"

        today_str = settings['today_dt'].strftime("%A, %B %d")
        #print("Today is %s" % today_str)


        #games, captured_games, total_final_games = get_IL_scoreboard_games(settings['today_dt'], False if 'use_file' not in settings else settings['use_file'], False if 'show_links' not in settings else settings['show_links'])
        games, captured_games, total_final_games, window_methods, machines = get_LR_scoreboard_games(settings['today_dt'], 0, False if 'show_links' not in settings else settings['show_links'])
        
        if 'league' in settings and settings['league'] not in ['', None]:
            games = [z for z in games if z['league'] == settings['league']]

        for g in games:
            g['assigned_to_options'] = [{'selected': "", 'val': ''}, {'selected': "", 'val': 'PwCLaptop'}, {'selected': "", 'val': 'NewEggLaptop'}, {'selected': "", 'val': 'Toshiba'}]

            if g['game_file'] in [z['game_file'] for z in settings['game_streams']]:
                tmp_settings = settings['game_streams'][ [z['game_file'] for z in settings['game_streams']].index(g['game_file']) ]
                g['final_tweet_sent'] = tmp_settings['final_tweet_sent']
                g['auto_tweet'] = tmp_settings['auto_tweet']
                g['game_stream_ID'] = tmp_settings['ID']
                g['assigned_to'] = tmp_settings['assigned_to']
                g['preview_tweet_sent'] = 1 if tmp_settings['preview_tweets_send_time'] is not None else 0
                for o in g['assigned_to_options']:
                    if g['assigned_to'] == o['val']: o['selected'] = "selected"

            else:
                g['final_tweet_sent'] = False
                g['preview_tweet_sent'] = 0
                g['game_stream_ID'] = None
                g['assigned_to'] = None
                g['auto_tweet'] = None
                
            g['lp_str'] = "[url=%s]%s vs %s[/url]" % (g['lax_power_url'], g['display_team1'], g['display_team2'])
            if 'laxref_content' in settings:
                preview = None; recap = None;
                game_content = [z for z in settings['laxref_content'] if z['game_ID'] == g['ID']]
                if g['status'] == "scheduled":
                    if 'preview-paragraph' in [z['content_type'] for z in game_content]:
                        tmp_content = game_content[ [z['content_type'] for z in game_content].index('preview-paragraph') ]
                        if tmp_content['content'] not in ['', None]:
                            preview = tmp_content['content']
                            g['lp_str'] = "%s vs %s ([url=https://%s]Preview Analysis[/url])" % (g['display_team1'], g['display_team2'], g['lax_power_url'])
                            g['preview'] = preview
                elif "comp" in g['status']:
                    if 'recap-paragraph' in [z['content_type'] for z in game_content]:
                        tmp_content = game_content[ [z['content_type'] for z in game_content].index('recap-paragraph') ]
                        if tmp_content['content'] not in ['', None]:
                            recap = tmp_content['content']
                            g['lp_str'] = "%s vs %s ([url=%s]Recap Analysis[/url])" % (g['display_team1'], g['display_team2'], g['lax_power_url'])
                            g['recap'] = recap

    
        #games = sorted(games, key=lambda k: k['team1'])
        for g1, g2, g3 in zip(*[iter(games)]*3):
            table_rows.append([g1, g2, g3])
        empty = {'populate': 'no', 'title': '---'}
        if len(games) % 3 == 1:
            table_rows.append([games[-1], empty, empty])
        elif len(games) % 3 == 2:
            table_rows.append([games[-2], games[-1], empty])
        if total_final_games > 0:
            captured_cnt = "%d out of %d finals captured" % (captured_games, total_final_games)
        else:
            men_cnt = sum([1 for z in games if z['league'] == "NCAA D1 Men"])
            women_cnt = sum([1 for z in games if z['league'] == "NCAA D1 Women"])
            captured_cnt = "%d games on the schedule (<span style='cursor:pointer;' class='league-games-cnt-label mouseover-link' onclick='hide_games(\"WLAX\");'>%d M</span> / <span style='cursor:pointer;' class='league-games-cnt-label mouseover-link' onclick='hide_games(\"MLAX\");'>%d W</span>)" % (len(games), men_cnt, women_cnt)
        #print captured_cnt



        #zc.print_dict(win_probabilities_for_laxpower)
        
        if settings['show_links']:
            keys = ['NCAA D1 Men', 'NCAA D1 Women']
            laxpower_msg = ""
            for k in keys:

                win_probabilities_for_laxpower = sorted([z for z in games if z['league'] == k], key=lambda x:x['game_date'])
                for l in win_probabilities_for_laxpower:
                    if 'http' not in l['lp_str']:
                        l['lp_str'] =  l['lp_str'].replace("bit.ly", "https://bit.ly")
                laxpower_msg += "" if len(win_probabilities_for_laxpower) == 0 else "<BR><BR>Live Win Probability Links<BR><BR> - %s" % ("<BR> - ".join([z['lp_str'] for z in win_probabilities_for_laxpower if z['lax_power_url'] not in [None, '']]))
        else:
            laxpower_msg = ""
        return table_rows, captured_cnt, laxpower_msg, window_methods


def shorten_conf_name(orig_conf):

    if orig_conf == "Southern":
        conf = "SoCon"
    elif orig_conf == "Ivy League":
        conf = "Ivy"
    elif orig_conf == "Big Ten":
        conf = "B1G"
    elif orig_conf == "Division I Independents":
        conf = "Independents"
    else:
        words = orig_conf.split(" ")
        conf = ""
        for w in words:
            conf += w[0].upper()
    return conf


def get_top_efficiency_teams(count, stat_type):
    teams = []
    year = datetime.today().year
    path = os.path.join(lr_fldr, 'Post_015', 'Outputs', '%d overall_efficiency (%s).csv' % (year, stat_type))
    if os.path.isfile(path):
        lines = open(path, 'r').read().split("\n")[1:count +1]
        teams = [t.split(",")[0] for t in lines]
    return teams

def get_team_gif(team, big=False):
    if 'team_ID' in team:
        files = os.listdir(os.path.join(lr_fldr, "TeamLogos"))
        fname = "team%04d" % (team['team_ID'])

        for f in files:
            if big:
                if f.startswith(fname) and "_big" in f:
                    return os.path.join(lr_fldr, "TeamLogos", f)
            else:
                if f.startswith(fname) and "_big" not in f:
                    return os.path.join(lr_fldr, "TeamLogos", f)

        tteam = team['display_name'].replace("St. Bonaventure", "bonnies").replace("Sacred Heart", "Sacred").replace("Hobart and William", "Hobart").replace("Notre Dame", "ND").replace("North Carolina", "UNC").replace("Johns Hopkins", "JHU").replace("Penn State", "PSU").replace("Ohio State", "OSU").replace("Air Force", "AFA")    .replace("St. John's", "StJohns")    .replace("Boston U", "BostonU")    .replace("Stony Brook", "SBU")    .replace("Virginia", "UVA")    .replace("Marquette", "MARQ")    .replace("Loyola MD", "Loyola")    .replace("Holy Cross", "HolyCross")    .replace("Saint Joseph's", "StJoseph")    .replace("Robert Morris", "RMU")    .replace("High Point", "HPU")    .replace("Massachusetts-Lowell", "UML")    .replace("Georgetown", "Gtown")    .replace("Massachusetts", "Umass")    .replace("Cleveland State", "ClevelandState")    .replace("Mount St Marys", "MSM").lower()

    elif 'ID' in team:
        files = os.listdir(os.path.join(lr_fldr, "TeamLogos"))
        fname = "team%04d" % (team['ID'])

        for f in files:
            if big:
                if f.startswith(fname) and "_big" in f:
                    return os.path.join(lr_fldr, "TeamLogos", f)
            else:
                if f.startswith(fname) and "_big" not in f:
                    return os.path.join(lr_fldr, "TeamLogos", f)

        tteam = team['display_name'].replace("St. Bonaventure", "bonnies").replace("Sacred Heart", "Sacred").replace("Hobart and William", "Hobart").replace("Notre Dame", "ND").replace("North Carolina", "UNC").replace("Johns Hopkins", "JHU").replace("Penn State", "PSU").replace("Ohio State", "OSU").replace("Air Force", "AFA")    .replace("St. John's", "StJohns")    .replace("Boston U", "BostonU")    .replace("Stony Brook", "SBU")    .replace("Virginia", "UVA")    .replace("Marquette", "MARQ")    .replace("Loyola MD", "Loyola")    .replace("Holy Cross", "HolyCross")    .replace("Saint Joseph's", "StJoseph")    .replace("Robert Morris", "RMU")    .replace("High Point", "HPU")    .replace("Massachusetts-Lowell", "UML")    .replace("Georgetown", "Gtown")    .replace("Massachusetts", "Umass")    .replace("Cleveland State", "ClevelandState")    .replace("Mount St Marys", "MSM").lower()

    else:
        tteam = team.replace("St. Bonaventure", "bonnies").replace("Sacred Heart", "Sacred").replace("Hobart and William", "Hobart").replace("Notre Dame", "ND").replace("North Carolina", "UNC").replace("Johns Hopkins", "JHU").replace("Penn State", "PSU").replace("Ohio State", "OSU").replace("Air Force", "AFA")    .replace("St. John's", "StJohns")    .replace("Boston U", "BostonU")    .replace("Stony Brook", "SBU")    .replace("Virginia", "UVA")    .replace("Marquette", "MARQ")    .replace("Loyola MD", "Loyola")    .replace("Holy Cross", "HolyCross")    .replace("Saint Joseph's", "StJoseph")    .replace("Robert Morris", "RMU")    .replace("High Point", "HPU")    .replace("Massachusetts-Lowell", "UML")    .replace("Georgetown", "Gtown")    .replace("Massachusetts", "Umass")    .replace("Cleveland State", "ClevelandState")    .replace("Mount St Marys", "MSM").lower()

        if big:
            tteam += "_big"
        if os.path.isfile(os.path.join(lr_fldr, "TeamLogos", "%s.gif" % tteam)):
            return os.path.join(lr_fldr, "TeamLogos", "%s.gif" % tteam)
        elif os.path.isfile(os.path.join(lr_fldr, "TeamLogos", "%s.jpeg" % tteam)):
            return os.path.join(lr_fldr, "TeamLogos", "%s.jpeg" % tteam)
        elif os.path.isfile(os.path.join(lr_fldr, "TeamLogos", "%s.jpg" % tteam)):
            return os.path.join(lr_fldr, "TeamLogos", "%s.jpg" % tteam)
        elif os.path.isfile(os.path.join(lr_fldr, "TeamLogos", "%s.png" % tteam)):
            return os.path.join(lr_fldr, "TeamLogos", "%s.png" % tteam)

    return None

def get_team_games(g):
    trend_labels ={'type': "season" , 'first_header_dtop': 'Season Avg.', 'second_header_dtop': 'Last 3 games', 'explanation': 'Since we want to wait for sufficient games to have been played, we have compared each team\'s full season stats with a subset consisting of the last 3 games.'}

    for tmp in ["home", "away"]:
        path = os.path.join(lr_fldr, "Teams", 'team%04d' % g['%s_ID' % tmp], '%dGameLog' % datetime.now().year)
        g['%s_games' % tmp] = []

        if os.path.isfile(path):

            games = json.loads(open(path, 'r').read())
            if len(games) > 0:
                game_headers = games[0]; games = games[1:]
                for i, g_ in enumerate(games):
                    d = {}

                    for k in g_.keys():
                        if k == 'game_date':
                            d[k] = datetime.strptime(g_[k], "%Y-%m-%d")
                        else:
                            d[k] = g_[k]
                    d['won'] = True if d['goals'] > d['opp_goals'] else False
                    if d not in g['%s_games' % tmp]:
                        g['%s_games' % tmp].append(d)

    g['home_games'] = sorted(g['home_games'], key=lambda x:x['date'])
    g['away_games'] = sorted(g['away_games'], key=lambda x:x['date'])


    if min( len(g['home_games']), len(g['away_games'])) <= 3:
        trend_labels['type'] = None
    elif min( len(g['home_games']), len(g['away_games'])) >= 6:
        trend_labels['type'] = "last3"
        trend_labels['first_header_dtop'] = "Previous 3 games"
        trend_labels['second_header_dtop'] = "Last 3 games"
        trend_labels['explanation'] = ''

        for tmp in ["home", "away"]:
            g[tmp + "_first_games"] = g[tmp + "_games"][-6:-3]
            g[tmp + "_second_games"] = g[tmp + "_games"][-3:]
    else:
        for tmp in ["home", "away"]:
            g[tmp + "_first_games"] = g[tmp + "_games"]
            g[tmp + "_second_games"] = g[tmp + "_games"][-3:]

    return g


def removeget_team_elo_rating(team, date, start=True):

    path = os.path.join(lr_fldr, "Post_021", "Teams", "team%04d_2015_%d_ELO_Rating.csv" % (team, datetime.now().year -2000))

    if not os.path.isfile(path):
        path = os.path.join(lr_fldr, "Post_021", "Teams", "team%04d_2015_%d_ELO_Rating.csv" % (team, datetime.now().year -2001))
    #print "Look up the data in path: %s" % path
    if os.path.isfile(path):
        lines = filter(None, open(path, 'r').read().split("\n")[1:])
        #print date
        if date in [l.split(",")[0].replace(" 00:00:00", "") for l in lines]:

            date_id = [l.split(",")[0].replace(" 00:00:00", "") for l in lines].index(date)
            if start:
                return int(lines[date_id].split(",")[1])
            else:
                return int(lines[date_id].split(",")[2])
        else:
            max_date = datetime.strptime(lines[-1].split(",")[0], "%Y-%m-%d %H:%M:%S")
            date = datetime.strptime(date, "%Y-%m-%d")
            #if date > max_date: # If it's a game in the future
            #    print("That is in the future")
            #    print("ELO is %d" % int(lines[-1].split(",")[2]))
            return int(lines[-1].split(",")[2])

    else:
        print(" ELO File missing: %s" % path)
        zc.send_telegram("ELO File missing: %s" % path, bot_token)
        return "???"

def get_player_hometown(team, year, player, urls):
    debug = False
    orig_player = player
    try:

        regex = re.compile(r'(https://.+[a-z]+)(?:/[0-9]+)?')
        data = filter(None, open(os.path.join(lr_fldr, 'Post_008', 'players_%d.csv' % (year - 2000)), 'r').read().split('\n')[1:])
        data_tuples = []
        for u in data:
            if True or not u.startswith("Year"):
                u = u.replace(", Jr", "; Jr")

                match = regex.search(u.replace(", Jr", "; Jr").split(",")[6])
                if match is None:
                    data_tuples.append(("", ""))
                else:
                    url = match.group(1)
                    tmp_player = u.split(",")[2].lower().replace("-", "").replace("'", "").replace(".", "").replace(" ", "")
                    if "mcandrew" not in tmp_player:
                        tmp_player = tmp_player.replace("andrew", "andy")
                    tmp_player = tmp_player.replace("joseph", "joe")
                    tmp_player = tmp_player.replace("christopher", "chris")
                    
                    tmp_player = tmp_player.replace("tommy", "tom")
                    if tmp_player.startswith("patrick"):
                        tmp_player = tmp_player.replace("patrick", "pat")
                    tmp_player = tmp_player.replace("jacob", "jake")
                    tmp_player = tmp_player.replace("michael", "mike")
                    tmp_player = tmp_player.replace("brenden", "brendan")
                    if "mcnicholas" not in tmp_player:
                        tmp_player = tmp_player.replace("nicholas", "nick")
                    tmp_player = tmp_player.replace("david", "dave")
                    tmp_player = tmp_player.replace("jeffrey", "jeff")
                    tmp_player = tmp_player.replace("daniel", "dan")
                    tmp_player = tmp_player.replace("danny", "dan")
                    tmp_player = tmp_player.replace("johnathan", "john")
                    tmp_player = tmp_player.replace("gregory", "greg")
                    tmp_player = tmp_player.replace("matthew", "matt")
                    tmp_player = tmp_player.replace("billy", "william")
                    if tmp_player == "roland iv wheeler":
                        tmp_player = "Roland Wheeler IV"
                    if tmp_player.endswith("jr"):
                        tmp_player = tmp_player[0:-2]

                    data_tuples.append((url, tmp_player.strip().lower()))


        # Adjust the problematic names
        if player.lower().endswith(" jr"):
            player = player[0:-3]
        player = "Jimmy Joe Granito" if player == "Jimmy Granito" else player
        player = "Jimmy Joe Granito" if player == "Jimmy Joe" else player
        player = "John VanSickle" if player == "John Van Sickle" else player
        player = "Matthew Del Duca" if player == "Del Duca" else player
        player = "Jack Lydon" if player == "Jake Lydon" else player
        player = "Matt Tanenblatt" if player == "Matt Tannenblatt" else player
        player = "Luke Van Schepen" if player == "Van Schepen" else player
        player = "Austin PolsonMccannon" if player == "Aus PolsonMccannon" else player
        player = "Nic Ancona" if player == "Nick Ancona" else player
        player = "Luke Van Schepen" if player == "Luke Van" and team=='Siena' else player
        player = "J Andrew Spallanzani" if player == "J Andrew" and "Hobart" in team else player
        player = "D Bennett Moore" if player == "D Bennett" and "Hobart" in team else player
        player = "Evan P Kalish" if player == "Evan P" and "Bellarmine" in team else player
        player = "Dom St Laurent" if player == "St Laurent" and "Mass" in team else player
        player = "Cade Van Raaphorst" if player == "Cade Van" and "Duke" in team else player
        player = "Austin Yezarski" if "yezarski" in player.lower() else player
        player = "Christian Cuccinello" if player == "Christia Cuccinello" or player == "C Cuccinello" else player
        player = "Garrett Waldron" if player == "Garrett Walrdon" else player
   
        player = "Will Hendrick" if player == "Will Hendirck" else player
        player = "Daniel Winschuh" if player == "Daniel Winschuch" else player
        player = "Td Irelan" if player == "Td Ierlan" else player
        player = "Conor Van Duzer" if player == "Conor Van" and team == "Hartford" else player
        player = "Alec Van De Bovenkamp" if player == "A Van" and team == "Furman" else player
        player = "Michael Hatzopoulos" if player == "Michael Hatzopolous" else player
        player = "Connor Kirst" if player == "Conner Kirst" else player
        player = "Christian Carson-banister" if player == "C CarsonBanister" else player

        player = player.replace("Joseph", "Joe")
        player = player.replace("Christopher", "Chris")
        player = player.replace("Matthew", "Matt")
        player = player.replace("Jacob", "Jake")
        player = player.replace("Brenden", "Brendan")
        player = player.replace("Billy", "William")
        player = player.replace("Tommy", "Tom")
      
        player = player.replace("Michael", "Mike")
        player = player.replace("Jeffrey", "Jeff")
        player = player.replace("Daniel", "Dan")
        player = player.replace("Danny", "Dan")
        if "mcnicholas" not in player.lower():
            player = player.replace("Nicholas", "Nick")
        player = player.replace("David", "Dave")
        if "mcandrew" not in player.lower():
            player = player.replace("Andrew", "Andy")
        player = player.replace("Johnathan", "John")
        player = player.replace("Gregory", "Greg")
        if player.startswith("Patrick"):
            player = player.replace("Patrick", "Pat")


        if debug and player=='Jeff Reh':
            print("Find %s in year %d for team %s" % (player, year, team))
        data = filter(None, open(os.path.join(lr_fldr, 'Post_008', 'players_%d.csv' % (year - 2000)), 'r').read().split('\n')[1:])


        team_IL_url = urls[[u['Team'].lower().strip() for u in urls].index(team.lower().strip())]['url'].lower()
        if debug and player=='Jeff Reh':
            print("\n\nURL: %s\n\n" % (team_IL_url))


        data_id = data_tuples.index((team_IL_url, player.replace(".", "").replace("-", "").replace("'", "").replace(" ", "").strip().lower()))

        if debug and player=='Jeff Reh':
            print("Data row: %d" % data_id)
            print("\t%s" % data[data_id])

        player_class = data[data_id].replace(", Jr", "; Jr").split(",")[4]
        player_hometown = data[data_id].replace(", Jr", "; Jr").split(",")[5].replace(";", ",")

        if debug and player=='Jeff Reh':
            print("Player hometown: %s" % player_hometown)
        return player_hometown

    except Exception as e:
        print (traceback.format_exc())
        return "???"

def post_game_pro_email_basic(g, specs):
    #zc.print_dict(g)
    #print sorted(g.keys())
    #print "\nSpecs"
    #zc.print_dict(specs)
    html = ""
    
    me_tag = "home" if specs['team_ID'] == g['home_team']['ID'] else "away"
    them_tag = "home" if specs['team_ID'] != g['home_team']['ID'] else "away"
    opp_ID = g['away_team']['ID'] if specs['team_ID'] == g['home_team']['ID'] else g['home_team']['ID']
    
    sections = []
    
    # Team Summary Comp (Efficiency, Pace, Shooting %, TO Rate, T.O.P.)
    s = {'html': "", 'section_title': 'Summary Stats', 'seq': len(sections) + 1, 'tag': 'team_summaries'}
    fields = []
    
    header = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; padding: 20px 0px 10px 0px;border-bottom: solid 3px #555;'>"
    header += "<div style='width:33.3%;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "" )
    header += "<div style='width:33.3%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( g['home_team']['team'] )
    header += "<div style='width:33.3%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format(  g['away_team']['team'] )
    header += "</div>"
    fields.append({'html': header})
    

    fields.append({'tag': 'goals', 'display': 'Goals', 'fmt': "{:.0f}"})
    fields.append({'tag': 'possessions', 'display': 'Possessions', 'fmt': "{:.0f}"})
    fields.append({'tag': 'off_efficiency', 'display': 'Efficiency', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'shots', 'display': 'Shots', 'fmt': "{:.0f}"})
    fields.append({'tag': 'shooting_pct', 'display': 'Shooting Pct', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'sog', 'display': 'Shots-on-Goal', 'fmt': "{:.0f}"})
    fields.append({'tag': 'saves', 'display': 'Saves', 'fmt': "{:.0f}"})
    fields.append({'tag': 'save_pct', 'display': 'Save Pct', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'gbs', 'display': 'Groundballs', 'fmt': "{:.0f}"})
    fields.append({'tag': 'gb_win_rate', 'display': 'GB Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'turnovers', 'display': 'Turnovers', 'fmt': "{:.0f}"})
    fields.append({'tag': 'turnover_rate', 'display': 'TO Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'assists', 'display': 'Assists', 'fmt': "{:.0f}"})
    fields.append({'tag': 'assist_rate', 'display': 'Assist Rate', 'fmt': "{:.1f}%"})
    if "Women" not in g['league']:
        fields.append({'tag': 'faceoffs', 'display': 'Faceoff Wins', 'fmt': "{:.0f}"})
        fields.append({'tag': 'fo_pct', 'display': 'FO Win Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'failed_clears', 'display': 'Failed Clears', 'fmt': "{:.0f}"})
    fields.append({'tag': 'clear_rate', 'display': 'Clear Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'top', 'display': 'T.O.P.', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'time_per_possession', 'display': 'Avg Poss.', 'fmt': "{:.1f}s"})
    #fields.append({'tag': '', 'display': '', 'fmt': "{}"})
    #fields.append({'tag': '', 'display': '', 'fmt': "{}"})
    
    
    for i, fld in enumerate(fields[1:]):
        bg = "#EEE" if i % 2 == 0 else "#FFF"
        fld['html'] = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; background-color:{};'>" .format( bg )
        fld['html'] += "<div style='width:33.3%;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['display'] )
        
        for team_tag in ['home', 'away']:
            v = g['stat_summaries']['%s_%s' % (team_tag, fld['tag'])]['val']
            if v is not None and '%' in fld['fmt']: v *= 100.
            
            if v is None:
                fld['html'] += "<div style='width:33.3%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>N/A</span></div>"
            else:
                fld['html'] += "<div style='width:33.3%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['fmt'].format(v) )
        fld['html'] += "</div>"
    s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
    s['html'] += "".join([z['html'] for z in fields])
    sections.append(s)
    
    # Actual vs Opp Adjusted Performance
    s = {'html': "", 'section_title': 'Opponent-Adjusted', 'seq': len(sections) + 1, 'tag': 'opp_adjustment'}
    opp_stat_adjustments = [z for z in specs['stat_adjustments'] if z['team_ID'] == opp_ID]
    #zc.print_dict(opp_stat_adjustments)
    
    html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; padding: 20px 0px 10px 0px;border-bottom: solid 3px #555;'>"
    html += "<div style='width:40%;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "" )
    html += "<div style='width:20%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "Raw" )
    html += "<div style='width:20%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format("%s Adj" % (  g['%s_team' % them_tag]['team'][0:3] ))
    html += "<div style='width:20%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "Final" )
    html += "</div>"
    
    divs = [html]
    
    
    fields = []
    fields.append({'stat': 'efficiency', 'summary_tag': 'off_efficiency', 'offense':1, 'display': 'Off Efficiency', 'fmt': "{:.1f}%"})
    fields.append({'stat': 'efficiency', 'summary_tag': 'def_efficiency', 'offense':0, 'display': 'D' + 'ef ' + 'Efficiency', 'fmt': "{:.1f}%"})
    fields.append({'stat': 'shooting_pct', 'summary_tag': 'shooting_pct', 'offense':1, 'display': 'Shooting Pct', 'fmt': "{:.1f}%"})
    fields.append({'stat': 'turnover_rate', 'summary_tag': 'turnover_rate', 'offense':1, 'display': 'Turnover Rate', 'fmt': "{:.1f}%"})
    if "Women"not in g['league']:
        fields.append({'stat': 'faceoff_win_rate', 'summary_tag': 'fo_pct', 'offense':1, 'display': 'FO Win Rate', 'fmt': "{:.1f}%"})
    #fields.append({'stat': 'modified_possession_margin', 'summary_tag': 'modified_possession_margin', 'offense':1, 'display': 'Possession Margin', 'fmt': "{:.1f}"})
    
    
    try:

        src = os.path.join(lr_fldr, "Logs", "PgData.json")
        pft = open(src, 'w')
        pft.write(json.dumps(g['stat_summaries'], default=zc.json_handler, indent=1))
        pft.close()
    except Exception:
        print (traceback.format_exc())
    
    for i, fld in enumerate(fields):
        bg = "#EEE" if i % 2 == 0 else "#FFF"
        fld['raw'] = g['stat_summaries']['%s_%s' % (me_tag, fld['summary_tag'])]['val']
        tmp = [z for z in opp_stat_adjustments if z['stat'] == fld['stat'] and z['offense'] != fld['offense']]
        fld['adj'] = 0. if len(tmp) == 0 else -1*tmp[0]['self_adjustment']
        
        fld['final'] = fld['raw'] + fld['adj']
        
        if "%" in fld['fmt']:
            fld['raw'] *= 100.
            fld['adj'] *= 100.
            fld['final'] *= 100.
            
        plus_sign = "" if fld['adj'] < 0 else "+"
        html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; background-color:{};'>".format(bg)
        html += "<div style='width:40%;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['display'] )
        html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['fmt'].format(fld['raw']) )
        html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}{}</span></div>".format(plus_sign, fld['fmt'].format(fld['adj']))
        html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format(fld['fmt'].format(fld['final']) )
        html += "</div>"
        divs.append(html)
    
    s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
    s['html'] += "".join(divs)
    sections.append(s)

    # Stars/Favorite Player My Team
    
    
    team_tags = [me_tag, them_tag]
    for team_tag in team_tags:
        divs = []
        s = {'html': "", 'section_title': '%s: Top 5 by EGA' % g['%s_team' % team_tag]['team'], 'seq': len(sections) + 1, 'tag': 'box_score_highlights', 'team_ID': g['%s_team' % team_tag]['ID']}
        
        html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; padding: 20px 0px 10px 0px;border-bottom: solid 3px #555;'>"
        html += "<div style='width:40%;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "Player" )
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "G" )
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format("A")
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "Sh%" )
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "EGA" )
        html += "</div>"
        divs.append(html)
        
        top_5 = [z for z in sorted(g['player_summaries'], key=lambda x:x['goals_added'], reverse=True) if z['team_ID'] == s['team_ID']][0:5]
        for i, p in enumerate(top_5):
            bg = "#EEE" if i % 2 == 0 else "#FFF"

            html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; background-color:{};'>".format(bg)
            html += "<div style='width:40%;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( p['player'] )
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.0f}".format(p['goals']) )
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.0f}".format(p['assists']) )
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.1f}%".format(100. * float(p['goals'])/float(p['shots'])) if p['shots'] > 0 else "---" )
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.2f}".format(p['goals_added']) if p['goals_added'] is not None else "---" )
            html += "</div>"
            divs.append(html)
        
        
        s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
        s['html'] += "".join(divs)
        sections.append(s)

    # Link to the Game (i.e. Rapid Summary gets sent straight to LRP)
    
    s = {'html': "", 'section_title': 'Game Link', 'seq': len(sections) + 1, 'tag': 'game_link'}
    
    if '--include-game-link' in sys.argv: 
        
        s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
        sections.append(s)
    
    # Unsubscribe from these emails    
    s = {'html': "", 'section_title': 'Unsubscribe', 'seq': len(sections) + 1, 'tag': 'unsubscribe'}
    
    s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
    s['html'] += "<div style='width:100%; padding: 5px 0px 5px 3px; text-align:left;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "To unsubcribe from post-game emails, <a href='https://pro.lacrossereference.com/preferences'>click here</a> to update your preferences.." )
    sections.append(s)
    
    html = "<BR><BR>".join([z['html'] for z in sections])
    
    #print html
    if '--test-email' in sys.argv: 
        f = open(os.path.join(piFolder, 'default', 'templates', 'laxref_game_email.html'), 'w')
        f.write(html); f.close()

    
    return html

def post_game_pro_email_team(g, specs):
    #zc.print_dict(g)
    #print sorted(g.keys())
    #print "\nSpecs"
    #zc.print_dict(specs)
    html = ""
    me_tag = "home" if specs['team_ID'] == g['home_team']['ID'] else "away"
    them_tag = "home" if specs['team_ID'] != g['home_team']['ID'] else "away"
    
    
    opp_ID = g['away_team']['ID'] if specs['team_ID'] == g['home_team']['ID'] else g['home_team']['ID']
    
    sections = []
    
    # Team Summary Comp (Efficiency, Pace, Shooting %, TO Rate, T.O.P.)
    s = {'html': "", 'section_title': 'Summary Stats', 'seq': len(sections) + 1, 'tag': 'team_summaries'}
    fields = []
    
    header = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; padding: 20px 0px 10px 0px;border-bottom: solid 3px #555;'>"
    header += "<div style='width:33.3%;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "" )
    header += "<div style='width:33.3%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( g['home_team']['team'] )
    header += "<div style='width:33.3%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format(  g['away_team']['team'] )
    header += "</div>"
    fields.append({'html': header})
    

    fields.append({'tag': 'goals', 'display': 'Goals', 'fmt': "{:.0f}"})
    fields.append({'tag': 'possessions', 'display': 'Possessions', 'fmt': "{:.0f}"})
    fields.append({'tag': 'off_efficiency', 'display': 'Efficiency', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'shots', 'display': 'Shots', 'fmt': "{:.0f}"})
    fields.append({'tag': 'shooting_pct', 'display': 'Shooting Pct', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'sog', 'display': 'Shots-on-Goal', 'fmt': "{:.0f}"})
    fields.append({'tag': 'saves', 'display': 'Saves', 'fmt': "{:.0f}"})
    fields.append({'tag': 'save_pct', 'display': 'Save Pct', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'gbs', 'display': 'Groundballs', 'fmt': "{:.0f}"})
    fields.append({'tag': 'gb_win_rate', 'display': 'GB Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'turnovers', 'display': 'Turnovers', 'fmt': "{:.0f}"})
    fields.append({'tag': 'turnover_rate', 'display': 'TO Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'assists', 'display': 'Assists', 'fmt': "{:.0f}"})
    fields.append({'tag': 'assist_rate', 'display': 'Assist Rate', 'fmt': "{:.1f}%"})
    if "Women" not in g['league']:
        fields.append({'tag': 'faceoffs', 'display': 'Faceoff Wins', 'fmt': "{:.0f}"})
        fields.append({'tag': 'fo_pct', 'display': 'FO Win Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'failed_clears', 'display': 'Failed Clears', 'fmt': "{:.0f}"})
    fields.append({'tag': 'clear_rate', 'display': 'Clear Rate', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'top', 'display': 'T.O.P.', 'fmt': "{:.1f}%"})
    fields.append({'tag': 'time_per_possession', 'display': 'Avg Poss.', 'fmt': "{:.1f}s"})
    #fields.append({'tag': '', 'display': '', 'fmt': "{}"})
    #fields.append({'tag': '', 'display': '', 'fmt': "{}"})
    
    
    for i, fld in enumerate(fields[1:]):
        bg = "#EEE" if i % 2 == 0 else "#FFF"
        fld['html'] = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; background-color:{};'>" .format( bg )
        fld['html'] += "<div style='width:33.3%;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['display'] )
        
        for team_tag in ['home', 'away']:
            v = g['stat_summaries']['%s_%s' % (team_tag, fld['tag'])]['val']
            if v is not None and '%' in fld['fmt']: v *= 100.
            
            if v is None:
                fld['html'] += "<div style='width:33.3%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>N/A</span></div>"
            else:
                fld['html'] += "<div style='width:33.3%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['fmt'].format(v) )
        fld['html'] += "</div>"
    s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
    s['html'] += "".join([z['html'] for z in fields])
    sections.append(s)
    
    # Actual vs Opp Adjusted Performance
    s = {'html': "", 'section_title': 'Opponent-Adjusted Stats', 'seq': len(sections) + 1, 'tag': 'opp_adjustment'}
    if 'historical_statistical_ratings' in specs:
        s['explanation'] = "These stats take the summary stats above and adjust them to account for the strength of the opponent in each facet of the game. As a result, the last column shows, given your team's performance, what their true rating for this game is. The number is on a 0-99 scale where 99 is as good as the best team in Division I and 0 is a bad as the worst team in Division I. (Green means your performance looks better after applying the adjustment; red means your performance looks worse. If there is no colored circle in the Adj column, then we don't have enough game data to do an adjustment.)"
    else:
        s['explanation'] = "These stats take the summary stats above and adjust them to account for the strength of the opponent in each facet of the game. As a result, the last column shows, given your team's performance, what their rating would have been against an average Division I team."
        
    opp_stat_adjustments = [z for z in specs['stat_adjustments'] if z['team_ID'] == opp_ID]
    #zc.print_dict(opp_stat_adjustments)
    
    html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; padding: 20px 0px 10px 0px;border-bottom: solid 3px #555;'>"
    html += "<div style='width:40%;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "" )
    html += "<div style='width:20%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "Raw" )
    html += "<div style='width:20%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format("%s Adj" % (  g['%s_team' % them_tag]['team'][0:3] ))
    html += "<div style='width:20%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "Final" )
    html += "</div>"
    
    divs = [html]
    
    
    fields = []
    fields.append({'historical_comp': 'adjusted_off_efficiency', 'stat': 'efficiency', 'high_is_good': 1, 'summary_tag': 'off_efficiency', 'offense':1, 'display': 'Off Efficiency', 'fmt': "{:.1f}%"})
    fields.append({'historical_comp': 'adjusted_def_efficiency', 'stat': 'efficiency', 'high_is_good': 0, 'summary_tag': 'def_efficiency', 'offense':0, 'display': 'D' + 'ef ' + 'Efficiency', 'fmt': "{:.1f}%"})
    fields.append({'historical_comp': 'adjusted_def_save_pct', 'stat': 'save_pct', 'high_is_good': 1, 'summary_tag': 'save_pct', 'offense':0, 'display': 'Save Pct', 'fmt': "{:.1f}%"})
    fields.append({'historical_comp': 'adjusted_off_shooting_pct', 'stat': 'shooting_pct', 'high_is_good': 1, 'summary_tag': 'shooting_pct', 'offense':1, 'display': 'Shooting Pct', 'fmt': "{:.1f}%"})
    fields.append({'historical_comp': 'adjusted_off_turnover_rate', 'stat': 'turnover_rate', 'high_is_good': 0, 'summary_tag': 'turnover_rate', 'offense':1, 'display': 'Turnover Rate', 'fmt': "{:.1f}%"})
    if "Women" not in g['league']:
        fields.append({'historical_comp': 'adjusted_faceoff_win_rate', 'stat': 'faceoff_win_rate', 'high_is_good': 1, 'summary_tag': 'fo_pct', 'offense':1, 'display': 'FO Win Rate', 'fmt': "{:.1f}%"})
    else:
        fields.append({'historical_comp': 'adjusted_faceoff_win_rate', 'stat': 'faceoff_win_rate', 'high_is_good': 1, 'summary_tag': 'fo_pct', 'offense':1, 'display': 'DC Win Rate', 'fmt': "{:.1f}%"})
    #fields.append({'historical_comp': '', 'stat': 'modified_possession_margin', 'summary_tag': 'modified_possession_margin', 'offense':1, 'display': 'Possession Margin', 'fmt': "{:.1f}"})
    
    
    for i, fld in enumerate(fields):
        bg = "#EEE" if i % 2 == 0 else "#FFF"
        fld['raw'] = g['stat_summaries']['%s_%s' % (me_tag, fld['summary_tag'])]['val']
        tmp = [z for z in opp_stat_adjustments if z['stat'] == fld['stat'] and z['offense'] != fld['offense']]
        fld['adj'] = 0. if len(tmp) == 0 or tmp[0]['opp_adjustment'] is None else -1*tmp[0]['opp_adjustment']
        
        fld['final'] = fld['raw'] + fld['adj']
        success = 0
        
        if 'historical_statistical_ratings' in specs:
            try:
                ratings = [z for z in specs['historical_statistical_ratings'] if z['league'] == g['league']]
                
                if fld['high_is_good']:
                    n_worse = sum([1. for z in ratings if z[fld['historical_comp']] < fld['final']])
                else:
                    n_worse = sum([1. for z in ratings if z[fld['historical_comp']] > fld['final']])
                n_ratings = len(ratings)
                percentile = n_worse / n_ratings
                print ("{:<30}{:<10.3f}{:<10.3f}{:<10.3f}{:<10.0f}{:<10.0f}{:<10.3f}".format(fld['summary_tag'], fld['raw'], fld['adj'], fld['final'], n_worse, n_ratings, percentile*100.))
                fld['final'] = percentile * 100.
                
                # Figure out where this single-game performance rates if it is compared to final team season values for the past 3 years
                
                success = 1
            except Exception:
                pass
        
        if not success:
            if "%" in fld['fmt']:
                fld['final'] *= 100.
        
        if "%" in fld['fmt']:
            fld['raw'] *= 100.
            fld['adj'] *= 100.        
        plus_sign = "" if fld['adj'] < 0 else "+"
        html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; border-bottom: solid 1px #EEE;'>"
        html += "<div style='width:40%;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['display'] )
        html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( fld['fmt'].format(fld['raw']) )
        
        if fld['adj'] > 0 and fld['high_is_good']:
            html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'><img src='https://pro.lacrossereference.com/static/img/green_dot_15.png' /></span></div>"
        elif fld['adj'] < 0 and not fld['high_is_good']:
            html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'><img src='https://pro.lacrossereference.com/static/img/green_dot_15.png' /></span></div>"
        elif fld['adj'] < 0 and fld['high_is_good']:
            html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'><img src='https://pro.lacrossereference.com/static/img/red_dot_15.png' /></span></div>"
        elif fld['adj'] > 0 and not fld['high_is_good']:
            html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'><img src='https://pro.lacrossereference.com/static/img/red_dot_15.png' /></span></div>"
        elif fld['adj'] == 0:
            html += "<div style='width:20%; text-align:center;'></div>"
            
        #html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}{}</span></div>".format(plus_sign, fld['fmt'].format(fld['adj']))
        
        if 'historical_statistical_ratings' in specs:
            html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format("{:.0f}".format(fld['final']) )
        else:
            html += "<div style='width:20%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format(fld['fmt'].format(fld['final']) )
        html += "</div>"
        divs.append(html)
    
    s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
      
    s['html'] += "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:15px;'>{}</span></div>".format( s['explanation'] )
    
    s['html'] += "".join(divs)
    sections.append(s)

    # Stars/Favorite Player My Team
    
    
    team_tags = [me_tag]
    for team_tag in team_tags:
        divs = []
        s = {'html': "", 'section_title': 'Player Efficiency Summary', 'seq': len(sections) + 1, 'tag': 'box_score_highlights', 'team_ID': g['%s_team' % team_tag]['ID']}
        
        if 'uaEGA_percentiles' in specs:
            tmp = specs['uaEGA_percentiles'][ [z['league'] for z in specs['uaEGA_percentiles']].index(g['league'])]
            
            s['explanation'] = "Usage-Adjusted-EGA measures what an individual player did with the chances they had. Higher values mean a player was more efficient."
            s['explanation'] += " As a general rule, a uaEGA of 4.0 is a %d%s percentile efficiency." % (100.*float(tmp['rating_4']), zc.get_number_suffix(int(100.*float(tmp['rating_4']))))
            s['explanation'] += " 3.0 is the %d%s percentile." % (100.*float(tmp['rating_3']), zc.get_number_suffix(int(100.*float(tmp['rating_3']))))
            s['explanation'] += " 2.0 is the %d%s percentile." % (100.*float(tmp['rating_2']), zc.get_number_suffix(int(100.*float(tmp['rating_2']))))
            s['explanation'] += " 1.0 is around the %d%s percentile." % (100.*float(tmp['rating_1']), zc.get_number_suffix(int(100.*float(tmp['rating_1']))))
            s['explanation'] += " And a uaEGA rating of 0.0 is the %d%s percentile." % (100.*float(tmp['rating_0']), zc.get_number_suffix(int(100.*float(tmp['rating_0']))))
        else:
            s['explanation'] = "Usage-Adjusted-EGA measures what an individual player did with the chances they had. Higher values mean a player was more efficient. As a general rule, a uaEGA of 3.0 is a 90th percentile efficiency. 2.0 is the 80th percentile. 1.0 is around the 40th percentile. A 0.0 uaEGA is a 16th percentile efficiency."
        
        html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; padding: 20px 0px 10px 0px;border-bottom: solid 3px #555;'>"
        html += "<div style='width:40%;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "Player" )
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "G" )
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format("A")
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "TO" )
        html += "<div style='width:15%; text-align:center;'><span style='font-weight:700; font-family:Arial; font-size:14px;'>{}</span></div>".format( "uaEGA" )
        html += "</div>"
        divs.append(html)
        
        player_summaries = [z for z in sorted(g['player_summaries'], key=lambda x: (0. if x['uaEGA'] is None else x['uaEGA']), reverse=True) if z['team_ID'] == s['team_ID']]
        for i, p in enumerate(player_summaries):
            bg = "#EEE" if i % 2 == 0 else "#FFF"

            html = "<div style='display:flex; padding: 5px 0px 5px 3px; width:100%; background-color:{};'>".format(bg)
            html += "<div style='width:40%;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( p['player'] )
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.0f}".format(p['goals']) )
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.0f}".format(p['assists']) )
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.0f}".format(p['tos']))
            html += "<div style='width:15%; text-align:center;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "{:.2f}".format(p['uaEGA']) if p['uaEGA'] is not None else "---" )
            html += "</div>"
            divs.append(html)
        
        
        s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
      
        s['html'] += "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:15px;'>{}</span></div>".format( s['explanation'] )
      
        s['html'] += "".join(divs)
        sections.append(s)

    # Link to the Game (i.e. Rapid Summary gets sent straight to LRP)
    
    s = {'html': "", 'section_title': 'Game Link', 'seq': len(sections) + 1, 'tag': 'game_link'}
    
    if '--include-game-link' in sys.argv: 
        
        s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
        sections.append(s)
    
    # Unsubscribe from these emails    
    s = {'html': "", 'section_title': 'Unsubscribe', 'seq': len(sections) + 1, 'tag': 'unsubscribe'}
    
    s['html'] = "<div style='width:100%; padding: 20px 0px 10px 0px; text-align:left;'><span style='font-family:Arial; color:#888; font-size:24px;'>{}</span></div>".format( s['section_title'] )
    s['html'] += "<div style='width:100%; padding: 5px 0px 5px 3px; text-align:left;'><span style='font-family:Arial; font-size:14px;'>{}</span></div>".format( "To unsubcribe from post-game emails, <a href='https://pro.lacrossereference.com/preferences'>click here</a> to update your preferences.." )
    sections.append(s)
    
    html =  "This email provides a rapid view of how the LacrosseReference models see this game. The intention is to complement what you saw on the field by using our models to add a second perspective."
    html += "<BR><BR>" + "<BR><BR>".join([z['html'] for z in sections])
    
    #print html
    if '--test-email' in sys.argv: 
        f = open(os.path.join(piFolder, 'default', 'templates', 'laxref_game_email.html'), 'w')
        f.write(html); f.close()

    
    return html
    
def generate_rapid_upload(ID, g, specs):
    
    
    
    #rapid = {'fname': 'game%07d_LRP.json' % ID, 'src': os.path.join(lr_fldr, "Logs", "LRPGameJSONs", g['league'].replace(" ", ""), "%d" % g['detail']['date'].year, 'game%07d_LRP.json' % ID), 'json': None}
    rapid = {'fname': 'game%07d_LRP.json' % ID, 'src': os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GameData", 'game%07d_LRP.json' % ID), 'json': None}
    #a['LRP_json_path'] = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GameData", 'game%07d_LRP.json' % (a['ID']))
            
    data = {'rapid': 1, 'preview': {}, "results": {'BasicSummaryCounting': [1], 'TopStars': None, 'team_summary_stats': [], 'WinProbabilityChart': None}}
    data["headline"] = "%s vs %s (RAPID)" % (g['home_team']['team'], g['away_team']['team'])
    tmp_teams = ['home', 'away']
    for tmp_team in tmp_teams:
        other = 'away' if tmp_team == 'home' else 'home'
        data["%s_alt_team" % tmp_team] = g['%s_team' % tmp_team]['team']
        data["headline_as_%s" % g['%s_team' % tmp_team]['ID']] = "vs %s" % g['%s_team' % other]['team']
    
    data["teams"] =[{"ID": g['%s_team' % tmp_team]['ID'], "short_name": g['%s_team' % tmp_team]['team']} for tmp_team in tmp_teams]
    
    data = LRP_add_basic_counting_team_comparison(data, g)
    data = LRP_add_basic_rate_team_comparison(data, g)
    data = LRP_add_wp_content(data, g, g['plays'])
    data = LRP_add_team_summary_stats(data, g)
    data = LRP_add_shots_content(data, g)
    data['results']['TopStars'] = g['player_summaries']
    
    
    
    try:
        #print ("Print to %s" % rapid['src'])
        f = open(rapid['src'], 'w'); f.write(json.dumps(data)); f.close()
        rapid['stored'] = 1
    except Exception:
        print (traceback.format_exc())
        data = None
        rapid['stored'] = 0
    rapid['json'] = data
    return rapid
    
def stats_page_html(js_data, league_slug, this_url, link_urls_to_show, cursor = None):

    script_html = '<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://www.lacrossereference.com/wp-content/themes/magazine/js/laxref.js?dt=%d"></script><!--script>(function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://www.google-analytics.com/analytics.js","ga"); ga("create", "UA-90014763-1", "auto");</script--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-TYQ0S1T4QH"></script><script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\'js\', new Date());gtag(\'config\', \'G-TYQ0S1T4QH\');</script>' % time.time()
    
    close_DB = False
    if cursor is None:
        close_DB = True
        conn, cursor = zc.mysql_connect("LR")
    
    cursor.execute("SELECT * from LaxRef_Stat_Links where active", [])
    stat_links = zc.dict_query_results(cursor)
    
    dtop_ad_div = ""
    mob_ad_div = ""
    women = 1 if 'women' in league_slug else 0
    link_ID = stat_links[ [z['url'] for z in stat_links].index(this_url) ]['ID']
    stat_code = "?t=57%d%03d930294711" % (women, link_ID)
    
    for d in js_data['data']:
        
        if 'pro_url_icon' in d:
            d['pro_url_icon']['val'] = d['pro_url_icon']['val'].replace("[tracker]", stat_code)
    
    
    
    if '--show-ad' in sys.argv:
        num_imgs = 3
        rand_val = min(num_imgs-1, int(random.random() * float(num_imgs)))
        
        
        
        random.seed(time.time() + link_ID)
        
        
        dtop_img_src = "http://lacrossereference.com/wp-content/uploads/2021/02/2021ad%03d_dtop.png" % rand_val
        mob_img_src = "http://lacrossereference.com/wp-content/uploads/2021/02/2021ad%03d_mob.png" % rand_val
        generic_code = "57%d%03d%d30294712" % (women, link_ID, rand_val )
        dtop_code =    "57%d%03d%d00294712" % (women, link_ID, rand_val )
        mob_code  =    "57%d%03d%d10294712" % (women, link_ID, rand_val )
        
        print ("{:<30}{:<30}{:<30}".format(generic_code, dtop_code, mob_code))
        
        dtop_ad_div = "<div class='col-12 centered dtop'><a href='https://pro.lacrossereference.com/product-summary-basic?t=%s'><img src='%s' /></a></div>" % (dtop_code, dtop_img_src)
        mob_ad_div = "<div class='col-12 centered mob'><a href='https://pro.lacrossereference.com/product-summary-basic?t=%s'><img class='col-12' src='%s' /></a></div>" % (mob_code, mob_img_src)
        
        print (dtop_ad_div)
        print (mob_ad_div)

    
    if '--show-ad' in sys.argv:
        script_html += "<script>var td=%s;generic_create_table(td,{'id':'js_div'});record_ad(%s)</script>" % (json.dumps(js_data), generic_code)
    else:
        script_html += "<script>var td=%s;generic_create_table(td,{'id':'js_div'});</script>" % json.dumps(js_data)
    

    query = "SELECT * from LaxRef_Stat_Links where active=1"
    cursor.execute(query)
    links = zc.dict_query_results(cursor)
    this_stat = None
    for l in links:
        l['selected'] = ""
        if l['url'] == this_url:
            l['selected'] = " selected"
        l['full_url']  = ("/%s-%s" % (l['url'], league_slug))

        l['dtop_description'] = None if l['dtop_description'] is None else l['dtop_description'].replace("[league]", league_slug).replace("\n\n", "<BR>")
        l['mob_description'] = None if l['mob_description'] is None else l['mob_description'].replace("[league]", league_slug).replace("\n\n", "<BR>")
        if 'women' in league_slug.lower():
            l['dtop_description'] = None if l['dtop_description'] is None else l['dtop_description'].replace("if a FOGO", "if a player").replace("faceoff", "draw")
            l['mob_description'] = None if l['mob_description'] is None else l['mob_description'].replace("if a FOGO", "if a player").replace("faceoff", "draw")

        for tmp_tag in ['dtop', 'mob']:
            tmp = []
            if l['%s_description' % tmp_tag] is not None:
                tmp = [z for z in l['%s_description' % tmp_tag].split("<BR>") if z.strip() != ""]
                tmp = ["<div class='col-12 no-padding' style='padding-top:20px;'><span class='contents font-15'>%s</span></div>" % (z) for z in tmp]
            l['%s_description_html' % tmp_tag] = "<div class='no-padding %s'>%s</div>" % (tmp_tag, "".join(tmp))
    this_stat = links[ [z['url'] for z in links].index(this_url)]
    dtop_links = [z for i, z in enumerate(links) if z['description'] in link_urls_to_show]


    for i, z in enumerate(dtop_links):
        z['style'] = ""

        if z['url'] == this_url:
            z['style'] = "background-color:blue;"

    link_categories = [{'stat_group': y} for y in list(set([z['stat_group'] for z in links]))]
    for c in link_categories:
        c['links'] = [z for z in links if z['stat_group'] == c['stat_group']]

    dtop_links_html = "<!-- DTOPPLACEHOLDER --><div class='dtop flex' style='width:90%%; padding-bottom:30px; margin-left:5%%; margin-right:5%%;'>%s</div>" % "".join(["<div onclick=\"window.location='%s';\" class='col-3 link-button centered' style='%s'><span class='btn btn-default stat_button' style='width: 90%%; padding-left:0px;'>%s</span></div>" % (z['full_url'], z['style'], z['dtop_tag']) for z in dtop_links])

    mob_links_html = "<div class='mob right' style='width:90%; padding-bottom:10px; margin-left:5%; margin-right:5%;'><select class='font-14' style='font-family:Oswald;' onchange='window.location=this.value;'>"
    mob_links_html += "".join(["<optgroup label=\"%s\">%s</optgroup>" % (z['stat_group'], "".join(["<option value='%s'%s>%s</option>" % (y['full_url'], y['selected'], y['mob_tag']) for y in z['links']]))  for z in link_categories])
    mob_links_html += "</select></div>"

    if 'women' in league_slug.lower():
        dtop_links_html = dtop_links_html.replace("FOGO", "Draws")
        mob_links_html = mob_links_html.replace("FOGO", "Draws")
    hidden_img = '<img style="display:none;" src="https://lacrossereference.com/wp-content/uploads/2019/03/LaxRefStats.png">'
    if this_url in []:
        hidden_img = ""

    meta_tag_description = ""
    if this_url == "elo":
        league_slug_variant_1 = league_slug.replace("-", " ").title()
        meta_tag_description = '<meta name="description" content="{}\'s lacrosse rankings that are based on actual wins and losses, not a media poll.">'.format(league_slug_variant_1)
    elif this_url == "rpi": 
        league_slug_variant_1 = league_slug.replace("-", " ").title()
        meta_tag_description = '<meta name="description" content="Always up-to-date RPI ranking for {}\'s lacrosse.">'.format(league_slug_variant_1)
    
    # Set Content for main page HTML
    content = """<meta name="viewport" content="width=device-width, initial-scale=1">%s<link rel="stylesheet" href="https://www.lacrossereference.com/wp-content/uploads/oswald.css"><link rel="stylesheet" href="https://www.lacrossereference.com/wp-content/uploads/llg.css?dt=%d"><link rel="stylesheet" href="https://www.lacrossereference.com/wp-content/uploads/laxref.css?dt=%d"><link rel="stylesheet" ref="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"><script src="https://www.lacrossereference.com/wp-content/themes/magazine/js/laxref.js?dt=%d"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><style>.largetext { font-size: 22px; } div.header-widget{ margin:0px; padding:0px;} .team-fg{color:maroon; } .entry-header{ display:none; } .team-bg{background-color:maroon; color:white; } /* .sidebar.widget-area{ display:none; }  .content-area{ width:100%%; } .site{ padding:0px; } .site-inner{ padding:0px; } */</style>%s%s%s<div style="width: 90%%; margin-left: 5%%; overflow-x: auto;"><div class"col-12">
<span class="font-15 contents"><span class="dtop no-padding">%s</span><span class="mob no-padding">%s</span></span></div>
<div class="right"><span class="font-12 contents">Last Updated: [updatedate] ET</span></div></div>
<div id="js_div" class="col-12" style="width:90%%; margin-left:5%%; "></div>
<div style="text-align:center; width:100%%; display:none; visible:hidden;"><img src="https://lacrossereference.com/wp-content/uploads/2019/03/LaxRefStats.png"></div>""" % (meta_tag_description, time.time(), time.time(), time.time(), dtop_links_html, mob_links_html,hidden_img, this_stat['dtop_description'],  this_stat['mob_description'])

    social_media_preview_img = "https://lacrossereference.com/wp-content/uploads/2019/03/LaxRefStats.png"
    social_media_card_text = "Innovative stats and metrics. Team and player rankings. Documenting the sport in a way no one else does."
    if this_url == "rpi":
        social_media_preview_img = "https://storage.googleapis.com/images.pro.lacrossereference.com/MiscImages/rpi_link_rule_30_%s.jpg" % league_slug
        social_media_card_text = "Our sortable RPI report is updated after every game. It includes win quality, SOS, and links to Selection Sunday RPI projections for every team."
    if this_url == "strength-of-record":
        social_media_preview_img = "https://storage.googleapis.com/images.pro.lacrossereference.com/MiscImages/sor_link_rule_30_%s.jpg" % league_slug
        social_media_card_text = "Which team has tbe best resume? Strength-of-Record compares quality wins and losses to rank each team's record."
    content = """<meta name="viewport" content="width=device-width, initial-scale=1">%s<meta property='twitter:card' content="summary_large_image" /><meta property="og:url" content="https://lacrossereference.com" /><meta property="og:title" content="LacrosseReference: Stats" /><meta property="og:image" content="%s" /><meta property="og:image:width" content="500" /><meta property="og:image:height" content="309" /><meta property="og:description" content="%s" /><meta property='twitter:site' content="https://lacrossereference.com" /><meta property='twitter:title' content="LacrosseReference: Stats" /><meta property='twitter:description' content="%s" /><meta property='twitter:image' content="%s" /><body onload=''></p>
<link rel="stylesheet" href="https://www.lacrossereference.com/wp-content/uploads/oswald.css"><link rel="stylesheet" href="https://www.lacrossereference.com/wp-content/uploads/llg.css?dt=%d"><link rel="stylesheet" href="https://www.lacrossereference.com/wp-content/uploads/laxref.css?dt=%d"><link rel="stylesheet" ref="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"><script src="https://www.lacrossereference.com/wp-content/themes/magazine/js/laxref.js?dt=%d"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><style>.largetext { font-size: 22px; } div.header-widget{ margin:0px; padding:0px;} .team-fg{color:maroon; } .entry-header{ display:none; } .team-bg{background-color:maroon; color:white; } /* .sidebar.widget-area{ display:none; }  .content-area{ width:100%%; } .site{ padding:0px; } .site-inner{ padding:0px; } */  </style>
%s
%s
%s
<div style="width: 90%%; margin-left: 5%%; overflow-x: auto;"><div class"col-12">%s%s</div>
<div class="right"><span class="font-12 contents">Last Updated: [updatedate] ET</span></div></div>%s%s
<div id="js_div" class="col-12" style="width:90%%; margin-left:5%%; "></div>
<div style="text-align:center; width:100%%; display:none; visible:hidden;"><img src="https://lacrossereference.com/wp-content/uploads/2019/03/LaxRefStats.png"></div>""" % (meta_tag_description, social_media_preview_img, social_media_card_text, social_media_card_text, social_media_preview_img, time.time(), time.time(), time.time(), dtop_links_html, mob_links_html,hidden_img, this_stat['dtop_description_html'],  this_stat['mob_description_html'], dtop_ad_div, mob_ad_div)


    content += script_html

    content = content.replace("[updatedate]", datetime.now().strftime("%b %d, %Y %H:%M").replace(" 0", " "))

    if close_DB: cursor.close(); conn.close()
    return content

def tag_shot(shot):
    shot['game_status'] = 'In Doubt'
    if shot['team_odds'] < .25:
        shot['game_status'] = 'Likely Loss'
    elif shot['team_odds'] > .75:
        shot['game_status'] = 'Likely Win'

    shot['leading_status'] = 'winning'
    if shot['game_state'] == 0:
        shot['leading_status'] = 'tied'
    elif shot['game_state'] < 0:
        shot['leading_status'] = 'losing'

    
    shot['quarter_bucket'] = int(max(0,int(min(3599,shot['time_elapsed'])/900))*900)
    shot['shot_clock_remaining_bucket'] = int(max(0,min(79,shot['shot_clock_remaining']))/20)*20
    
    shot['penalty_remaining_bucket'] = None
    if shot['penalty_remaining'] is not None:
        shot['penalty_remaining_bucket'] = int(max(0,shot['penalty_remaining'])/10)*10
    

    shot['possession_started_with_bucket'] = shot['possession_started_with']
    if shot['possession_started_with_bucket'] not in ['Missed Shot', "Penalty", 'Faceoff Win', 'Ground Ball']:
        shot['possession_started_with_bucket'] = "Other"
    return shot

def analyze_shots(team, league, year=None):
    res = {}

    if year is None:
        query = "SELECT a.time_elapsed, a.goalie_ID, a.shooter_ID, a.team_odds, a.weird, a.team_ID,a.penalty_remaining, a.game_state, a.possession_started_with, a.possession_seq, a.shot_clock_remaining, a.on_goal, a.on_keeper, a.man_up, a.goal, a.opp_ID from LaxRef_Shots a, LaxRef_Games b where a.active and b.status like 'complete%%' and b.league=%s and IFNULL(b.simulation,0)=0 and IFNULL(b.game_type,'')='' and year(b.game_date)>2018 and a.game_ID=b.ID and b.active=1"; param = [league]
        all_teams = True


        if team is not None:
            all_teams=False
            query = "SELECT a.time_elapsed, a.goalie_ID, a.shooter_ID, a.team_odds, a.weird, a.team_ID,a.penalty_remaining, a.game_state, a.possession_started_with, a.possession_seq, a.shot_clock_remaining, a.on_goal, a.on_keeper, a.man_up, a.goal, a.opp_ID from LaxRef_Shots a, LaxRef_Games b where a.active and b.status like 'complete%%' and b.league=%s and IFNULL(b.simulation,0)=0 and IFNULL(b.game_type,'')='' and a.team_ID=%s and year(b.game_date)>2018 and a.game_ID=b.ID and b.active=1"; param = [league, team['ID']]
    else:
        query = "SELECT a.time_elapsed, a.goalie_ID, a.shooter_ID, a.team_odds, a.weird, a.team_ID,a.penalty_remaining, a.game_state, a.possession_started_with, a.possession_seq, a.shot_clock_remaining, a.on_goal, a.on_keeper, a.man_up, a.goal, a.opp_ID from LaxRef_Shots a, LaxRef_Games b where a.active and b.status like 'complete%%' and b.league=%s and IFNULL(b.simulation,0)=0 and IFNULL(b.game_type,'')='' and year(b.game_date)=%s and a.game_ID=b.ID and b.active=1"; param = [league, year]
        all_teams = True


        if team is not None:
            all_teams=False
            query = "SELECT a.time_elapsed, a.goalie_ID, a.shooter_ID, a.team_odds, a.weird, a.team_ID,a.penalty_remaining, a.game_state, a.possession_started_with, a.possession_seq, a.shot_clock_remaining, a.on_goal, a.on_keeper, a.man_up, a.goal, a.opp_ID from LaxRef_Shots a, LaxRef_Games b where a.active and b.status like 'complete%%' and b.league=%s and IFNULL(b.simulation,0)=0 and IFNULL(b.game_type,'')='' and a.team_ID=%s and year(b.game_date)=%s and a.game_ID=b.ID and b.active=1"; param = [league, team['ID'], year]
    res = {'team_ID': team['ID'] if not all_teams else "All"}

    conn, cursor = zc.mysql_connect("LR")
    print ("Query %s w/ %s" % (query, param))
    cursor.execute(query, param)
    res['shots'] = zc.dict_query_results(cursor)
    cursor.close(); conn.close()
    



    #rows = [z.split("|") for z in filter(None, open(path, 'r').read().split("\n"))]
    print ("{:<30}{:>10,}".format("Raw rows", len(res['shots'])))
    #res['shots'] = [{'team_ID': team['ID'] if not all_teams else z[1], 'oppID': int(z[1+offset]), 'shooter': z[2+offset], 'game_ID': int(z[0]), 'time_elapsed': int(z[3+offset]), 'possession_elapsed': int(z[4+offset]), 'possession_elapsed_bucket': int(int(z[4+offset])/10)*10, 'goal': int(z[5+offset]), 'possession_seq': int(z[6+offset]), 'goalie': z[7+offset], 'team_odds': float(z[8+offset]), 'margin': float(z[9+offset]), 'weird': float(z[10+offset]), 'on_goal': int(z[11+offset])} for z in rows]
    print ("{:<30}{:>10,}".format("Shot objects", len(res['shots'])))
    for i, shot in enumerate(res['shots']):
        if i % 10000 == 0: print ("Processing shot {:>7,}/{:<7,} at {}".format(i+1, len(res['shots']), datetime.now().strftime("%H:%M:%S")))

        if shot['team_odds'] is None:
            conn, cursor = zc.mysql_connect("LR")
            cursor.execute("SELECT game_ID, count(1) from LaxRef_Shots where time_elapsed=%s and shooter_ID=%s and opp_ID=%s and game_state=%s and shot_clock_remaining=%s and on_goal=%s group by game_ID order by 2 desc", [shot['time_elapsed'], shot['shooter_ID'], shot['opp_ID'], shot['game_state'], shot['shot_clock_remaining'], shot['on_goal']])
            game_IDs = zc.dict_query_results(cursor)
            cursor.close(); conn.close()
            
            msg = "In laxref.analyze_shots, a shot's team_odds (WP at the time of the shot was not set)!!! This must be fixed before the script can be run!!!"
            msg += "\n\nThis error is typically caused by..."
            if len(game_IDs) == 1:
                msg += "\nGameID: %d" % game_IDs[0]['game_ID']
            else:
                msg += "\nPotential GameIDs: %s" % ("; ".join(["%d" % (z['game_ID']) for z in game_IDs]))
            msg += "\nShots: http://192.168.1.240:5000/laxref_query?table=LaxRef_Shots&game_ID=%d" % game_IDs[0]['game_ID']
            msg += "\nGame: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % game_IDs[0]['game_ID']
            msg += "\n%s" % zc.print_dict(shot)
            
            
            print (msg)
            try:
                record_script_completion(script_name, success=False)
            except Exception:
                zc.send_crash("Could not mark script crash; script_name not set (probably).\n\n%s" % traceback.format_exc(), bot_token)
            zc.send_crash(msg, bot_token); zc.exit("SHOT WP NOT SET")
            
        shot = tag_shot(shot)

    #res['shots'] = [z for z in res['shots'] if not z['weird']]
    #print "{:<30}{:>10,}".format("Non-weird", len(res['shots']))

    print ("Done categorizing shots...")
    final_cnt = 8; cnt = 1
    print (" %d/%d (Getting shooters..." % (cnt, final_cnt)); cnt += 1
    if team is None:
        res['shooters'] = []
    else:
        res['shooters'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['shooter'] for y in res['shots']]))]


    print (" %d/%d (Getting game_statuses..." % (cnt, final_cnt)); cnt += 1
    res['game_status'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['game_status'] for y in res['shots']]))]
    print (" %d/%d (Getting leading_statuses..." % (cnt, final_cnt)); cnt += 1
    res['leading_status'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['leading_status'] for y in res['shots']]))]
    print (" %d/%d (Getting started_with..." % (cnt, final_cnt)); cnt += 1
    res['possession_started_with_bucket'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['possession_started_with_bucket'] for y in res['shots']]))]
    print (" %d/%d (Getting possession_sequences..." % (cnt, final_cnt)); cnt += 1
    res['possession_seq'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['possession_seq'] for y in res['shots']]))]
    print (" %d/%d (Getting shot_clock_remaining..." % (cnt, final_cnt)); cnt += 1
    res['shot_clock_remaining_bucket'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['shot_clock_remaining_bucket'] for y in res['shots']]))]
    print (" %d/%d (Getting quarter..." % (cnt, final_cnt)); cnt += 1
    res['quarter_bucket'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['quarter_bucket'] for y in res['shots']]))]
    print (" %d/%d (Getting on_goal..." % (cnt, final_cnt)); cnt += 1
    res['on_goal'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['on_goal'] for y in res['shots']]))]
    print (" %d/%d (Getting man_up buckets..." % (cnt, final_cnt)); cnt += 1
    res['man_up'] = [{'bucket': z, 'cross_tabs': []} for z in list(set([y['man_up'] for y in res['shots']]))]

    print ("Done finding uniques...")

    total = float(len(res['shots']))
    vars = [{'tag': 'shooter', 'data': res['shooters']}, {'tag': 'man_up', 'data': res['man_up']}, {'tag': 'on_goal', 'data': res['on_goal']}, {'tag': 'possession_seq', 'data': res['possession_seq']}, {'tag': 'game_status', 'data': res['game_status']}, {'tag': 'leading_status', 'data': res['leading_status']}, {'tag': 'possession_started_with_bucket', 'data': res['possession_started_with_bucket']}]
    for i, var1 in enumerate(vars):
        print (" %d/%d (%s)" % (i+1, len(vars), var1['tag']))
        for shooter in var1['data']:
            shooter['shots'] = [z for z in res['shots'] if z[var1['tag']] == shooter['bucket']]

            shooter['total_shots'] = float(len(shooter['shots']))
            shooter['total_sog'] = sum([1. for z in shooter['shots'] if z['on_goal']])

        for shooter in var1['data']:
            shooter['share_of_shots'] = shooter['total_shots']/sum([z['total_shots'] for z in var1['data']])
            shooter['total_goals'] = float(len([1. for z in shooter['shots'] if z['goal']]))
            shooter['shooting_percentage'] = None if shooter['total_shots'] == 0 else shooter['total_goals']/shooter['total_shots']
            shooter['shooting_percentage_str'] = "{:.1f}%".format(shooter['shooting_percentage']*100.) if shooter['shooting_percentage'] is not None else "N/A"
            shooter['shooting_percentage_on_goal'] = None if shooter['total_sog'] == 0 else shooter['total_goals']/shooter['total_sog']
            shooter['shooting_percentage_on_goal_str'] = "{:.1f}%".format(shooter['shooting_percentage_on_goal']*100.) if shooter['shooting_percentage_on_goal'] is not None else "N/A"

            shooter['shots'] = None

        """for j, var2 in enumerate(vars):
            if var1['tag'] != var2['tag']:
                for shooter in var1['data']:
                    for shooter2 in var2['data']:
        """
    """
    for shooter in res['possession_sequences']:
        shooter['shots'] = [z for z in res['shots'] if z['possession_seq'] == shooter['possession_seq']]
        shooter['total_shots'] = float(len(shooter['shots']))
        shooter['total_goals'] = float(len([1. for z in shooter['shots'] if z['goal']]))
        shooter['shooting_percentage'] = shooter['total_goals']/shooter['total_shots']

        shooter['shots'] = None
    """
    print (" possession_elapsed_bucket...")
    for shooter in res['shot_clock_remaining_bucket']:
        shooter['shots'] = [z for z in res['shots'] if z['shot_clock_remaining_bucket'] == shooter['bucket']]
        shooter['total_shots'] = float(len(shooter['shots']))
        shooter['total_sog'] = sum([1. for z in shooter['shots'] if z['on_goal']])
        
    for shooter in res['quarter_bucket']:
        shooter['shots'] = [z for z in res['shots'] if z['quarter_bucket'] == shooter['bucket']]
        shooter['total_shots'] = float(len(shooter['shots']))
        shooter['total_sog'] = sum([1. for z in shooter['shots'] if z['on_goal']])

    for shooter in res['shot_clock_remaining_bucket']:
        shooter['share_of_shots'] = shooter['total_shots']/sum([z['total_shots'] for z in var1['data']])

        shooter['total_goals'] = float(len([1. for z in shooter['shots'] if z['goal']]))
        shooter['shooting_percentage'] = shooter['total_goals']/shooter['total_shots'] if shooter['total_shots'] > 0 else None
        shooter['shooting_percentage_str'] = "{:.1f}%".format(shooter['shooting_percentage']*100.) if shooter['shooting_percentage'] is not None else "N/A"
        shooter['shooting_percentage_on_goal'] = shooter['total_goals']/shooter['total_sog'] if shooter['total_sog'] > 0 else None
        shooter['shooting_percentage_on_goal_str'] = "{:.1f}%".format(shooter['shooting_percentage_on_goal']*100.) if shooter['shooting_percentage_on_goal'] is not None else "N/A"
        shooter['shots'] = None
    
    for shooter in res['quarter_bucket']:
        shooter['share_of_shots'] = shooter['total_shots']/sum([z['total_shots'] for z in var1['data']])

        shooter['total_goals'] = float(len([1. for z in shooter['shots'] if z['goal']]))
        shooter['shooting_percentage'] = shooter['total_goals']/shooter['total_shots'] if shooter['total_shots'] > 0 else None
        shooter['shooting_percentage_str'] = "{:.1f}%".format(shooter['shooting_percentage']*100.) if shooter['shooting_percentage'] is not None else "N/A"
        shooter['shooting_percentage_on_goal'] = shooter['total_goals']/shooter['total_sog'] if shooter['total_sog'] > 0 else None
        shooter['shooting_percentage_on_goal_str'] = "{:.1f}%".format(shooter['shooting_percentage_on_goal']*100.) if shooter['shooting_percentage_on_goal'] is not None else "N/A"
        shooter['shots'] = None
    #zc.print_dict(res['possession_sequences'])

    fmt = "{:<10}{:>15}{:>15}{:>15}{:>15}"
    header = fmt.format("Sequence", "Shots", "Goals", "Shooting %", "Pct of Total")
    print ("\n\n" + header + "\n" + ("-"* len(header)))
    tmp_teams = []
    for seq in res['possession_seq']:
        print (fmt.format(seq['bucket'], "{:,}".format(int(seq['total_shots'])), "{:,}".format(int(seq['total_goals'])), "{:.1f}%".format(seq['shooting_percentage']*100.), "{:.1f}%".format(seq['total_shots']/total*100.)))


    fmt = "{:<10}{:>15}{:>15}{:>15}{:>15}"
    header = fmt.format("Shot Clock", "Shots", "Goals", "Shooting %", "Pct of Total")
    print ("\n\n" + header + "\n" + ("-"* len(header)))
    tmp_teams = []
    res['shot_clock_remaining_bucket'] = sorted(res['shot_clock_remaining_bucket'], key=lambda x:x['bucket'])
    for seq in res['shot_clock_remaining_bucket']:
        print (fmt.format(seq['bucket'], "{:,}".format(int(seq['total_shots'])), "{:,}".format(int(seq['total_goals'])), seq['shooting_percentage_str'], "{:.1f}%".format(seq['total_shots']/total*100.)))

    fmt = "{:<10}{:>15}{:>15}{:>15}{:>15}"
    header = fmt.format("Quarter", "Shots", "Goals", "Shooting %", "Pct of Total")
    print ("\n\n" + header + "\n" + ("-"* len(header)))
    tmp_teams = []
    res['quarter_bucket'] = sorted(res['quarter_bucket'], key=lambda x:x['bucket'])
    for seq in res['quarter_bucket']:
        print (fmt.format(seq['bucket'], "{:,}".format(int(seq['total_shots'])), "{:,}".format(int(seq['total_goals'])), seq['shooting_percentage_str'], "{:.1f}%".format(seq['total_shots']/total*100.)))

    fmt = "{:<20}{:>15}{:>15}{:>15}{:>15}"
    header = fmt.format("Game Status", "Shots", "Goals", "Shooting %", "Pct of Total")
    print ("\n\n" + header + "\n" + ("-"* len(header)))
    tmp_teams = []
    #res['game_statuses'] = sorted(res['game_statuses'], key=lambda x:x['game_statuses'])
    for seq in res['game_status']:
        print (fmt.format(seq['bucket'], "{:,}".format(int(seq['total_shots'])), "{:,}".format(int(seq['total_goals'])), seq['shooting_percentage_str'], "{:.1f}%".format(seq['total_shots']/total*100.)))

    fmt = "{:<20}{:>15}{:>15}{:>15}{:>15}"
    header = fmt.format("Started With", "Shots", "Goals", "Shooting %", "Pct of Total")
    print ("\n\n" + header + "\n" + ("-"* len(header)))
    tmp_teams = []
    #res['game_statuses'] = sorted(res['game_statuses'], key=lambda x:x['game_statuses'])
    for seq in res['possession_started_with_bucket']:
        print (fmt.format(seq['bucket'], "{:,}".format(int(seq['total_shots'])), "{:,}".format(int(seq['total_goals'])), seq['shooting_percentage_str'], "{:.1f}%".format(seq['total_shots']/total*100.)))

    fmt = "{:<20}{:>15}{:>15}{:>15}{:>15}"
    header = fmt.format("Leading Status", "Shots", "Goals", "Shooting %", "Pct of Total")
    print ("\n\n" + header + "\n" + ("-"* len(header)))
    tmp_teams = []
    #res['leading_statuses'] = sorted(res['leading_statuses'], key=lambda x:x['leading_statuses'])
    for seq in res['leading_status']:
        print (fmt.format(seq['bucket'], "{:,}".format(int(seq['total_shots'])), "{:,}".format(int(seq['total_goals'])), seq['shooting_percentage_str'], "{:.1f}%".format(seq['total_shots']/total*100.)))


    fmt = "{:<10}{:>15}{:>15}{:>15}{:>15}"
    header = fmt.format("Man-Up", "Shots", "Goals", "Shooting %", "Pct of Total")
    print ("\n\n" + header + "\n" + ("-"* len(header)))
    tmp_teams = []
    for seq in res['man_up']:
        print (fmt.format(seq['bucket'], "{:,}".format(int(seq['total_shots'])), "{:,}".format(int(seq['total_goals'])), seq['shooting_percentage_str'], "{:.1f}%".format(seq['total_shots']/total*100.)))

    return res

def get_stat_summaries(game_ID, stat, home, away, date):
    if os.path.isfile(os.path.join(lr_fldr, 'game_stat_log.csv')):
        stat_summaries = open(os.path.join(lr_fldr, 'game_stat_log.csv'), 'r').read().split("\n")
        #print_stuff("Retrieve stats for %s in %s" % (str(stat), game_ID))
        #print_stuff("\t or %s @ %s on %s" % (away, home, date))
        for s in filter(None, stat_summaries):
            tokens = s.split(",")
            if int(tokens[0]) == game_ID or (tokens[1] == away and tokens[2] == home and tokens[3] == date):
                #print tokens
                return int(tokens[stat]), int(tokens[stat+17])
                # away shots, home shots, away gbs, home gbs
    return None

def print_pos(p, f, all_pos, to_screen):

    log(to_screen, f, "\n\t\t\t[Possession #%03d was taken by %s and it started at %d w/ %s %d" % (p['ID'], "{:<20}".format(p['team']), p['start_time'], p['team'], p['game_state_start']))
    if p['first_shot_time'] is not None:
        log(to_screen, f, "\t\t\t\tGround balls: %s\t Shots (on goal): %s (%d)\tFirst Shot Time: %d" % ("|".join(map(str, p['groundballs'])), "|".join(map(str, p['shots'])), p['shots_on_goal'], p['first_shot_time']))
    else:
        log(to_screen, f, "\t\t\t\tGround balls: %s\t Shots (on goal): %s (%d)" % ("|".join(map(str, p['groundballs'])), "|".join(map(str, p['shots'])), p['shots_on_goal']))
    if p['before_shot'] is not None:
        log(to_screen, f, "\t\t\t\tSecond between start of possession and first shot: %d" % (p['before_shot']))
    #print_shots(p, all_pos, confirmed_away_team)
    #print_goals(p, all_pos, confirmed_away_team)
    #print_gbs(p, all_pos, confirmed_away_team)
    log(to_screen, f, "\t\t\t]")



def get_stats(game_ID):
    if os.path.isfile(os.path.join(lr_fldr, 'sog_log.csv')):
        sog = open(os.path.join(lr_fldr, 'sog_log.csv'), 'r').read().split("\n")
        for s in filter(None, sog[1:]):
            tokens = s.split(",")
            if int(tokens[0]) == game_ID:
                return map(int, tokens[3:7]), map(int, tokens[7:11]), map(int, tokens[11:15]), map(int, tokens[15:19])
                # away shots, home shots, away gbs, home gbs

    return None

def log (p, f, msg):

    if p:
        print_stuff(msg, p)
    if f is not None and False:
        f.write(msg + "\n")

def print_stuff(t, to_screen_val = False):

    if to_screen_val:
        print (t)

def get_game_crash_info(g):
    """
    This function returns the links needed for an admin to debug a game's issues. 
    """
    gID = None
    #print ("g: %s" % str(g))
    if isinstance(g, int):
        #It's the game ID
        gID = g
    elif g is not None: # assume it's a dict
        if 'ID' in g and g['ID'] is not None:
            gID = g['ID']
        elif 'game_ID' in g and g['game_ID'] is not None:
            gID = g['game_ID']
    
    msg = "Could not identify the game ID to run get_game_crash_info:\n\n%s" % str(g)
    if gID is not None:
        
        cursor = zc.zcursor("LR")
        tmp_data = cursor.dqr("Select a.log_url, IFNULL(a.only_box_score, 0) only_box_score, IFNULL(game_type,'') game_type, a.confirmed_home_team, b.ncaa_schedule_url home_ncaa_url, c.ncaa_schedule_url away_ncaa_url, a.status, a.confirmed_away_team, a.ID game_ID, a.league, a.game_date, a.home_score, a.away_score from LaxRef_Games a, LaxRef_Team_Seasons b, LaxRef_Team_Seasons c where b.team_ID=a.home_ID and a.away_ID=c.team_ID and c.year=b.year and a.zgame_year=b.year and b.active and c.active and a.active and a.ID=%s", [gID])[0]
        cursor.close()
        
        msg = "\n\nGame ID: %d" % gID
        msg += "\n\n%s (%s) vs %s (%s) (%s) on %s" % (tmp_data['confirmed_home_team'], tmp_data['home_score'], tmp_data['confirmed_away_team'], tmp_data['away_score'], tmp_data['league'], tmp_data['game_date'].strftime("%b %d, %Y"))
        msg += "\nLog URL: %s" % tmp_data['log_url']
        msg += "\nStatus: %s" % tmp_data['status']
        msg += "\nHome NCAA Schedule: %s" % tmp_data['home_ncaa_url']
        msg += "\nOnly Box Score: %s" % tmp_data['only_box_score']
        msg += "\nGame Type: %s" % tmp_data['game_type']
        msg += "\nGame DB Record: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % gID
        msg += "\nDB Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % gID
        msg += "\nAdmin_cockpit: https://pro.lacrossereference.com/admin_cockpit?dt=%s&game_ID=%d" % (tmp_data['game_date'].strftime("%Y%m%d"), tmp_data['game_ID'])
        msg += "\nAdmin_game: https://pro.lacrossereference.com/admin_game?game_ID=%d" % (tmp_data['game_ID'])
    return msg
    
def assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_sec, play_ID, game_ID, play_obj, from_code):

    if '--show-play-log' in sys.argv:
        print ("showpl: {:<30}{:<10}{:<10}{:<15}{:<15}{:<15}{:<30}{}".format("", "code=%s" % from_code, elapsed_sec, team, "playID=%s" % play_ID, "play=%s" % play, "seq=%s" % play_obj['seq'], play_obj['details']))
    if 0 and cur_pos is None:
        msg = "When processing shots for game ID %s (play ID=%s), an error occurred where the cur_pos object was None, and so no plays could be assigned to it."
                
        msg += "\n\nteam: %s" % team
        msg += "\nplay_obj['details']: %s" % play_obj['details']
        msg += "\n\nplay_obj:\n%s\n" % json.dumps(play_obj) 
        msg += get_game_crash_info(game_ID)
        print (msg)
        zc.send_crash(msg, bot_token)
        zc.exit("Error because of a missing cur_pos")
    if play.startswith("Penalty") and cur_pos is not None:
        cur_pos['penalties'] += 1
    elif play.endswith("Shot") or play.endswith("Goal"):
        if cur_pos['first_shot_time'] is None:
            cur_pos['first_shot_time'] = elapsed_sec
            cur_pos['first_shot_play_seq'] = play_obj['seq']
            #print("\t\t\t\t\t\t\tSet first shot time to %s" % elapsed_sec)
            if cur_pos['first_shot_time'] < cur_pos['start_time'] and cur_pos['first_shot_play_seq'] < cur_pos['first_play_seq']:
                
                
                
                
                if game_ID is not None:
                    msg = "http://localhost:8080/query?table=LaxRef_Events&game_ID=%s" % game_ID
                    
                    conn, cursor = zc.mysql_connect("LR")
                    cursor.execute("SELECT log_url, zgame_year year, league from LaxRef_Games where ID=%s", [game_ID])
                    tmp = zc.dict_query_results(cursor)
                    if len(tmp) > 0:
                        msg += "\nPXP: %s\n" % (tmp[0]['log_url'])
                        msg += "When processing shots for game ID %s (play ID=%s), an error occurred where the shot came (time=%s) before possession started (pos start time=%s)." % (game_ID, play_ID
                        #, cur_pos['first_shot_time']
                        , convert_pct_complete_to_time_str(float(cur_pos['first_shot_time'])/3600., tmp[0]['year'], tmp[0]['league'])
                        #, cur_pos['start_time']
                        , convert_pct_complete_to_time_str(float(cur_pos['start_time'])/3600., tmp[0]['year'], tmp[0]['league'])
                        )
                    else:
                        msg = "When processing shots for game ID %s (play ID=%s), an error occurred where the shot came (time=%d) before possession started (pos start time=%d)." % (game_ID, play_ID
                        , cur_pos['first_shot_time']
                        , cur_pos['start_time']
                        )
                
                    cursor.close(); conn.close();
                    
                    
                else:
                    msg = "When processing shots for game ID %s (play ID=%s), an error occurred where the shot came (time=%d) before possession started (pos start time=%d)." % (game_ID, play_ID
                    , cur_pos['first_shot_time']
                    , cur_pos['start_time']
                    )
                
                msg += "\n\nteam: %s" % team
                msg += "\nplay_obj['details']: %s" % play_obj['details']
                msg += "\n\ncur_pos:\n%s\n" % json.dumps(cur_pos) 
                msg += "\n\nplay_obj:\n%s\n" % json.dumps(play_obj) 
                msg += get_game_crash_info(game_ID)
                print (msg)
                zc.send_crash(msg, bot_token)
                
                zc.exit("laxref0025")
        if play.endswith("Goal"):
            if team == cur_pos['team']:
                cur_pos['game_state_end'] = cur_pos['game_state_start'] + 1
                cur_pos['goal_scored'] = True
                cur_pos['goals'][quarter_loc] += 1
            else:
                msg = ("Uh - oh 493: %s" % play_obj['details']);
                msg += ("\nPlay ID: %s" % play_ID);
                msg += ("\nGame ID: %s" % game_ID);
                msg += ("\nElapsed: %d" % elapsed_sec)
                
                if game_ID is not None:
                    msg = "A play-by-play parsing error has occurred in game ID %d. The following play suggests that a goal was scored by a team that didn't have possession of the ball. Note: this will not prevent processing of the game's data. But wanted to make everyone aware of the issue." % game_ID
                else:
                    msg = "A play-by-play parsing error has occurred in game ID unknown. The following play suggests that a goal was scored by a team that didn't have possession of the ball. Note: this will not prevent processing of the game's data. But wanted to make everyone aware of the issue."
                msg += "\n\nelapsed_sec: %d" % elapsed_sec
                msg += "\nteam: %s" % team 
                msg += "\nplay: %s" % play 
                msg += "\nplay_obj['details']: %s" % play_obj['details']
                
                conn, cursor = zc.mysql_connect("LR")
                cursor.execute("SELECT log_url from LaxRef_Games where ID=%s", [game_ID])
                tmp = zc.dict_query_results(cursor)
                if len(tmp) > 0 and tmp[0]['log_url'] is not None:
                    msg += "\n\nPXP: %s" % (tmp[0]['log_url'])
                cursor.close(); conn.close();
                
                
                # This is going to happen; nothing seems to have been gained by having admins alerted; I can't envision and scenario where this is the only evidence of something going wrong
                if 0 and datetime.now().year > 2022:
                    print (msg);
                    zc.send_telegram(msg)
                cur_pos['data_quality_issue'] = 1
                return cur_pos, consec
        cur_pos['shots'][quarter_loc] += 1
        if play == "Saved Shot" or play.endswith("Goal"):
            cur_pos['shots_on_goal'] += 1
        if play.endswith("Shot") or play.endswith("Goal"):
            cur_pos['total_shots'] += 1
    elif play == "Faceoff Win":
        if "violation" not in play_obj['details'].lower():

            cur_pos['groundballs'][quarter_loc] += 1

    elif cur_pos is not None and play == "Shot Clock On":
        cur_pos['shot_clock_time'] = elapsed_sec - cur_pos['start_time']

    elif play.startswith("Penalty") and cur_pos is not None:
    
        cur_pos['penalties'] += 1

    elif play == "Ground Ball" and cur_pos is not None:

        if cur_pos is not None and team == cur_pos['team']:
            cur_pos['groundballs'][quarter_loc] += 1
        else:
            print("Play ID: %d.\t\tIn possession, a ground ball was picked up by the other team (game %s)..." % (play_ID, game_ID))
            #zc.exit("laxref0026")
            cur_pos['data_quality_issue'] = 1
    
    if play.endswith("Goal"):
        cur_pos['goal'] = 1
    if play == "Assisted Goal":
        cur_pos['assisted_goal'] = 1
        
    # If the shot was saved, then this possession had a save; on any subsequent plays assigned to this possession, we'll use that flag to ensure it's logged as a 2nd chance as necessary
    if cur_pos is not None and cur_pos['had_save']:
        if play.endswith("Turnover") or play.endswith("Goal") or play.endswith("Shot"):
            cur_pos['is_2nd_chance'] = 1
        cur_pos['save_elapsed_sec'] = elapsed_sec
    if play == "Saved Shot":
        cur_pos['had_save'] = 1
    
    
    if cur_pos is not None:
        if elapsed_sec in [d['time'] for d in cur_pos['timestamps']]:
        #    print("\tA - play: %s" % play)
            index = [d['time'] for d in cur_pos['timestamps']].index(elapsed_sec)
            cur_pos['timestamps'][index]['cnt'] += 1
        else:
        #    print("\tB - play: %s" % play)
            cur_pos['timestamps'].append({'time': elapsed_sec, 'cnt': 1})

        if consec > 3:
            cur_pos['weird'][1] = 1
    #print("\t\t%s (%d)" % (str(cur_pos['timestamps']), consec))
    #if len(possessions) > 5:

    return cur_pos, consec

def new_possession(play_obj, play_seq, tp, team, team_ID, play_ID, last_play, play, start_time, game_state, confirmed_away_team, f, to_screen):
    combo = "%s/%s" % (play, last_play)

    weird = [0] * 4 # 4th position is when it was a failed clear but then the team scored
    category = "[Blank]"
    if last_play is None:
        if play == "Faceoff Win" or play == "Shot Clock Violation":
            category = play
        elif play.endswith("Shot"):
            category = "Missed Shot"
        elif play.endswith("Turnover") or play == "Ground Ball" or play == "Failed Clear":
            category = "Ground Ball"
        elif play.startswith("Penalty"):
            category = "Penalty"
        else:
            category = combo
            weird[0] = 1
    else:
        if play == "Faceoff Win" or play == "Shot Clock Violation":
            category = play
        elif play.endswith("Shot"):
            category = "Missed Shot"
        elif play.endswith("Turnover") or play == "Ground Ball" or play == "Failed Clear":
            category = "Ground Ball"
        elif play.startswith("Penalty"):
            category = "Penalty"
        elif play == "Good Clear" and (last_play.endswith("Shot") or last_play == "Ground Ball" or last_play == "Good Clear" or last_play == "Shot Clock On"):
            category = "Ground Ball"
        elif play.endswith("Goal") and last_play == "Faceoff Win":
            category = "Faceoff Win"
        else:
            category = combo
            weird[0] = 1

    if "Goal/Face" in combo:
        weird[0] = 1


    if '--show-play-log' in sys.argv:
        print ("\t\t\tCreate possession #%s for %s team @ %s - started with play: %s - %s/%s (Play ID %s; Play_obj.seq %s)" % (tp, team, start_time, category, play, last_play, play_ID, play_obj['seq']))
    cnt = 1

    if play.endswith("Goal"):
        cnt = 0

    #print ("{:<10}{:<30}{:<30}{:<10}{}".format("@ %s" % start_time, team, confirmed_away_team, team == confirmed_away_team, play))
    if team == confirmed_away_team:

        new_cur_pos = {'first_play_seq': play_obj['seq'], 'ended_with': None, 'goal_scored': False, 'timestamps': [{'time': start_time, 'cnt': cnt}], 'weird': weird, 'started_with': category, 'ID': tp, 'team': team, 'team_ID': team_ID, 'start_time': start_time, 'failed_clear': False, 'end_time': None, 'penalties': 0, 'shots': [0]*10, 'shots_on_goal': 0, 'total_shots': 0, 'groundballs': [0]*10, 'goals': [0]*10, 'first_shot_time': None, 'before_shot': None, 'start_away_score': game_state['away_score'], 'start_home_score': game_state['home_score'], 'game_state_start': -1*game_state['state'], 'game_state_end': None, 'play_ID': play_ID, 'triggered_by': play}
    else:
        new_cur_pos = {'first_play_seq': play_obj['seq'], 'ended_with': None, 'goal_scored': False, 'timestamps': [{'time': start_time, 'cnt': cnt}], 'weird': weird, 'started_with': category, 'ID': tp, 'team': team, 'team_ID': team_ID, 'start_time': start_time, 'failed_clear': False, 'end_time': None, 'penalties': 0, 'shots': [0]*10, 'shots_on_goal': 0, 'total_shots': 0, 'groundballs': [0]*10, 'goals': [0]*10, 'first_shot_time': None, 'before_shot': None, 'start_away_score': game_state['away_score'], 'start_home_score': game_state['home_score'], 'game_state_start': game_state['state'], 'game_state_end': None, 'play_ID': play_ID, 'triggered_by': play}

    new_cur_pos['is_2nd_chance'] = 0
    new_cur_pos['save_elapsed_sec'] = None
    new_cur_pos['had_save'] = 0
    new_cur_pos['goal'] = 0
    new_cur_pos['assisted_goal'] = 0
    
    return new_cur_pos



def new_possession_old(play_seq, tp, team, team_ID, play_ID, last_play, play, start_time, game_state, confirmed_away_team, f, to_screen):
    combo = "%s/%s" % (play, last_play)

    weird = [0] * 4 # 4th position is when it was a failed clear but then the team scored
    category = "[Blank]"
    if last_play is None:
        if play == "Faceoff Win" or play == "Shot Clock Violation":
            category = play
        elif play.endswith("Shot"):
            category = "Missed Shot"
        elif play.endswith("Turnover") or play == "Ground Ball" or play == "Failed Clear":
            category = "Ground Ball"
        elif play.startswith("Penalty"):
            category = "Penalty"
        else:
            category = combo
            weird[0] = 1
    else:
        if play == "Faceoff Win" or play == "Shot Clock Violation":
            category = play
        elif play.endswith("Shot"):
            category = "Missed Shot"
        elif play.endswith("Turnover") or play == "Ground Ball" or play == "Failed Clear":
            category = "Ground Ball"
        elif play.startswith("Penalty"):
            category = "Penalty"
        elif play == "Good Clear" and (last_play.endswith("Shot") or last_play == "Ground Ball" or last_play == "Good Clear" or last_play == "Shot Clock On"):
            category = "Ground Ball"
        elif play.endswith("Goal") and last_play == "Faceoff Win":
            category = "Faceoff Win"
        else:
            category = combo
            weird[0] = 1

    if "Goal/Face" in combo:
        weird[0] = 1


    if '--show-play-log' in sys.argv:
        print ("\t\t\tCreate possession #%d for %s team @ %d - started with play: %s - %s/%s (Play ID %d)" % (tp, team, start_time, category, play, last_play, play_ID))
    cnt = 1

    if play.endswith("Goal"):
        cnt = 0

    #print ("{:<10}{:<30}{:<30}{:<10}{}".format("@ %s" % start_time, team, confirmed_away_team, team == confirmed_away_team, play))
    if team == confirmed_away_team:

        new_cur_pos = {'first_play_seq': play_seq, 'ended_with': None, 'goal_scored': False, 'timestamps': [{'time': start_time, 'cnt': cnt}], 'weird': weird, 'started_with': category, 'ID': tp, 'team': team, 'team_ID': team_ID, 'start_time': start_time, 'failed_clear': False, 'end_time': None, 'penalties': 0, 'shots': [0]*10, 'shots_on_goal': 0, 'total_shots': 0, 'groundballs': [0]*10, 'goals': [0]*10, 'first_shot_time': None, 'before_shot': None, 'start_away_score': game_state['away_score'], 'start_home_score': game_state['home_score'], 'game_state_start': -1*game_state['state'], 'game_state_end': None, 'play_ID': play_ID, 'triggered_by': play}
    else:
        new_cur_pos = {'first_play_seq': play_seq, 'ended_with': None, 'goal_scored': False, 'timestamps': [{'time': start_time, 'cnt': cnt}], 'weird': weird, 'started_with': category, 'ID': tp, 'team': team, 'team_ID': team_ID, 'start_time': start_time, 'failed_clear': False, 'end_time': None, 'penalties': 0, 'shots': [0]*10, 'shots_on_goal': 0, 'total_shots': 0, 'groundballs': [0]*10, 'goals': [0]*10, 'first_shot_time': None, 'before_shot': None, 'start_away_score': game_state['away_score'], 'start_home_score': game_state['home_score'], 'game_state_start': game_state['state'], 'game_state_end': None, 'play_ID': play_ID, 'triggered_by': play}


    return new_cur_pos

def remove_non_ascii(s): return "".join(filter(lambda x: ord(x) < 128, s)) if s is not None else s

def is_conference_tournament(team1, team2, date, team_conferences, conference_dates):
    print_stuff("Search for %s vs %s on %s" % (team1, team2, date))
    if team1 in [z['Team'] for z in team_conferences] and team2 in [z['Team'] for z in team_conferences]:
        conf1 = team_conferences[[z['Team'] for z in team_conferences].index(team1)]['conference']
        conf2 = team_conferences[[z['Team'] for z in team_conferences].index(team2)]['conference']
        print_stuff("Who is in %s" % conf1)
        print_stuff("      and %s" % conf2)
        if conf1 == conf2:
            if conf1 in [z[0] for z in conference_dates]:
                tourney_date = conference_dates[[z[0] for z in conference_dates].index(conf1)][1]
                print_stuff("Who's tourney starts %s" % tourney_date)
                if tourney_date is not None and tourney_date >= date:
                    print_stuff("Which is before or equal to the game date...")
                    return True
    return False

def is_player_on_team(player, team, yr):
    if os.path.isfile(os.path.join(lr_fldr, "PlayerLists", team, "%s" % yr)):
        return player.lower().strip() in [z.lower().strip() for z in filter(None, open(os.path.join(lr_fldr, "PlayerLists", team, "%s" % yr), 'r').read().split("\n"))]
    else:
        return False

def is_player_on_team_from_json(player, teamID, league, yr):
    #print (player)
    #print (teamID)
    #print (league)
    #print (yr)
    if '--roster-year' in sys.argv:
        fname = "dbLaxRef_PlayerList_{}_{}.json".format(sys.argv[sys.argv.index('--roster-year') + 1], league.replace(" ", ""))
    else:
        fname = "dbLaxRef_PlayerList_{}_{}.json".format(yr, league.replace(" ", ""))
    src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GeneralData", fname)
    tmp_data = ""
    if not os.path.isfile(src): return False
    
    tmp_data = open(src, 'r').read()
    if tmp_data in [None, ""]: return False
    data = json.loads(tmp_data)
    tup = (player, teamID)
    for d in data:
        if (d['player'], d['team_ID']) == tup:
            #print ("Found!!!")
            return True
    return False


def calc_RPI_SOR(teams, specs):
    """
    This function calculates the RPI SOR (it must be run after RPI ranks have been established) for each team
    """
    decay = {'wins': .2, 'after_n_wins': 0, 'losses': .3, 'after_n_losses': 0}
    n_teams = len(teams)
    for i, t in enumerate(teams):
        t['raw_RPI_SOR_win_points'] = 0.
        t['raw_RPI_SOR_loss_points'] = 0.
        t['decayed_RPI_SOR_win_points'] = 0.
        t['decayed_RPI_SOR_loss_points'] = 0.
        t['SOR_results'] = []
        t['RPI_SOR'] = None
        t['RPI_SOR_rank'] = None
        t['decayed_RPI_SOR'] = 0.
        t['decayed_RPI_SOR_rank'] = 0.
            
        t['qualifying_games'] = 0
        for j, game in enumerate(t['games']):
            if game['OpponentID'] in [z['ID'] for z in teams]:
                opp = teams[ [z['ID'] for z in teams].index(game['OpponentID']) ]
                opp['non_division'] = 0
            elif 'non_division_teams' in specs and specs['non_division_teams'] is not None:
                #print ("\n\n\ngame record")
                #zc.print_dict(g)
                opp = specs['non_division_teams'][ [z['ID'] for z in specs['non_division_teams']].index(game['OpponentID']) ]
                #zc.exit("Non Div 32432")
                opp['non_division'] = 1
                
                    
            
            
            if not opp['non_division']:
                t['qualifying_games'] += 1
                if game['win']:
                    if opp['RPI_rank'] is not None:
                        t['raw_RPI_SOR_win_points'] += ((n_teams + 1) - opp['RPI_rank'])
                        t['SOR_results'].append({'win': game['win'], 'opp_display_name': opp['display_name'], 'raw_points': ((n_teams + 1) - opp['RPI_rank'])})
                        #print ("{:<40}{:<40}{:<40}{:<40}".format(
                        #"Opp: %s" % (opp['display_name'])
                        #, "(%d / %s)" % (opp['ID'], opp['league'])
                        #, "RPI: %d" % (opp['RPI_rank'])
                        #, "+W: %d" % (((n_teams + 1) - opp['RPI_rank']))
                        #))
                else:
                    if opp['RPI_rank'] is not None:
                        t['raw_RPI_SOR_loss_points'] -= (opp['RPI_rank'])
                        t['SOR_results'].append({'win': game['win'], 'opp_display_name': opp['display_name'], 'raw_points': (-opp['RPI_rank'])})
                        #print ("{:<40}{:<40}{:<40}{:<40}".format(
                        #"Opp: %s" % (opp['display_name'])
                        #, "(%d / %s)" % (opp['ID'], opp['league'])
                        #, "RPI: %d" % (opp['RPI_rank'])
                        #, "-L: %d" % (opp['RPI_rank'] - 1)
                        #))
                
        # Wins
        cur_decay = 1.0
        t['SOR_results'] = sorted(t['SOR_results'], key=lambda x:x['raw_points'], reverse=True)
        for j, game in enumerate(t['SOR_results']):
            if game['win']:
                if j >= decay['after_n_wins']:
                    cur_decay *= (1.0 - decay['wins'])
                game['decay'] = cur_decay
                game['final_points'] = game['raw_points'] * cur_decay
                t['decayed_RPI_SOR_win_points'] += game['final_points']
        
        # Losses
        cur_decay = 1.0
        t['SOR_results'] = sorted(t['SOR_results'], key=lambda x:x['raw_points'])
        if 0 and t['ID'] == 37:
            print ("{:<30}{:<15}{:<15}{:<15}".format("Opponent", "Raw", "Decay", "Final"))
            print ("-" * 75)
        for j, game in enumerate(t['SOR_results']):
            if not game['win']:
                if j >= decay['after_n_losses']:
                    cur_decay *= (1.0 - decay['losses'])
                game['decay'] = cur_decay
                game['final_points'] = game['raw_points'] * cur_decay
                t['decayed_RPI_SOR_loss_points'] += game['final_points']
                if 0 and t['ID'] == 37:
                    print ("{:<30}{:<15.0f}{:<15.3f}{:<15.1f}".format(game['opp']['display_name'], game['raw_points'], game['decay'], game['final_points']))
                    
        t['decayed_RPI_SOR'] = t['decayed_RPI_SOR_win_points'] + t['decayed_RPI_SOR_loss_points']         
        t['RPI_SOR'] = t['raw_RPI_SOR_win_points'] + t['raw_RPI_SOR_loss_points']
     
        
    for i, t in enumerate(teams):
        t['RPI_SOR_rank'] = None if t['RPI_SOR'] is None else len([1 for z in teams if z['league'] == t['league'] and z['RPI_SOR'] is not None and z['RPI_SOR'] > t['RPI_SOR']]) + 1
        t['decayed_RPI_SOR_rank'] = None if t['decayed_RPI_SOR'] is None else len([1 for z in teams if z['league'] == t['league'] and z['decayed_RPI_SOR'] is not None and z['decayed_RPI_SOR'] > t['decayed_RPI_SOR']]) + 1
        
        #t['sum_of_RPI_SOR_ranks'] += float(t['RPI_SOR_rank'])
        #t['sum_of_decayed_RPI_SOR_ranks'] += float(t['decayed_RPI_SOR_rank'])
        
        t['raw_RPI_SOR_win_points_rank'] = None if t['raw_RPI_SOR_win_points'] is None else len([1 for z in teams if z['league'] == t['league'] and z['raw_RPI_SOR_win_points'] is not None and z['raw_RPI_SOR_win_points'] > t['raw_RPI_SOR_win_points']]) + 1
        t['raw_RPI_SOR_loss_points_rank'] = None if t['raw_RPI_SOR_loss_points'] is None else len([1 for z in teams if z['league'] == t['league'] and z['raw_RPI_SOR_loss_points'] is not None and z['raw_RPI_SOR_loss_points'] > t['raw_RPI_SOR_loss_points']]) + 1
        
        t['decayed_RPI_SOR_win_points_rank'] = None if t['decayed_RPI_SOR_win_points'] is None else len([1 for z in teams if z['league'] == t['league'] and z['decayed_RPI_SOR_win_points'] is not None and z['decayed_RPI_SOR_win_points'] > t['decayed_RPI_SOR_win_points']]) + 1
        t['decayed_RPI_SOR_loss_points_rank'] = None if t['decayed_RPI_SOR_loss_points'] is None else len([1 for z in teams if z['league'] == t['league'] and z['decayed_RPI_SOR_loss_points'] is not None and z['decayed_RPI_SOR_loss_points'] > t['decayed_RPI_SOR_loss_points']]) + 1
        
        
        
    return teams
    
def calc_RPI(teams, simple_calc, specs):

    
    RPI_ignore_teams = [z['ID'] for z in teams if not team_is_full_member(z, specs['year'])]


    for t in teams:
        

        if '--as-of' in sys.argv:
            t['games'] = [z for z in t['games'] if datetime.strptime(z['Date'], "%Y-%m-%d %H:%M:%S")  < datetime.strptime(sys.argv[sys.argv.index('--as-of') + 1], "%Y-%m-%d")]

    
    time_logs = [{"start_ms": time.time(), 'seq': 0}]
    for focus_team in teams:

        if team_is_full_member(focus_team, specs['year']) and ('games' not in focus_team or focus_team['games'] in [None, []]):

            pass
            
            #zc.print_dict(focus_team)
            #print ("\n\nNo games found.\n\n")
            #zc.send_crash("RPI team_is_full_member no games error", bot_token)
            #zc.exit("laxref0027")
        for g in focus_team['games']:
            if 'year' not in g:
                if 'Date' in g:
                    g['year'] = datetime.strptime(g['Date'], "%Y-%m-%d").year

                
            if 'win' not in g:
                if 'outcome' in g:
                    g['win'] = True if g['outcome'] == "WIN" else False
            if 'win' not in g:
                msg = "In the calc_RPI process, a game was recorded as neither a win or a loss. The only other time this happened, the game was recorded on the NCAA site as a tie (mistakenly). Since this is a 1 in 10,000 issue, I set the game to manualFinal and updated the score manually in the database.\n\nFor now, this game has been removed from the team's games list, so the RPI calculation will not be accurate until the erroneous game is updated or removed.\n\n%s" % zc.print_dict(g)
                if 30 < datetime.now().minute < 40:
                    zc.send_telegram(msg, bot_token)
        focus_team['games'] = [z for z in focus_team['games'] if 'win' in z]
        focus_team['year_games'] = [z for z in focus_team['games'] if z['year'] == specs['year']]
    time_logs.append({"wins key added": time.time(), 'seq': len(time_logs)})

    RPI_focus_team = None
    if '--rpi-focus-team-ID' in sys.argv:
        RPI_focus_team = int(sys.argv[sys.argv.index('--rpi-focus-team-ID') + 1])
        
    for focus_team in teams:
        DEBUG_RPI=1 if RPI_focus_team is not None and focus_team['ID'] == RPI_focus_team else 0
        if DEBUG_RPI:
            print ("\n\nA) RPI calc for %s" % (focus_team['display_name']))
        focus_team['opp_winning_percentages'] = []
        focus_team['actual_wins_hypothetical'] = 0.
        focus_team['actual_losses_hypothetical'] = 0.
        focus_team['actual_record'] = "N/A"
        
        if team_is_full_member(focus_team, specs['year']) and len(focus_team['year_games']) > 0:
            
    
            focus_team['wins_list'] = [z['OpponentID'] for z in focus_team['year_games'] if z['win'] and z['OpponentID'] not in RPI_ignore_teams]
            focus_team['losses_list'] = [z['OpponentID'] for z in focus_team['year_games'] if not z['win'] and z['OpponentID'] not in RPI_ignore_teams]

            focus_team['actual_wins_hypothetical'] = float(len(focus_team['wins_list']))
            focus_team['actual_losses_hypothetical'] = float(len(focus_team['losses_list']))
            focus_team['actual_record'] = "%d-%d" % (focus_team['actual_wins_hypothetical'], focus_team['actual_losses_hypothetical'])
            
            #input ("{:<30}{:<10}{:<10}{:<10}".format(focus_team['display_name'], focus_team['actual_record'], focus_team['actual_wins_hypothetical'], focus_team['actual_losses_hypothetical']))
    
    
            if focus_team['actual_wins_hypothetical'] + focus_team['actual_losses_hypothetical'] == 0:
                focus_team['win_pct_hypothetical'] = None
            else:
                focus_team['win_pct_hypothetical'] = focus_team['actual_wins_hypothetical']/(focus_team['actual_wins_hypothetical'] + focus_team['actual_losses_hypothetical'])
                
            if DEBUG_RPI:
                print ("\n\nB1) focus_team['win_pct_hypothetical']: %s" % (("%.3f" % focus_team['win_pct_hypothetical']) if focus_team['win_pct_hypothetical'] is not None else "NONE"))
    
        else:
            focus_team['wins_list'] = []
            focus_team['losses_list'] = []

            focus_team['actual_wins_hypothetical'] = 0.
            focus_team['actual_losses_hypothetical'] = 0.
            focus_team['actual_record'] = "0-0"
            focus_team['win_pct_hypothetical'] = None
            
    time_logs.append({"all teams win % calculated": time.time(), 'seq': len(time_logs)})

    for focus_team in teams:
        DEBUG_RPI=1 if RPI_focus_team is not None and focus_team['ID'] == RPI_focus_team else 0
        #if focus_team['ID'] == 751:
        #    print "B) RPI calc for %s" % (focus_team['display_name'])
        
        #focus_team['avg_opp_LaxELO'] = 0.
        #if len(focus_team['year_games']) > 0:
        #    focus_team['avg_opp_LaxELO'] = sum([z['Opponent ELO'] for z in focus_team['year_games']])/float(len(focus_team['year_games']))
        
        if team_is_full_member(focus_team, specs['year']):

            output_logs = {'team': None, 'opps': [], 'opp_opps': []}
            team_wins = {}
            opp_winning_percentages = []
            team_losses = {}
            win_pcts = {}
            opp_wins = {}
            opp_losses = {}
            opp_wins_cnt = 0.
            opp_losses_cnt = 0.
            opp_opp_wins = {}
            opp_opp_losses = {}
            opp_win_pcts = {}
            opp_win_pcts_alt = {}

            # Ignore Hampton and Current Team in opp but in opp/opp add the original opp
            RPI_ignore_teams_opp = RPI_ignore_teams + [focus_team['ID']]



            if 'win_pct_hypothetical' in focus_team and focus_team['win_pct_hypothetical'] is not None:
                opp_opp_win_pct = []

                for g in focus_team['year_games']:
                    t = None
                    if g['OpponentID'] in [z['ID'] for z in teams]:
                        t = teams[ [z['ID'] for z in teams].index(g['OpponentID']) ]
                        t['non_division'] = 0
                    elif 'non_division_teams' in specs and specs['non_division_teams'] is not None:
                        #print ("\n\n\ngame record")
                        #zc.print_dict(g)
                        t = specs['non_division_teams'][ [z['ID'] for z in specs['non_division_teams']].index(g['OpponentID']) ]
                        #zc.exit("Non Div 32432")
                        t['non_division'] = 1
                    else:
                        pass
                        #zc.print_dict(g)
                        
                    #print ("T is none: %s" % (t is None))
                    #print ("specs is none: %s" % (specs is None))
                    #if 'games' not in t:
                    #    zc.print_dict(t)
                    if t['active_this_year'] and team_is_full_member(t, specs['year']) and len(t['games']) > 0:
                        if not t['non_division']:
                            opp_wins = sum([1. for z in t['wins_list'] if z not in RPI_ignore_teams_opp])
                            opp_wins_cnt += opp_wins
                            opp_losses = sum([1. for z in t['losses_list'] if z not in RPI_ignore_teams_opp])
                            opp_losses_cnt += opp_losses

                            tmp_win_pct = 0.
                            if opp_wins + opp_losses > 0:
                                tmp_win_pct = opp_wins/(opp_wins + opp_losses)

                            focus_team['opp_winning_percentages'].append(tmp_win_pct)

                            opp_opp_pct_list = []
                            opp_opp_wins_cnt = 0.
                            opp_opp_losses_cnt = 0.
                            RPI_ignore_teams_opp_opp = RPI_ignore_teams + [t['ID']]


                if opp_wins_cnt + opp_losses_cnt == 0:
                    focus_team['opp_win_pct_hypothetical'] = 0.
                    focus_team['opp_win_pct_hypothetical_old'] = 0.
                    focus_team['opp_opp_win_pct_hypothetical'] = 0.

                else:
                    focus_team['opp_win_pct_hypothetical_old'] =  opp_wins_cnt/(opp_wins_cnt + opp_losses_cnt)
                    focus_team['opp_win_pct_hypothetical'] = None if len(focus_team['opp_winning_percentages']) == 0 else float(sum(focus_team['opp_winning_percentages']))/float(len(focus_team['opp_winning_percentages']))
               
                if DEBUG_RPI:
                    print ("\n\nB2) focus_team['opp_win_pct_hypothetical']: %s (%d - %d)" % (("%.3f" % focus_team['opp_win_pct_hypothetical']) if focus_team['opp_win_pct_hypothetical'] is not None else "NONE", opp_wins_cnt, opp_losses_cnt))
            if '--just-one' in sys.argv: zc.exit("laxref0028")
    time_logs.append({"opponent win % calculated": time.time(), 'seq': len(time_logs)})

    for focus_team in teams:
        DEBUG_RPI=1 if RPI_focus_team is not None and focus_team['ID'] == RPI_focus_team else 0

        if team_is_full_member(focus_team, specs['year']):

            output_logs = {'team': None, 'opps': [], 'opp_opps': []}
            team_wins = {}

            team_losses = {}
            win_pcts = {}
            opp_wins = {}
            opp_losses = {}
            opp_wins_cnt = 0.
            opp_losses_cnt = 0.
            opp_opp_wins = {}
            opp_opp_losses = {}
            opp_win_pcts = {}
            opp_win_pcts_alt = {}


            if 'win_pct_hypothetical' in focus_team and focus_team['win_pct_hypothetical'] is not None:


                opp_opp_win_pct = []

                for g in focus_team['year_games']:
                    t = None
                    if g['OpponentID'] in [z['ID'] for z in teams]:
                        t = teams[ [z['ID'] for z in teams].index(g['OpponentID']) ]
                        t['non_division'] = 0
                    elif 'non_division_teams' in specs and specs['non_division_teams'] is not None:
                        #print ("\n\n\ngame record")
                        #zc.print_dict(g)
                        t = specs['non_division_teams'][ [z['ID'] for z in specs['non_division_teams']].index(g['OpponentID']) ]
                        #zc.exit("Non Div 32432")
                        t['non_division'] = 1
                    
                    
                    if team_is_full_member(t, specs['year']) and not t['non_division']:
                        opp_opp_win_pct.append(t['opp_win_pct_hypothetical'])

                focus_team['opp_opp_win_pct_hypothetical'] = None if len(opp_opp_win_pct) == 0 else sum(opp_opp_win_pct)/float(len(opp_opp_win_pct))


            if '--just-one' in sys.argv: zc.exit("laxref0029")

    time_logs.append({"opponent opponent win % calculated": time.time(), 'seq': len(time_logs)})
    for t in teams:
        DEBUG_RPI=1 if RPI_focus_team is not None and t['ID'] == RPI_focus_team else 0
        if team_is_full_member(t, specs['year']) and len(t['games']) > 0 and t['win_pct_hypothetical'] is not None:
            if '--use-hockey-weights' in sys.argv:
                t['RPI'] = t['win_pct_hypothetical']*.25 + t['opp_win_pct_hypothetical']*.22 + t['opp_opp_win_pct_hypothetical']*.53
            else:
                t['RPI'] = t['win_pct_hypothetical']*.25 + t['opp_win_pct_hypothetical']*.50 + t['opp_opp_win_pct_hypothetical']*.25
        else:
            t['RPI'] = 0.
            t['win_pct_hypothetical'] = 0.
            t['opp_win_pct_hypothetical'] = 0.
            t['opp_opp_win_pct_hypothetical'] = 0.
    for t in teams:
        DEBUG_RPI=1 if RPI_focus_team is not None and t['ID'] == RPI_focus_team else 0
        t['RPI_rank'] = len([1 for z in teams if z['league'] == t['league'] and z['RPI'] > t['RPI']]) + 1
        
        if '--debug-AL' in sys.argv: print ("{:<30}{:>10}{:>10.0f}{:>10.3f}{:>10.3f}{:>10.3f}{:>10.3f}".format(t['display_name'], "%d-%d" % (t['actual_wins_hypothetical'], t['actual_losses_hypothetical']), t['RPI_rank'], t['RPI'], t['win_pct_hypothetical'], t['opp_win_pct_hypothetical'], t['opp_opp_win_pct_hypothetical']))

        #t['LaxELO_rank'] = len([1 for z in teams if z['elo_rating'] > t['elo_rating']]) + 1
        #t['opp_LaxELO_rank'] = len([1 for z in teams if z['avg_opp_LaxELO'] > t['avg_opp_LaxELO']]) + 1

        if 'sum_of_avg_opp_LaxELO_ranks' in t and not specs['pre_seeding']: # If we are calculating RPI to set seeds, don't save the results

            t['sum_of_avg_opp_LaxELO_ranks'] += float(t['opp_LaxELO_rank'])
            
            t['sum_of_SOR_ranks'] += float(t['hypo_SOR_rank'])
            t['sum_of_RPI_ranks'] += float(t['RPI_rank'])
            t['list_of_RPI_ranks'].append(t['RPI_rank'])
            t['sum_of_LaxELOs'] += float(t['elo_rating'])
            t['sum_of_LaxELO_ranks'] += float(t['LaxELO_rank'])
            t['sum_of_wins'] += float(t['actual_wins_hypothetical'])
            t['sum_of_losses'] += float(t['actual_losses_hypothetical'])
    teams = sorted(teams, key=lambda x:x['RPI'], reverse=True)

    buckets = [{'min_RPI': 1, 'max_RPI': 5, 'desc': "1_5"}, {'min_RPI': 6, 'max_RPI': 10, 'desc': "6_10"}, {'min_RPI': 11, 'max_RPI': 20, 'desc': "11_20"}, {'min_RPI': 21, 'max_RPI': 10000, 'desc': "21+"}]


    for t in teams:
        for b in buckets:
            b['wins'] = 0.
            b['losses'] = 0.
            b['wins_list'] = []
            b['losses_list'] = []
        
        t['NCAA_SOS'] = None
        if team_is_full_member(t, specs['year']):
            t['avg_RPI_win'] = 0.
            t['avg_RPI_loss'] = 0.
            opp_RPIs = []
            for g in t['games']:
                opp = None
                if g['OpponentID'] in [z['ID'] for z in teams]:
                    opp = teams[ [z['ID'] for z in teams].index(g['OpponentID']) ]
                    opp['non_division'] = 0
                elif 'non_division_teams' in specs and specs['non_division_teams'] is not None:
                    #print ("\n\n\ngame record")
                    #zc.print_dict(g)
                    opp = specs['non_division_teams'][ [z['ID'] for z in specs['non_division_teams']].index(g['OpponentID']) ]
                    #zc.exit("Non Div 32432")
                    opp['non_division'] = 1
                
            
                if 'win' not in g:
                    if 'outcome' in g:
                        g['win'] = True if g['outcome'] == "WIN" else False
            
                if not opp['non_division']:
                    b_desc = "wins" if g['win'] else "losses"
                    for b in buckets:
                        if b['min_RPI'] <= opp['RPI_rank'] <= b['max_RPI']:
                            b[b_desc] += 1.
                            b["%s_list" % b_desc].append(g['OpponentID'])
                    if g['win']: t['avg_RPI_win'] += float(opp['RPI_rank'])
                    if not g['win']: t['avg_RPI_loss'] += float(opp['RPI_rank'])
                    opp_RPIs.append(opp['RPI_rank'])

            
            if len(opp_RPIs) > 2:
                t['NCAA_SOS'] = statistics.mean(sorted(opp_RPIs)[0:min(10, len(opp_RPIs))])

            
            t['avg_RPI_loss'] = 0 if t['actual_losses_hypothetical'] == 0 else t['avg_RPI_loss'] / float(t['actual_losses_hypothetical'])
            t['avg_RPI_win'] = 0 if t['actual_wins_hypothetical'] == 0 else t['avg_RPI_win'] / float(t['actual_wins_hypothetical'])
            for b in buckets:
                t['vs_%s' % b['desc']] = "%d - %d" % (b['wins'], b['losses'])
                t['wins_vs_%s' % b['desc']] = "%d" % (b['wins'])
                t['losses_vs_%s' % b['desc']] = "%d" % (b['losses'])
                t['wins_vs_%s_list' % b['desc']] = [z for z in b['wins_list']]
                t['losses_vs_%s_list' % b['desc']] = [z for z in b['losses_list']]

    for t in teams:

        t['NCAA_SOS_rank'] = "NA" if t['NCAA_SOS'] is None else (1 + len([z for z in teams if z['NCAA_SOS'] is not None and z['NCAA_SOS'] < t['NCAA_SOS']]))

    if '--print-RPI' in sys.argv:
        teams = sorted(teams, key=lambda x:x['RPI'], reverse=True)
        print(sorted(list(teams[0].keys())))
        print ("{:<30}{:<15}{:>10}{:>10}{:>10}{:>10}{:>10}".format("Team", "Record", "RPI Rank", "RPI.1", "RPI.2", "RPI.3", "RPI"))
        print ("-" * 180)
        for t in teams:
            print ("{:<30}{:<15}{:>10.0f}{:>10.3f}{:>10.3f}{:>10.3f}{:>10.3f}".format(t['display_name'], t['actual_record'], t['RPI_rank'], t['win_pct_hypothetical'], t['opp_win_pct_hypothetical'], t['opp_opp_win_pct_hypothetical'], t['RPI']))

        if '-method' in sys.argv:
            f = open(os.path.join(lr_fldr, "Logs", "RPI_%s_method_%s" % ("Full" if not simple_calc else "Simple", sys.argv[ sys.argv.index('-method') + 1])), 'w')
            for i, t in enumerate(teams):
                f.write("{:<5}{:<30}{:>10}{:>10}{:>10}{:>10}\n".format(i+1, t['display_name'], "%.5f" % t['RPI'], "%.5f" % t['win_pct_hypothetical'], "%.5f" % t['opp_win_pct_hypothetical'], "%.5f" % t['opp_opp_win_pct_hypothetical']))
            f.close()

        zc.exit("laxref0030")
    return teams

def team_is_full_member(t, yr):
    return 1
    if 'full_member' not in t or yr is None:
        return 1
    if yr not in t['full_member']:
        t['full_member'][yr] = None
        tmp_msg = "No full_member designation found for %s (%s) in %d" % (t['display_name'], t['league'], yr)
        print (tmp_msg)
        zc.send_telegram(tmp_msg, bot_token)
        if datetime.now().strftime("%Y%m%d") == "20220101": zc.exit('12312full')
    return t['full_member'][yr]
    
def calculate_SOR(all_teams_even_inactives, team_dict, all_seasons, all_games, orig_yr=datetime.now().year):
    queries = []; params = []
    
    #if 852 in [z['ID'] for z in all_teams_even_inactives]:
    #    zc.print_dict([z for z in all_teams_even_inactives if z['ID'] == 852])
    #input("C: 852 present: %s" % (852 in [z['ID'] for z in all_teams_even_inactives]))
    
    all_teams = [z for z in all_teams_even_inactives if z['active_this_year']]
    if '-league' in sys.argv:
        elo_teams = [z for z in all_teams if 'elo_rating' in z and z['elo_rating'] is not None and z['league'] == sys.argv[sys.argv.index('-league') + 1]]
        if len(elo_teams) > 10:
            top_10_ELO = sorted(elo_teams, key=lambda x:x['elo_rating'], reverse=True)[9]['elo_rating']
        else:
            top_10_ELO = 1600
    else:
        top_10_ELO = 1600

    prior_year = 0
    leagues = [{'league': 'NCAA D1 Women'}, {'league': 'NCAA D1 Men'}, {'league': 'NCAA D2 Women'}, {'league': 'NCAA D2 Men'}, {'league': 'NCAA D3 Women'}, {'league': 'NCAA D3 Men'}]
    if '-league' in sys.argv:
        leagues = [z for z in leagues if z['league'] == sys.argv[sys.argv.index('-league') + 1]]

    for il, l in enumerate(leagues):

        ss_date = [z for z in all_seasons if z['year'] == orig_yr and z['league'] == l['league']][0]['selection_sunday']
        yr = orig_yr
        success = False
        teams = [z for z in all_teams if team_is_full_member(z, yr) and z['league'] == l['league']]
        non_division_teams = [z for z in all_teams if z['league'] != l['league']]
        #input("A: 852 present: %s" % (852 in [z['ID'] for z in non_division_teams]))
        non_division_inactive_teams = [z for z in all_teams_even_inactives if z['league'] != l['league']]
        tmp_existing_IDs = [z['ID'] for z in non_division_teams]
        non_division_teams += [z for z in non_division_inactive_teams if z['ID'] not in tmp_existing_IDs]
        tmp_existing_IDs = [z['ID'] for z in non_division_teams]
        #input("B: 852 present: %s" % (852 in [z['ID'] for z in non_division_teams]))
        non_division_teams += [z for z in all_teams_even_inactives if z['league'] == l['league'] and not z['active_this_year'] and z['ID'] not in tmp_existing_IDs]
        #input("E: 852 present: %s" % (852 in [z['ID'] for z in non_division_teams]))
        
        print ("Calc SOR for league %d/%d (year: %d) -- n teams=%d" % (il+1, len(leagues), yr, len(teams)))
        
        for it, t in enumerate(teams):
            t['NCAA_SOS_rank'] = "NA"
            t['NCAA_SOS'] = None
            t['RPI_rank'] = None
            t['RPI'] = None
            t['all_games'] = [z for z in t['db_games'] if None not in [z['home_elo'], z['away_elo']] and z['game_date'].year == yr]
            for g in t['all_games']:
                if g['home_won'] is None:
                    g['win'] = None
                else:

                    if g['home_won'] and g['home_ID'] == t['ID']:
                        g['win'] = 1
                    elif not g['home_won'] and g['away_ID'] == t['ID']:
                        g['win'] = 1
                    else:
                        g['win'] = 0

                
            t = process_schedule_for_SOS(t, team_dict)
        
        while not success and yr > 2000:
            for it, t in enumerate(teams):

                team1 = t['ID']
                USEELOHISTORY=0
                if USEELOHISTORY:
                    path = os.path.join(lr_fldr, "Post_021", "Teams", "team%04d_ELO_History.csv" % (team1))
                
                    t['games'] = [{'Date': z[0], 'Start ELO': int(z[1]), 'Opponent': z[2], 'OpponentID': int(z[3]), 'Opponent ELO': int(z[4]), 'End ELO': int(z[5])} for z in [y.split(",") for y in filter(None, open(path, 'r').read().split("\n")) if y.startswith("%d" % yr)]]
                else:
                    t['games'] = json.loads(json.dumps([{'Date': z['Date'], 'conference_game': z['conference_game'], 'away_score': z['away_score'], 'home_score': z['home_score'], 'away_elo': z['away_elo'], 'home_elo': z['home_elo'], 'elo_transfer': z['elo_transfer'], 'game_epoch': z['game_epoch'], 'year': z['game_year'], 'home_ID': z['home_ID'], 'away_ID': z['away_ID'], 'home_won': 1 if z['home_score'] > z['away_score'] else 0, 'orig_x': z['game_epoch'], 'Start ELO': z['home_elo'] if z['home_ID'] == team1 else z['away_elo']} for z in all_games if (z['status'] == "manualFinal" or "comp" in z['status']) and z['home_score'] is not None and team1 in [z['home_ID'], z['away_ID']] and z['elo_transfer'] is not None and z['home_score'] != z['away_score']]))
                    for tmp_game in t['games']:
                        tmp_game['OpponentID'] = tmp_game['home_ID'] if team1 == tmp_game['away_ID'] else tmp_game['away_ID']
                        tmp_game['Opponent ELO'] = tmp_game['home_elo'] if team1 == tmp_game['away_ID'] else tmp_game['away_elo']
                        tmp_game['Start ELO'] = tmp_game['home_elo'] if team1 == tmp_game['home_ID'] else tmp_game['away_elo']
                        if team1 == tmp_game['home_ID'] and tmp_game['home_score'] > tmp_game['away_score']:
                            # Home Team and they won
                            tmp_game['End ELO'] = tmp_game['Start ELO'] + tmp_game['elo_transfer']
                        elif team1 == tmp_game['home_ID'] and tmp_game['home_score'] < tmp_game['away_score']:
                            # Home Team and they lost
                            tmp_game['End ELO'] = tmp_game['Start ELO'] - tmp_game['elo_transfer']
                        elif team1 == tmp_game['away_ID'] and tmp_game['home_score'] < tmp_game['away_score']:
                            # Away Team and they won
                            tmp_game['End ELO'] = tmp_game['Start ELO'] + tmp_game['elo_transfer']
                        elif team1 == tmp_game['away_ID'] and tmp_game['home_score'] > tmp_game['away_score']:
                            # Away Team and they lost
                            tmp_game['End ELO'] = tmp_game['Start ELO'] - tmp_game['elo_transfer']
                        
                # Identify the current ELO for the opponent (as opposed to their Elo rating at the time of the game)
                for tmp_game in t['games']:
                    if tmp_game['OpponentID'] in [yx['ID'] for yx in teams]:
                        tmp_game['Opponent Current ELO'] = teams[ [yx['ID'] for yx in teams].index(tmp_game['OpponentID']) ]['elo_rating'] 
                    else:
                        if tmp_game['OpponentID'] not in [yx['ID'] for yx in non_division_teams]:
                            if tmp_game['OpponentID'] not in [yx['ID'] for yx in all_teams_even_inactives]:
                                msg = "[FATAL] a non-division opponent (ID=%d) from the following game was not found in the list of non_division_teams." % (tmp_game['OpponentID'])
                                
                                msg += "\n\n%s" % get_game_crash_info(tmp_game)
                                
                                msg += "\n\nn non-division-teams: {:,}".format(len(non_division_teams))
                                msg += "\n\nn all_teams_even_inactives: {:,}".format(len(all_teams_even_inactives))
                                msg += "\nn all-teams: {:,}".format(len(all_teams))
                                
                                zc.send_crash(msg)
                                zc.exit(msg)
                            else:
                                tmp_game['Opponent Current ELO'] = all_teams_even_inactives[ [yx['ID'] for yx in all_teams_even_inactives].index(tmp_game['OpponentID']) ]['elo_rating'] 
                        else:
                            tmp_game['Opponent Current ELO'] = non_division_teams[ [yx['ID'] for yx in non_division_teams].index(tmp_game['OpponentID']) ]['elo_rating'] 
                        
                #print "\n\nall_teams_even_inactives[0:1]"
                #zc.print_dict(all_teams_even_inactives[0:1])
                #print "\n\nt.keys()"
                #print sorted(t.keys())
                #print "\n\nt['games'][0:1]"
                #zc.print_dict(t['games'][0:1]); 
                t['alt_games'] = sorted([z for z in t['db_games'] if z['elo_transfer'] is not None and z['game_date'].year == yr], key=lambda x:x['game_date'])
                keys = ['Opponent Current ELO', 'Date', 'Start ELO', 'Opponent', 'OpponentID', 'Opponent ELO', 'End ELO']
                
                for g in t['alt_games']:
                    g['Date'] = g['game_date'].strftime("%Y-%m-%d")
                    g['OpponentID'] = g['home_ID'] if g['away_ID'] == t['ID'] else g['away_ID']
                    g['Opponent ELO'] = g['home_elo'] if g['away_ID'] == t['ID'] else g['away_elo']
                    g['Start ELO'] = g['away_elo'] if g['away_ID'] == t['ID'] else g['home_elo']
                    g['win'] = g['home_won'] if g['home_ID'] == t['ID'] else (not g['home_won'])
                    if g['Start ELO'] is None:
                        msg = "Error in calculate_SOR function, elo rating is None for one of the teams in game ID %d. The last time this happened, I had to go back and manually calculate the Elo ratings for the teams by looking at their previous game and applying the elo transfer value. When it happened, the games were marked as status=live. Not really sure what happened to cause that issue.\n\ng record is below\n\n%s" % (g['ID'], zc.print_dict(g))
                        print (msg)
                        zc.send_telegram(msg, bot_token)
                        sys.exit()
                    if g['away_ID'] == t['ID']:
                        if g['home_won']:
                            g['End ELO'] = g['Start ELO'] - g['elo_transfer']
                        else:
                            g['End ELO'] = g['Start ELO'] + g['elo_transfer']
                    else:
                        if g['home_won']:
                            g['End ELO'] = g['Start ELO'] + g['elo_transfer']
                        else:
                            g['End ELO'] = g['Start ELO'] - g['elo_transfer']
                    
                    opp = all_teams_even_inactives[ [z['ID'] for z in all_teams_even_inactives].index(g['OpponentID'])]
                    g['Opponent Current ELO'] = opp['current_elo']
                    g['Opponent'] = opp['name']
                #print "\n\nt['db_games'][0:1] (n=%d)" % len(t['db_games'])
                #zc.print_dict(t['alt_games'][0:1]); 
                msg = "Calculate SOR DB vs EloHistory Approach for Mercer\n\n"
                
                
                if datetime.now().strftime("%Y%m%d") == "202201214" and yr == 2022 and t['ID'] == 56 and len(t['games']) > 0:
                    for i in range(0, len(t['games'])):
                        msg += "\nGame #%d" % (i)
                        for k in keys:
                            msg += "\n%s: New=%s  Old=%s" % (k, t['alt_games'][i][k], t['games'][i][k])
                            
                    msg += "\n\n\nIf this continues to match, then get rid of the Elo History file read and just use the alt-games as games."
                    zc.send_telegram(msg, bot_token)
                
                #zc.exit('t_games')
                
                
                for g in t['games']:
                    if g['End ELO'] == g['Start ELO']:
                        if g['Start ELO'] - g['Opponent ELO'] > 100:
                            g['win'] = 1
                        else:
                            g['win'] = 0
                    else:
                        g['win'] = True if g['End ELO'] > g['Start ELO'] else False

                
                t = process_schedule_for_SOR(t, team_dict, {'year': orig_yr, 'top_10_ELO': top_10_ELO, 'ss_date': ss_date})
                if orig_yr == yr:
                    t['cur_year_SOR'] = t['SOR_diff']
                    queries.append("UPDATE LaxRef_Team_Seasons set strength_of_record=%s where team_ID=%s and year=%s")
                    params.append([t['SOR_diff'], t['ID'], orig_yr])

                if ss_date is not None:
                    t['SOR_diff_pre_ss'] = t['actual_wins_pre_ss'] - t['expected_wins_pre_ss']
                    t['actual_wins_pre_ss'] = int(t['actual_wins_pre_ss'])
                    t['actual_losses_pre_ss'] = int(t['actual_losses_pre_ss'])
                    t['actual_record_pre_ss'] = "%d - %d" % (int(t['actual_wins_pre_ss']), int(t['actual_losses_pre_ss']))
                    t['expected_wins_pre_ss_val'] = t['expected_wins_pre_ss']
                    t['expected_wins_pre_ss'] = "%.2f" % t['expected_wins_pre_ss']

            med_val = statistics.median([z['total_games'] for z in teams])
            # We don't want to show ELO or RPI information until there have been enough games played. When the median team has played 3 games, we are good to go with updated metrics being displayed.
            if med_val >= 3 or '--current-year-only' in sys.argv:
                success = True
            else:
                print ("{:<40}{:>30}{:>30}{:>30}" .format("League: %s" % l['league'], "Year: %d" % yr, "Median Val: %d" % med_val, "Cnt Teams: %d" % len(teams)))
                yr -= 1; prior_year = 1

        if success:
            print ("Calculate RPI...")
            
            for it, t in enumerate(teams):
                t['avg_opp_LaxELO'] = 0.
                if len(t['games']) > 0:
                    t['avg_opp_LaxELO'] = sum([z['Opponent ELO'] for z in t['games']])/float(len(t['games']))
            for it, t in enumerate(teams):
                t['LaxELO_rank'] = None
                t['opp_LaxELO_rank'] = None
                if t['elo_rating'] is not None:
                    t['LaxELO_rank'] = len([1 for z in teams if z['elo_rating'] is not None and z['elo_rating'] > t['elo_rating']]) + 1
                if t['avg_opp_LaxELO'] is not None:
                    t['opp_LaxELO_rank'] = len([1 for z in teams if z['avg_opp_LaxELO'] is not None and z['avg_opp_LaxELO'] > t['avg_opp_LaxELO']]) + 1
               
     
            teams = calc_RPI(teams, False, {'non_division_teams': non_division_teams, 'pre_seeding': False, 'ss_date': ss_date, 'prior_year': prior_year, 'league': l, 'year': yr})
            teams = calc_RPI_SOR(teams, {'non_division_teams': non_division_teams, 'pre_seeding': False, 'ss_date': ss_date, 'prior_year': prior_year, 'league': l, 'year': yr})

            #SOS_teams = sorted([z for z in teams if 'SOS' in z], key=lambda x:x['SOS'], reverse=True)
            with_SOS = sorted([z for z in teams if 'SOS' in z and z['SOS'] is not None], key=lambda x:x['SOS'], reverse=True)
            without_SOS = [z for z in teams if 'SOS' in z and z['SOS'] is  None]
            SOS_teams = with_SOS + without_SOS
            
    if len(queries) > 0:
        conn, cursor = zc.mysql_connect("LR")
        cursor.execute("START TRANSACTION")
        for q, p in zip(queries, params):
            cursor.execute(q, p)
            #print "Query %s w/ %s" % (q, p)
        if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
        cursor.close(); conn.close();
        
    return all_teams, prior_year

def get_goalie(game_obj, play_obj):
    val = None

    
    txt = play_obj['details']
    opp_alt_team = game_obj['away_team'] if play_obj['team'] == game_obj['home_team'] else game_obj['home_team']

    time_regex = re.compile(r'((?:[\[\(])?[0-9]{1,2}:[0-9]{1,2}(?:\)|\])?)')
    match = time_regex.search(txt)
    if match:
        txt = txt.replace(match.group(1), "").strip()

    if " at goalie" in txt:
        val = txt.split(" at goalie")[0]
    elif " AT GOALIE" in txt:
        val = txt.split(" AT GOALIE")[0]
    
    if val is None and ("--%s-starting-goalie" % (play_obj['team'].replace(" ", ""))) in sys.argv:
        val = sys.argv[sys.argv.index("--%s-starting-goalie" % (play_obj['team'].replace(" ", ""))) + 1]
        print("Goalie for %s set to %s" % (play_obj['team'], val))
        
    if val is None:
    
        cursor = zc.zcursor("LR")
        if play_obj['ID'] is None:
            data = None
            tmp_play_detail = play_obj['details']
            if tmp_play_detail.endswith("."):
                tmp_play_detail = tmp_play_detail[0:-1]
            tmp_play_detail = tmp_play_detail.strip()
            
           
            query = "Select a.log_url, a.ID game_ID, a.game_date, b.ID event_ID from LaxRef_Games a, LaxRef_Events b where a.active and b.active and b.game_ID=%s and (b.details like %s or b.details like %s) and b.game_ID=a.ID"
            param = [game_obj['ID'], "%%%s%%" % tmp_play_detail, "%%%s%%" % (tmp_play_detail.replace(" goalie by", " goalie for"))]
            #print (" [2] Query %s w/ %s" % (query, param))
            tmp = cursor.dqr(query, param)
            if len(tmp) > 0:
                data = tmp[0]
        
        else:
            query = "Select a.log_url, a.ID game_ID, a.game_date, b.ID event_ID from LaxRef_Games a, LaxRef_Events b where a.active and b.active and b.ID=%s and b.game_ID=a.ID"
            param = [play_obj['ID']]
            #print (" [1] Query %s w/ %s" % (query, param))
            data = cursor.dqr(query, param)[0]
        
        
        if 'ID' in game_obj and game_obj['ID'] is not None:
            query = "UPDATE LaxRef_Games set processing_error=%s where ID=%s"
            param = ["Could not capture goalie from event (event ID=%s)" % play_obj['ID'], game_obj['ID']]
            cursor.execute(query, param)
        
        db_events = None
        
        if 'ID' in game_obj and game_obj['ID'] is not None:
            # Get a list of the events in this game that came after the missing goalie event
            cursor.execute("SELECT team, details from LaxRef_Events where (game_elapsed_minutes * 60.0 + game_elapsed_seconds + 0.0) / 3600.0 >= %s and active and game_ID=%s order by (game_elapsed_minutes * 60.0 + game_elapsed_seconds + 0.0) asc", [play_obj['pct_complete'], game_obj['ID']])
            db_events = zc.dict_query_results(cursor)
        
        
        cursor.commit()
        cursor.close()
        
        subsequent_goalie = None
        if db_events is not None:
            save_regex = re.compile(r'Shot by .*?SAVE (.+)', re.IGNORECASE)
            for e in db_events:
                if e['team'] != play_obj['team']:
                    print (" Search in %s" % (e['details']))
                    match = save_regex.search(e['details'])
                    if match is not None:
                        subsequent_goalie = match.group(1)
                        break
        
        
        updated_play_obj = 0
        if subsequent_goalie is not None:
            if play_obj['details'].startswith("at goalie"):
                play_obj['details'] = "%s %s" % (subsequent_goalie, play_obj['details'].strip())
                updated_play_obj = 1
        
        if updated_play_obj and 'ID' in play_obj and play_obj['ID'] not in [-1, None, '']:
            
            
            cursor = zc.zcursor("LR")
        
            query = "UPDATE LaxRef_Games set processing_error=NULL where ID=%s"
            param = [data['game_ID']]
        
        
        
            cursor.execute(query, param)
            
            query = "UPDATE LaxRef_Events set details=%s where active and game_ID=%s and ID=%s limit 1"
            param = [play_obj['details'], data['game_ID'], play_obj['ID']]
            print ("Query %s w/ %s" % (query, param))
            cursor.execute(query, param)
            
        
            cursor.commit()
            cursor.close()
        
        
        # Return result if a subsequent goalie was found
        if subsequent_goalie is not None:
            return subsequent_goalie, play_obj, game_obj
        else:
            msg = "(B) Could not capture the goalie in event ID %s from\n\n%s"% (play_obj['ID'], txt)
            msg += "\n\nThis error is typically caused by a play detail that says \"[blank] at goalie for TEAM\". There is literally no player name listed. Typically, in later plays, a save is made and the jersey number is noted as having made the save. We just need to use laxref.cleanse_data (with a pxp url number conditional) to add the player number to the text of the goalie-change play."
            if data is None:
                msg += "\n\n[DATA WAS NONE!!!] Normally, we would re-run this game with the specifics, but based on the ID or text of the play details, we could not find a matching LaxRef_Events ID, and therefore, could not identify the game that this play came from."
                msg += "\n\n\nNote, there is logic that would resolve this issue if the DB had a later shot by the opponent with a goalie listed. (We can just assume that the empty goalie assignment was that player. It did not resolve this instance however, so perhaps the syntax of this particular detail field needs to be added to the logic!!!\n\n\n"
            else:
                msg += "Once the function has been updated, run the following:\n\npython get_official_ncaa_game_data.py --game-ID %d --replace-plays -manual -u %s & python view_game_details.py -g %d --refresh-game-dict" % (data['game_ID'], data['log_url'], data['game_ID'])
                msg += "\n\n\nNote, there is logic that would resolve this issue if the DB had a later shot by the opponent with a goalie listed. (We can just assume that the empty goalie assignment was that player. It did not resolve this instance however, so perhaps the syntax of this particular detail field needs to be added to the logic!!!\n\n\n"
                msg += "\n\nGame ID: %d" % data['game_ID']
                msg += "\nLog URL: %s" % data['log_url']
                msg += "\nGame DB Record: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % data['game_ID']
                msg += "\nDB Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % data['game_ID']
                msg += "\n\nTo reprocess the game with goalies specified ahead of time, use this command\n\npython view_game_details.py -g %d --refresh-game-dict -basic" % game_obj['ID']
                msg += " --%s-starting-goalie [name]" % (game_obj['away_team'].replace(" ", ""))
                msg += " --%s-starting-goalie [name]" % (game_obj['home_team'].replace(" ", ""))
                msg += "\n\nIf replacement_text was needed and you want to re-pull the raw game pxp: python get_official_ncaa_game_data.py --game-ID %d --replace-plays -manual -u %s & python view_game_details.py -g %d --refresh-game-dict" % (data['game_ID'], data['log_url'], data['game_ID'])
                    
            msg += "\n\nDict Obj:\n\n%s" % (zc.print_dict(play_obj))
            print (msg)
            zc.send_crash(msg, bot_token)
            zc.exit("laxref0031")
    else:
        if "," in  val:
            if '--debug-goalie-assignments' in sys.argv:
                print (val)
                print ("becomes")
                print (" ".join([z.strip() for z in (val.split(",")[-1] + " " + " ".join(val.split(",")[0:-1])).split(" ") if z.strip() != ""]))
            val = " ".join([z.strip() for z in (val.split(",")[-1] + " " + " ".join(val.split(",")[0:-1])).split(" ") if z.strip() != ""])
    if '--debug-goalie-assignments' in sys.argv: print ("%s --> %s" % (play_obj['details'], val))
    return val, play_obj, game_obj

def add_pace_statistics_to_game(game):

    hchunks = [{'low': -1, 'high': 30, 'desc': "< 30 sec"}, {'low': 30, 'high': 60, 'desc': "30-59 sec"}, {'low': 60, 'high': 999, 'desc': "60 - 80 sec"}]
    for c in hchunks:
        c['poss'] = 0.
        c['goals'] = 0.
        c['turnovers'] = 0.
        c['total_shots'] = 0.
        c['shots_on_goal'] = 0.

    achunks = [{'low': -1, 'high': 30, 'desc': "< 30 sec"}, {'low': 30, 'high': 60, 'desc': "30-59 sec"}, {'low': 60, 'high': 999, 'desc': "60 - 80 sec"}]
    for c in achunks:
        c['poss'] = 0.
        c['goals'] = 0.
        c['turnovers'] = 0.
        c['total_shots'] = 0.
        c['shots_on_goal'] = 0.

    game['stat_summaries']['home_pacing'] = [z for z in hchunks]
    game['stat_summaries']['away_pacing'] = [z for z in achunks]
    found_a_bad_poss = False
    bad_games = [z.split(",") for z in open(os.path.join(lr_fldr, 'goal_nogoal_possessions'), 'r').read().split("\n") if z.strip() != ""]
    telegrammed = False

    #for i, p in enumerate(game['man_up_opportunities']):
    #    team_type = "away" if p['team'] == game['away_team']['confirmed_team'] else "home"

    for i, p in enumerate(game['possessions']):
        team_type = "away" if p['team'] == game['away_team']['confirmed_team'] else "home"
        if sum(p['weird']) == 0:
            tmp = [z for z in game['stat_summaries'][team_type + "_pacing"] if z['low'] <= p['duration'] < z['high']]
            if len(tmp) > 0:
                if p['ended_with'] is not None and (not p['ended_with'].endswith("Goal")) and p['goal_scored']:
                    found_a_bad_poss = True
                    p['start stamp'] = convert_pct_complete_to_time_str(float(p['start_time'])/3600., game['game_date'].year, game['league'])
                    #print "\n\n****   BAD POSSESSION   ******\n\n"

                    if 'ID' in game and game['ID'] is not None:

                        if not telegrammed and game['ID'] not in [z[0] for z in bad_games]:

                            zc.send_telegram("In game %d, possession #%d did not end with a Goal but a goal was scored during it." % (game['ID'], i+1))
                            bad_g = open(os.path.join(lr_fldr, 'goal_nogoal_possessions'), 'a')
                            bad_g.write("%d,%s,%s\n" % (game['ID'], i, p['start stamp'])); bad_g.close()
                            telegrammed = True
                c = tmp[0]
                c['poss'] += 1.
                c['turnovers'] += (1. if p['ended_with'] is not None and p['ended_with'].endswith("Turnover") else 0.)
                c['goals'] += float(p['goal_scored'])
                c['total_shots'] += float(p['total_shots'])
                c['shots_on_goal'] += float(p['shots_on_goal'])
            else:
                zc.send_telegram ("Could not find a chunk to deal with duration %d" % p['duration'], bot_token)
    if 'ID' in game and game['ID'] is not None:
        if game['ID'] in [z[0] for z in bad_games] and not found_a_bad_poss:
            bad_g = open(os.path.join(lr_fldr, 'goal_nogoal_possessions'), 'w')
            bad_g.write("\n".join([",".join(z) for z in bad_games if z[0] != game['ID']])); bad_g.close()

    for team_type in ["home", "away"]:
        for c in game['stat_summaries'][team_type + "_pacing"]:
            c['avg_shots'] = 0 if c['poss'] == 0 else c['total_shots']/c['poss']
            c['turnover_rate'] = 0 if c['poss'] == 0 else c['turnovers']/c['poss']
            c['sog_pct'] = 0 if c['total_shots'] == 0 else c['shots_on_goal']/c['total_shots']
            c['off_eff'] = 0 if c['poss'] == 0 else c['goals']/c['poss']
            c['pct_of_poss'] = 0. if int(sum([z['poss'] for z in game['stat_summaries'][team_type + "_pacing"]])) == 0 else c['poss']/float(sum([z['poss'] for z in game['stat_summaries'][team_type + "_pacing"]]))
            c['pct_of_goals'] = 0. if int(sum([z['goals'] for z in game['stat_summaries'][team_type + "_pacing"]])) == 0 else c['goals']/float(sum([z['goals'] for z in game['stat_summaries'][team_type + "_pacing"]]))

    return game
    
def team_from_ID():
    cols_per_league = 3

    teams = sorted(zc.file_to_dict(os.path.join(lr_fldr, "Logs", "team_list")), key=lambda x:x['display_name'])
    for t in teams:
        t['str'] = "{:<5}{:<23}  ".format(t['ID'], t['display_name'])
    leagues = [{'league': z, 'ID': i} for i, z in enumerate(list(set([y['league'] for y in teams])))]
    leagues = [z for z in leagues if z['league'] not in ['NLL']]
    for l in leagues:

        l['teams'] = [z for z in teams if z['league'] == l['league']]
        l['num_teams'] = len(l['teams'])
        l['groupings'] = []
        ind = 0
        while ind < l['num_teams']:
            l['groupings'].append("".join([z['str'] for z in l['teams'][ind:ind+cols_per_league]]))
            ind += cols_per_league
        l['num_groupings'] = len(l['groupings'])

    max_groupings = max([z['num_groupings'] for z in leagues])
    ID = None

    rows = ["".join([("{:<%d}" % (cols_per_league * 30)).format(z['league']) for z in leagues])]
    for grouping in range(0, max_groupings + 1):
        row = ""
        for l in leagues:
            if grouping < l['num_groupings']:
                row += l['groupings'][grouping]
            else:
                row += (" " * 30) * cols_per_league

        rows.append(row)


    print ("\n".join(rows))

    ID_entry = raw_input ("\nEnter the ID of the team (|-separated for list): ")
    if "|" in ID_entry:
        return [int(z.strip()) for z in ID_entry.split("|")]
    else:
        return int(ID_entry)


def process_schedule_for_SOR(t, team_dict, specs):
    if specs['top_10_ELO'] is None:
        specs['top_10_ELO'] = 1600.
    expected_wins = 0.0
    expected_wins_hypothetical = 0.0

    t['actual_wins'] = 0.0
    t['actual_losses'] = 0.0
    t['actual_wins_hypothetical'] = 0.0
    t['actual_losses_hypothetical'] = 0.0
    t['conference_actual_wins'] = 0.0
    t['conference_actual_losses'] = 0.0
    t['conference_actual_wins_hypothetical'] = 0.0
    t['conference_actual_losses_hypothetical'] = 0.0

    expected_wins_pre_ss = 0.0
    actual_wins_pre_ss = 0.0
    actual_losses_pre_ss = 0.0

    pre_ss_games = 0
    hypothetical_games = 0

    #opp_elos = []
    
    if '--show-SOR' in sys.argv and int(sys.argv[sys.argv.index('--show-SOR') + 1]) == t['ID']:
         print ("\nEloGames: using reference Elo {}\n\n{:<30}{:<30}{:<10}{:<10}{:<10}{:<30}{:<15}".format(specs['top_10_ELO'], "Opponent", "ID", "GameDayElo", "Avg Elo", "CurrentElo", "Date", "Top 10 Pre-Game WP"))
         
    # Not every script knows to send year as a value in the games list (and some of them are sending more than just this year's games). So if year was not included, but a date field was, use that to set the year value     
    for g in t['games']:
        if 'year' not in g or g['year'] is None:
            if 'Date' in g and g['Date'] is not None and isinstance(g['Date'], str):
                if len(g['Date']) == 10:
                    g['year'] = datetime.strptime(g['Date'], "%Y-%m-%d").year
                elif len(g['Date']) == 8:
                    g['year'] = datetime.strptime(g['Date'], "%Y%m%d").year
                
    tmp_no_year = [z for z in t['games'] if 'year' not in z]
    if len(tmp_no_year) > 0:
        msg = "[FATAL], in SOR calculation, there are games with no year information available. If the keys that are available include date information, just add it here."
        msg += "\nKeys: %s" % (sorted(tmp_no_year[0].keys()))
        msg += "\n\n{}".format(json.dumps(tmp_no_year[0], default=zc.json_handler, indent=1))
        print(msg)
        zc.send_crash(msg, bot_token)
        zc.exit("NO YEAR G")
    games_for_year_in_question = [z for z in t['games'] if z['year'] == specs['year']]
    
    for g in games_for_year_in_question: 
        opp = team_dict[ [z['ID'] for z in team_dict].index(g['OpponentID'])]

        
        if g['Opponent Current ELO'] is None:
            g['Opponent Current ELO'] = 1500.
        opp_elo = (g['Opponent ELO'] + g['Opponent Current ELO'])/2
        #opp_elos.append(opp_elo)
        
        if g['End ELO'] == g['Start ELO']:
            if g['Start ELO'] - g['Opponent ELO'] > 100:
                win = 1
            else:
                win = 0
        else:
            win = True if g['End ELO'] > g['Start ELO'] else False
        
        win_prob = 1.0/(1.0+math.pow(10.0, float(opp_elo - specs['top_10_ELO'])/400.0))

        if '--show-SOR' in sys.argv and int(sys.argv[sys.argv.index('--show-SOR') + 1]) == t['ID']:
            print ("{:<30}{:<30}{:<10.0f}{:<10.0f}{:<10.0f}{:<30}{:<15.3f}".format(opp['display_name'], g['OpponentID'], g['Opponent ELO'], opp_elo, g['Opponent Current ELO'], g['Date'].split(" ")[0] if " " in g['Date'] else g['Date'], win_prob))
        if 'conference_game' not in g:
            if 'OpponentID' not in g:
                print (sorted(g.keys())); 
                msg = "conference_game not in g"
                print (msg)
                zc.send_crash(msg, bot_token)
                zc.exit("laxref0032 - missing OpponentID")
            
            g['conference_game'] = 1 if (t['conference_ID'] == opp['conference_ID']) else 0

        t['actual_wins_hypothetical'] += 1.0 if win else 0.0
        t['actual_losses_hypothetical'] += 1.0 if not win else 0.0

        g_date = datetime.strptime(g['Date'].split(" ")[0] if " " in g['Date'] else g['Date'], "%Y-%m-%d")

        #print t['display_name'], g['conference_game'], g_date

        tournament_game = False
        if t['conf_tournament_start'] is not None:
            #print t['conf_tournament_start'], (t['conf_tournament_start'] + timedelta(seconds = -1))
            #print "Tourney Game: %s" % ((t['conf_tournament_start'] + timedelta(seconds = -1)) < g_date)
            tournament_game = g['conference_game'] and ((t['conf_tournament_start'] + timedelta(seconds = -1)) < g_date)

        t['conference_actual_wins_hypothetical'] += g['conference_game'] if win and not tournament_game else 0.0
        t['conference_actual_losses_hypothetical'] += g['conference_game'] if not win and not tournament_game else 0.0

        expected_wins_hypothetical += win_prob
        hypothetical_games += 1

        if not ('loser' in g or ('hypo' in g and g['hypo'])):


            t['actual_wins'] += 1.0 if win else 0.0
            t['actual_losses'] += 1.0 if not win else 0.0
            t['conference_actual_wins'] += g['conference_game'] if win else 0.0
            t['conference_actual_losses'] += g['conference_game'] if not win else 0.0
            expected_wins += win_prob

            
            if specs['ss_date'] is not None and g_date <= specs['ss_date']:
                actual_wins_pre_ss += 1.0 if win else 0.0
                actual_losses_pre_ss += 1.0 if not win else 0.0
                expected_wins_pre_ss += win_prob
                pre_ss_games += 1
    
    if '--show-SOR' in sys.argv and int(sys.argv[sys.argv.index('--show-SOR') + 1]) == t['ID']:
        print ("{:<30}{:<30}{:<10}{:<10}{:<10}{:<30}{:<15.3f}".format("Total", "", "", "", "", "", expected_wins_hypothetical))
        
    t['SOR_diff_hypothetical'] = t['actual_wins_hypothetical'] - expected_wins_hypothetical
    t['actual_wins_hypothetical'] = int(t['actual_wins_hypothetical'])
    t['expected_wins_hypothetical'] = "%.2f" % expected_wins_hypothetical
    t['total_games_hypothetical'] = hypothetical_games

    t['SOR_diff'] = t['actual_wins'] - expected_wins
    t['actual_wins'] = int(t['actual_wins'])
    t['expected_wins_val'] = expected_wins
    t['expected_wins'] = "%.2f" % expected_wins
    t['total_games'] = len(games_for_year_in_question)

    t['hypothetical_movement'] = t['SOR_diff_hypothetical'] - t['SOR_diff']

    if specs['ss_date'] is not None:
        t['SOR_diff_pre_ss'] = actual_wins_pre_ss - expected_wins_pre_ss
        t['actual_wins_pre_ss'] = int(actual_wins_pre_ss)
        t['actual_losses_pre_ss'] = int(actual_losses_pre_ss)
        t['expected_wins_pre_ss'] = expected_wins_pre_ss
        t['total_games_pre_ss'] = pre_ss_games

    
    t['actual_record'] = "%d-%d" % (t['actual_wins'], t['actual_losses'])
    #input ("{:<30}{:<10}{:<10}{:<10}{:<10}{:<10}".format(t['display_name'], t['actual_record'], t['actual_wins'], t['actual_losses'], t['actual_wins_hypothetical'], t['actual_losses_hypothetical']))
    t['actual_win_pct'] = 0 if (t['actual_wins'] + t['actual_losses']) == 0 else t['actual_wins']/(t['actual_wins'] + t['actual_losses'])
    t['sim_record'] = "%d-%d" % (t['actual_wins_hypothetical'], t['actual_losses_hypothetical'])
    t['conference_actual_record'] = "%d-%d" % (t['conference_actual_wins'], t['conference_actual_losses'])
    t['conference_sim_record'] = "%d-%d" % (t['conference_actual_wins_hypothetical'], t['conference_actual_losses_hypothetical'])
    return t

def process_schedule_for_SOS(t, team_dict):

    #if t['ID'] == 28:
    #    print ("\n\n")
    opp_elos = []
    nc_opp_elos = []
    msg_sent = 0
    for g in t['all_games']: 
        g['OpponentID'] = g['away_ID'] if g['home_ID'] == t['ID'] else g['home_ID']
        opp = team_dict[ [z['ID'] for z in team_dict].index(g['OpponentID'])]
        g['Opponent ELO'] = g['away_elo'] if g['home_ID'] == t['ID'] else g['home_elo']
        g['Opponent Current ELO'] = opp['current_elo']
        
        if g['home_won'] is not None and t['ID'] == 29:
            if g['Opponent ELO'] == g['Opponent Current ELO'] and not msg_sent:
                msg = "Potential issue: When calculating OSU's SOS, %s had the same day-of-game Elo rating (%d) and current Elo rating (%d); they should probably be different." % (opp['display_name'], g['Opponent ELO'], g['Opponent Current ELO'])
                zc.send_telegram(msg, bot_token)
                msg_sent = 1
                
        if t['ID'] == 28:
            print ("{:<30}{:<30}{:<10.0f}{:<10.0f}{:<30}".format(opp['display_name'], g['OpponentID'], g['Opponent ELO'], g['Opponent Current ELO'], g['game_date'].strftime("%Y-%m-%d")))
            
        if g['Opponent Current ELO'] is None:
            g['Opponent Current ELO'] = 1500.
        opp_elo = (g['Opponent ELO'] + g['Opponent Current ELO'])/2
        opp_elos.append(opp_elo)
        if not g['conference_game']:
            nc_opp_elos.append(opp_elo)
        


    t['SOS'] = None if len(opp_elos) == 0 else float(sum(opp_elos))/float(len(opp_elos))
    t['non_conf_SOS'] = None if len(nc_opp_elos) == 0 else float(sum(nc_opp_elos))/float(len(nc_opp_elos))
    
    if  t['ID'] == 28 and '--show-team' in sys.argv:
        print ("SOS: %.3f / %.3f = %.3f" % (float(sum(opp_elos)),float(len(opp_elos)), float(sum(opp_elos))/float(len(opp_elos))))
        zc.exit("HOP OPP ELO")
                
    #if t['ID'] == 28:
    #    print "-" * 110
    #    print "{:<30}{:<30}{:<10.0f}{:<10}{:<30}".format("Avg", "", t['SOS'], "", "")
        
    return t



def finish_js_data(objects, fields):
    res = []
    for t in objects:
        d = {}
        for f in fields:
            if 'sort_by' in f and f['sort_by'] not in d:
                d[f['sort_by']] = t[f['sort_by']]
        for i, f in enumerate(fields):
            v = t[f['tag']]
            d[f['tag']] = {'val': v, 'seq': i}
        res.append(d)

    return res

def process_game_shots(plays_list, game_ID, confirmed_away_team, confirmed_home_team, away_ID, home_ID, game_date):
    shots = [z for z in plays_list if z['play_type'].endswith("Goal") or z['play_type'].endswith("Shot")]
    #zc.print_dict(plays_list)
    fmt = "{:<20}{:<20}{:>20}{:>20}{:>20}{:>20}  {}"
    header = fmt.format("Team", "Shooter", "Game Elapsed", "Poss. Elasped", "Goal", "Goalie", "Details")
    #print (header + "\n" + ("-"* len(header)))
    tmp_teams = []
    for shot in shots:
        shot['on_goal'] = 1 if (shot['play_type'] in ["Pipe Shot", "Saved Shot"] or shot['play_type'].endswith("Goal")) else 0
        shot['possession_seq'] = len([1 for z in shots if z['poss_ID'] == shot['poss_ID'] and shot['time_elapsed'] > z['time_elapsed']]) + 1
        shot['game_ID'] = game_ID
        shot['opp'] = confirmed_away_team if shot['confirmed_team'] == confirmed_home_team else confirmed_home_team
        shot['oppID'] = away_ID if shot['team_ID'] == home_ID else home_ID
        shot['possession_elapsed'] = shot['time_elapsed'] - shot['poss_start']
        if shot['player1'] in [None, ""]:
            shot['shooter'] = shot['player']
        else:
            shot['shooter'] = shot['player1']
        shot['goal'] = 1 if shot['play_type'].endswith("Goal") else 0
        shot['goal_str'] = "YES" if shot['goal'] == 1 else ""
        #print (fmt.format(shot['confirmed_team'], shot['shooter'], shot['time_elapsed'], shot['possession_elapsed'], shot['goal_str'], shot['goalie'], shot['details']))
        ns = ""
        for d in shot['shooter']:
            if ord(d) == 235:
                ns += "e"
            else:
                ns += d
        shot['shooter'] = ns



        shot['tup'] = {'possession_seq': shot['possession_seq'], 'game_ID': shot['game_ID'], 'oppID': shot['oppID'], 'shooter': shot['shooter'], 'time_elapsed': shot['time_elapsed'], 'possession_elapsed': shot['possession_elapsed'], 'goal': shot['goal']}
    for shot in shots:
        shot['same_time_shots'] = len([1 for z in shots if z['time_elapsed'] == shot['time_elapsed']])
        shot['weird'] = 0
        if shot['possession_elapsed'] ==  0:
            shot['weird'] = 1
        elif shot['same_time_shots'] > 1:
            shot['weird'] = 1

    tmp_teams = list(set([z['team_ID'] for z in shots]))
    for t in tmp_teams:
        fldr = path = os.path.join(lr_fldr, "Logs", "ShotLogs")
        all_shots_path = path = os.path.join(lr_fldr, "Logs", "ShotLogs", "AllShots%d" % game_date.year)
        if os.path.isdir(fldr):
            path = os.path.join(fldr, "team%04d_%d_shots" % (t, game_date.year))

            if not os.path.isfile(path):
                stored_shots = []
            else:
                rows = [z.split("|") for z in filter(None, open(path, 'r').read().split("\n"))]
                stored_shots = [{'oppID': int(z[1]), 'shooter': z[2], 'game_ID': int(z[0]), 'time_elapsed': int(z[3]), 'possession_elapsed': int(z[4]), 'goal': int(z[5]), 'possession_seq': int(z[6])} for z in rows]
            #print "Stored Shots[0]"
            #zc.print_dict( stored_shots[0])
            #print "New Shots"
            new_shots = [z for z in shots if z['tup'] not in stored_shots and z['team_ID'] == t]
            #zc.print_dict(new_shots[0]['tup'])

            #print "There are %d ( out of %d) new shots for %s" % (len(new_shots), len(shots), t)
            #zc.exit("laxref0033")

            f = open(path, 'a')
            for s in new_shots:
                rec = "|".join(map(str,[s['game_ID'], s['oppID'], s['shooter'], s['time_elapsed'], s['possession_elapsed'], s['goal'], s['possession_seq'], s['goalie'], s['team_odds'],s['team_game_state'], s['weird'], s['on_goal']]))
                f.write("%s\n" % rec)
            f.close()

            f = open(all_shots_path, 'a')
            for s in new_shots:
                rec = "|".join(map(str,[s['game_ID'], s['team_ID'], s['oppID'], s['shooter'], s['time_elapsed'], s['possession_elapsed'], s['goal'], s['possession_seq'], s['goalie'], s['team_odds'],s['team_game_state'], s['weird'], s['on_goal']]))
                f.write("%s\n" % rec)
            f.close()

def removereplace_special_chars(s):
    """
    Replace the non-ascii version of characters with the ascii version
    """
    if s is None: return s

    
    if 0 and "Erin" in s:
        for c in s:
            print (c, ord(c))
        zc.exit("KATCH")
    apostrophes = []
    apostrophes.append({'str': chr(226) + chr(128) + chr(153), 'repl': "'"})
    apostrophes.append({'str': chr(226) + chr(63) + chr(63), 'repl': "'"})
    for j, ap in enumerate(apostrophes):
        s = s.replace(ap['str'], ap['repl'])
    
    accented_letters = []
    accented_letters.append({'str': chr(195) + chr(169), 'repl': "e"})
    for j, ap in enumerate(accented_letters):
        s = s.replace(ap['str'], ap['repl'])
            
    return s
    


def hash_player_name(s):

    s = s.replace(" ","")
    s = s.replace(".","")
    s = s.replace("-","")
    s = s.replace("'","")

    s = s.lower().strip()
    return s

def process_player_lists(teams, game_ID, existing_list, existing_seasons_list, alternate_player_names, plays_list, game_date, conn, cursor):

    next_player_ID = None
    print("     {:<95}{:<15}".format("Start existing list player names...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));    
    for l in existing_list:
        for e in l:
            e['hash'] = hash_player_name(e['player'])
            e['tup'] = (e['hash'])
    print("     {:<95}{:<15}".format("Done hash existing list player names...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));    
    def add_player_record_to_DB(p, player_mod, existing_list, next_player_ID, queries, params, t, game_date, game_ID, print_it=False):

        is_individual = 1
        if p['player'].lower() in ['tm', 'team', 'own goal']:
            is_individual = 0
            
        
        
        query = "INSERT INTO LaxRef_Players (ID, player, active, pro_url_tag, is_individual, added_from_game_ID) VALUES (%s, %s, %s, %s, %s, %s)"
        param = [next_player_ID, p['player'], 1, player_name_to_slug(p['player'], next_player_ID, {'game_ID': game_ID}), is_individual, game_ID]
        if print_it: print ("New Player Query: %s w/ %s" % (query,  param))
        queries.append(query); params.append(param)
        t['players_added']  += 1
        p['ID'] = next_player_ID; next_player_ID += 1
        existing_list[player_mod].append(p)
        p['tup_no_team'] = (p['ID'], game_date.year)
        p['tup'] = (p['ID'], t['ID'], game_date.year)

        p['player_added'] = 1
        return p, next_player_ID, existing_list[player_mod], queries, params

    #zc.print_dict(alternate_player_names[0])
    #zc.print_dict([z for z in alternate_player_names if z['player_ID'] == 37596])
    
    for i, t in enumerate(teams):
        t['players_added'] = 0
        print("     {:<95}{:<15}".format(" a.Process Team %d" % (i+1), datetime.now().strftime("%H:%M:%S.%f")[0:-3]));    
    
        team_alternate_player_names = [z for z in alternate_player_names if z['team_ID'] is None or z['team_ID'] == t['ID']]
        for j, p in enumerate(t['players']):
            p['hash'] = hash_player_name(p['player'])
            
            
            
            

            if p['hash'] in [z['alternate_cleaned'] for z in team_alternate_player_names]:
                alternate = team_alternate_player_names[ [z['alternate_cleaned'] for z in team_alternate_player_names].index(p['hash'])]

                msg = "In game %s, we used alternate names to change %s (%s) to %s (player ID: %s)" % (game_ID, p['player'], t['team'], alternate['actual_name'], alternate['player_ID'])

                # If this was a player who's name needed to be switched, then we need to go back and update the player names in all play objects too.
                
                for play in plays_list:
                    if p['hash'] == hash_player_name(play['player']):
                        play['player'] = alternate['actual_name']
                    elif p['hash'] == hash_player_name(play['player1']):
                        play['player1'] = alternate['actual_name']
                    elif p['hash'] == hash_player_name(play['player2']):
                        play['player2'] = alternate['actual_name']
                    elif p['hash'] == hash_player_name(play['player3']):
                        play['player3'] = alternate['actual_name']

                p['player'] = alternate['actual_name']
                p['hash'] = hash_player_name(p['player'])

    
                print (msg)


    queries = []; params = []
    for i, t in enumerate(teams):
        t['players_added'] = 0
        print("     {:<95}{:<15}".format(" b.Process Team %d" % (i+1), datetime.now().strftime("%H:%M:%S.%f")[0:-3]));    
        for j, p in enumerate(t['players']):
            #


            mod = max(min(12, int((ord(p['player'].upper()[0])-65)/2)), 0)

            p['tup'] = (p['hash'])
            if p['tup'] not in [z['tup'] for z in existing_list[mod]]:
                
                print ("{:<40}{:<40}{:<20}".format(p['player'], p['hash'], "NOT FOUND"))
                # [Nov 13, 2023] We should not be automatically adding players in the process of processing a game; these have led to far too many duplicates because of mis-spellings. Players need to be added more manually and then picked up here. These games should trigger a flag being set on the database so that we know we have unknown players in the logs.
                #zc.print_dict(p)
                #zc.exit("PLAYER NOT FOUND")
                if next_player_ID is None:
                    cursor.execute("SELECT IFNULL(max(ID),0)+1 ID from LaxRef_Players", [])
                    next_player_ID = zc.dict_query_results(cursor)[0]['ID']
    
                p, next_player_ID, existing_list[mod], queries, params = add_player_record_to_DB(p, mod, existing_list, next_player_ID, queries, params, t, game_date, game_ID)
            else:
                #print "{:<30}{:<30}{:<10}".format(p['player'], p['hash'], "FOUND")
                p['IDs'] = [z['ID'] for z in existing_list[mod] if z['tup'] == p['tup']]
                p['ID'] = None
                if len(p['IDs']) == 1:
                    p['ID'] == p['IDs'][0]

                p['player_added'] = 0

    print("     {:<95}{:<15}".format("Start existing seasons list hashing...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));    
    for l in existing_seasons_list:
        for e in l:
            e['tup'] = (e['player_ID'], e['team_ID'], int(e['year']))
            e['team_tup'] = (e['player_ID'], e['team_ID'])
            e['tup_no_team'] = (e['player_ID'], int(e['year']))
    print("     {:<95}{:<15}".format("Done existing seasons list hashing...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));    
    
    relevant_players = []
    
    for i, t in enumerate(teams):
        t['player_seasons_added'] = 0
        print("     {:<95}{:<15}".format(" c.Process Team %d" % (i+1), datetime.now().strftime("%H:%M:%S.%f")[0:-3]));    
    
        for j, p in enumerate(t['players']):


            if p['player_added']:
                # Because the player was added, we know we need to add this record too in the Player_Seasons table

                query = "INSERT INTO LaxRef_Player_Seasons (ID, player_ID, team_ID, year, active, added_from_game_ID, date_added, added_from) VALUES ((SELECT IFNULL(max(ID), 0)+1 from LaxRef_Player_Seasons fds), %s, %s, %s, %s, %s, %s, %s)"
                script_name = sys.argv[0].split("\\")[-1]
                param = [p['ID'], t['ID'], game_date.year, 1, game_ID, datetime.now(), "process_player_lists"]
                queries.append(query); params.append(param)
                existing_seasons_list[mod].append({'player_ID': p['ID'], 'team_ID': t['ID'], 'year': game_date.year, 'tup_no_team': (p['ID'], game_date.year), 'team_tup': (p['ID'], t['ID']), 'tup': (p['ID'], t['ID'], game_date.year)})
                t['player_seasons_added']  += 1

            else:
                # Check if there is an ID that is a match for this season / team
                p['season_team_match_found'] = 0; p['other_season_match_found'] = 0
                for ID in p['IDs']:
                    tmp_mod = ID % 13


                    tup = (ID, t['ID'], int(game_date.year))
                    if tup in [z['tup'] for z in existing_seasons_list[tmp_mod]]:
                        p['ID'] = ID
                        p['season_team_match_found'] = 1
                        break


                if p['season_team_match_found']:
                    if not p['player_added'] and p['player'] in ["Jack KELLY", "Ben Ward"]:
                        msg = "We found an existing record for %s (%d) associated with team %d (DON'T ADD NEW)" % (p['player'], p['ID'], t['ID'])
                        #print (msg); zc.send_telegram(msg, bot_token)

                    pass # We are good to go on this player
                else:
                    # If there is not a match for this season/team, check if there is a match for another season/team
                    matched_IDs = []; unmatched_IDs = []
                    for ID in p['IDs']:
                        tmp_mod = ID % 13


                        tup_no_team = (ID, int(game_date.year))
                        if tup_no_team in [z['tup_no_team'] for z in existing_seasons_list[tmp_mod]]:
                            p['other_season_match_found'] = 1
                            matched_IDs.append(ID)
                        else:
                            unmatched_IDs.append({'ID': ID, 'mod': tmp_mod, 'team_ID': t['ID'], 'team_tup': (ID, t['ID']), 'team_match': (ID, t['ID']) in [z['team_tup'] for z in existing_seasons_list[tmp_mod]]})


                    if p['ID'] is None:
                        if len(unmatched_IDs) == 1:
                            p['ID'] = unmatched_IDs[0]['ID']

                            p['unique_teams'] = list(set([z['team_ID'] for z in unmatched_IDs]))
                        elif len(unmatched_IDs) > 1:
                            team_matches = [z for z in unmatched_IDs if z['team_match']]
                            p['unique_teams'] = list(set([z['team_ID'] for z in team_matches]))

                            if len(p['unique_teams']) == 1:

                                msg = "There are multiple potential IDs for %s (out of %d total) (%s), but only 1 (%d) matches to a player season record for team %d in a different year." % (p['player'], len(p['IDs']), "; ".join(map(str, [z['ID'] for z in unmatched_IDs])), team_matches[0]['ID'], t['ID'])
                                p['ID'] = team_matches[0]['ID']


                                #if p['player'].upper() not in ['TEAM']:
                                #    print (msg); zc.send_telegram(msg, bot_token)
                            elif t['ID'] == 103 and p['player'].upper() == "MEREDITH MOORE":
                                msg = "There are at least 3 Meredith Moore's (Vermont [this one], Presb, and Detroit)."
                                print (msg)
                            elif t['ID'] == 105 and p['player'].upper() == "BU":
                                msg = "It's just a team record."
                                print (msg)
                            elif t['ID'] == 177 and p['player'].upper() == "BU":
                                msg = "It's just a team record."
                                print (msg)
                            elif t['ID'] in [186] and p['player'].upper() == "COL":
                                msg = "It's just a team record."
                                print (msg)
                            elif t['ID'] == 151 and p['player'].upper() == "TAYLOR DARRELL":
                                msg = "She transferred from Delaware to Merrimack after '18."
                                print (msg)
                            elif t['ID'] == 104 and p['player'].upper() == "EMMA SCHAIT":
                                msg = "She transferred from Albany to Stony Brook after '16. [She had a mistaken record for St Bonventure, otherwise we wouldn't need this line.]"
                                print (msg)
                            elif t['ID'] == 149 and p['player'].upper() == "CAROLYN CARRERA":
                                msg = "She transferred from Hofstra to Stony Brook after '16."
                                print (msg)
                            elif t['ID'] == 176 and p['player'].upper() == "ANNIE SACHS":
                                msg = "Sachs transferred from RMU to Towson after '17."
                                print (msg)
                            elif t['ID'] == 61 and p['player'].upper() == "JACK BARRON":
                                msg = "Jack Barron transferred from Furman to Utah between the '19 and '20 seasons."
                                print (msg)
                            elif t['ID'] == 51 and p['player'].upper() == "JACK KELLY":
                                msg = "Jack Kelly played at Brown until 2016; there are two other Jack Kelly's."
                                print (msg)
                            elif t['ID'] == 12 and p['player'].upper() == "JAMES BURKE":
                                msg = "James Burke played at PSU and another played at BU; this one played at AFA."
                                print (msg)
                            elif t['ID'] == 36 and p['player'].upper() == "CHASE ROSE":
                                msg = "Chase Rose played at RMU and another played at Bellarmine."
                                print (msg)
                            else:
                                msg = "For team %d (game ID %d), there are multiple potential IDs for %s (out of %d total) (%s) that do not match an existing player season record for the specified team. (One explanation is that a duplicate-name player transferred.)\n\nNote, this is no longer causing the script to exit." % (t['ID'], game_ID, p['player'], len(p['IDs']), "; ".join(map(str, [z['ID'] for z in unmatched_IDs])))


                                #if p['player'].upper() not in ['TEAM', 'TM',  'OWN GOAL', 'EMPTY NET']:
                                #    print (msg); zc.send_telegram(msg, bot_token);
                                

                    if p['ID'] is None or (p['other_season_match_found'] and len(p['unique_teams']) != 1): # There is a different player by the same name tagged to a different team

                        if p['player'].upper() not in ['TEAM', 'OWN GOAL', 'EMPTY NET']:
                            print ("Original (duplicate?) p record\n---------------------------")
                            zc.print_dict(p)

                        player_mod = max(min(12, int((ord(p['player'].upper()[0])-65)/2)), 0)
                        
                        if '--no-short-names' in sys.argv:
                            if len(p['player']) < 10 or p['player'].upper() in ['TEAM', 'OWN GOAL', 'EMPTY NET']:
                                resp = raw_input("New player found for DB addition: %s\n\nAdd player (y) or quit(q): " % p['player']).lower().strip()
                                if resp != "y":
                                    print ("Ok, exiting script...")
                                    zc.exit("laxref0035")
                                
                        if next_player_ID is None:
                            cursor.execute("SELECT IFNULL(max(ID),0)+1 ID from LaxRef_Players", [])
                            next_player_ID = zc.dict_query_results(cursor)[0]['ID']
                        p, next_player_ID, existing_list[player_mod], queries, params = add_player_record_to_DB(p, player_mod, existing_list, next_player_ID, queries, params, t, game_date, game_ID, True)

                        if p['player'].upper() not in ['TEAM', 'OWN GOAL', 'EMPTY NET']:
                            print ("Newly created p record\n---------------------------")
                            zc.print_dict(p)

                            msg = "We have a player season record for %s in %d on a different team." % (p['player'],  game_date.year)

                            print (msg); #zc.send_telegram(msg, bot_token)
                    query = "INSERT INTO LaxRef_Player_Seasons (ID, player_ID, team_ID, year, active, added_from_game_ID, date_added, added_from) VALUES ((SELECT IFNULL(max(ID), 0)+1 from LaxRef_Player_Seasons fds), %s, %s, %s, %s, %s, %s, %s)"
                    if p['ID'] is None:
                        msg =  "Trying to add a player season record for %s (game ID %d), but player.ID is None" % (p['player'], game_ID)
                        print (msg)
                        zc.send_telegram(msg, bot_token); zc.exit("laxref0036")
                    param = [p['ID'], t['ID'], game_date.year, 1, game_ID, datetime.now(), str(sys.argv)[0:25]]
                    queries.append(query); params.append(param)
                    existing_seasons_list[mod].append({'player_ID': p['ID'], 'team_ID': t['ID'], 'year': game_date.year, 'tup_no_team': (p['ID'], game_date.year), 'team_tup': (p['ID'], t['ID']), 'tup': (p['ID'], t['ID'], game_date.year)})
                    t['player_seasons_added']  += 1

        relevant_players += t['players']
    if len(queries) > 0:

        
        print (" Adding %d players & player seasons player seasons to the DB (players: %s, seasons: %s)..." % (len(queries), "; ".join(["%s - %d" % (z['ID'], z['players_added']) for z in teams]), "; ".join(["%s - %d" % (z['ID'], z['player_seasons_added']) for z in teams])))

        cursor.execute("START TRANSACTION")
        for q, p in zip(queries, params):
            if '--print-player-uploads' in sys.argv or '--show-player-uploads' in sys.argv: 
                print ("Query %s w/ %s" % (q, p))
            cursor.execute(q, p)
            
        if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
        print ("\n\n")
    return existing_list, existing_seasons_list, relevant_players, plays_list


def process_possessions(possessions, game_ID, existing, game_date, conn, cursor):

    next_ID = 1
    if len(existing) > 0:
        next_ID = max([z['ID'] for z in existing]) + 1

    for e in existing:
        e['tup'] = (e['team_ID'], e['game_ID'], e['sequence'])

    queries = []; params = []
    possessions_added = 0
    if '--print-possessions' in sys.argv:
        fmt = "{:<10}{:<10.0f}{:<7}{:<12}{:<12}{:<12}".replace(".0f", "")
        print (fmt.format("Start", "Duration", "teamID", 'Goal', 'Turnover', 'Failed Clear'))
        print ("-" * 150)
        
    #print ("Starting with {:,} existing possessions.".format(len([1 for z in existing if z['game_ID'] == game_ID ])))
    for i, p in enumerate(possessions):

        p['raw_seq'] = i+1
        
    for i, p in enumerate(possessions):

        

        seq = i+1#len([1 for z in possessions if z['team_ID'] == p['team_ID'] and p['ID'] >= z['ID']])

        if p['failed_clear'] and p['goal_scored']:
            zc.print_dict(p); zc.exit("laxref0037")
        p['tup'] = (p['team_ID'], game_ID, seq)
        
        if '--print-possessions' in sys.argv:
            print (fmt.format(convert_pct_complete_to_time_str(p['start_time']/3600., datetime.now().year, "NCAA D1 Men"), p['duration'], p['team_ID'], "YES" if p['goal_scored'] else "", "YES" if p['turnover'] else "", "YES" if p['failed_clear'] else "")    )
        if p['tup'] not in [z['tup'] for z in existing]:
            if 'data_quality_issue' not in p:
                p['data_quality_issue'] = None
            p['started_with_short'] = p['started_with'] if len(p['started_with']) <= 45 else p['started_with'][0:45]
            query = "INSERT INTO LaxRef_Possessions (ID, removed, game_ID, opp_ID, team_ID, sequence, goal, num_shots, team_odds, start_time, duration, before_shot, shots_on_goal, started_with, failed_clear, turnover, data_quality_issue, from_play_seq, active) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
            param = [None, p['removed'], game_ID, p['opp_ID'], p['team_ID'], seq, p['goal_scored'], p['total_shots'], p['team_odds'], p['start_time'], p['duration'], p['before_shot'], p['shots_on_goal'], p['started_with_short'], p['failed_clear'], p['turnover'], p['data_quality_issue'], p['first_play_seq'], 1]
            queries.append(query); params.append(param)
            next_ID += 1
            possessions_added  += 1

    if len(queries) > 0:
        print (" Adding %d possessions to the DB..." % (len(queries)))
        n = float(len(queries))
        start_ms = time.time()
        if '--use-fast-upload' not in sys.argv:
            cursor.execute("SELECT IFNULL(max(ID), 0) + 1 'next_ID' from LaxRef_Possessions", [])
            next_ID = zc.dict_query_results(cursor)[0]['next_ID']
            cursor.execute("START TRANSACTION")
            for q, p in zip(queries, params):
                p[0] = next_ID; next_ID += 1
                cursor.execute(q, p)
            if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
        else:
            cursor.execute("SELECT IFNULL(max(ID), 0) + 1 'next_ID' from LaxRef_Possessions", [])
            next_ID = zc.dict_query_results(cursor)[0]['next_ID']
            #cursor.execute("START TRANSACTION")
            param_list = []
            for q, p in zip(queries, params):
                p[0] = next_ID; next_ID += 1
                param_list.append(p)

            cursor.executemany(queries[0], param_list)
            print ("  Inserted {:,} rows".format(cursor.rowcount))
            if '--no-commit' not in sys.argv: conn.commit()

        end_ms = time.time()
        per_n = (end_ms - start_ms)/n



        print ("  It took %.3f seconds per possession" % (per_n))

def process_game_stretches(stretches, game_ID, existing, game_date, conn, cursor):

    
    for e in existing:
        e['tup'] = (e['team_ID'], e['game_ID'], e['seq'])

    queries = []; params = []
    game_stretches_added = 0
        
    stretches = sorted(stretches, key=lambda x:x['start_pct_complete'])    
    #print ("Starting with {:,} existing possessions.".format(len([1 for z in existing if z['game_ID'] == game_ID ])))
    seq = 1
    for i, stretch in enumerate(stretches):

        tmp_tags = ['mine', 'theirs']
        for j, tmp_tag in enumerate(tmp_tags):
            p = stretch['splits'][tmp_tag]
            p['seq'] = seq
            p['game_order'] = i+1
            seq += 1
            
    for i, stretch in enumerate(stretches):

        tmp_tags = ['mine', 'theirs']
        team1_ID = stretch['splits']['mine']['team_ID']
        team2_ID = stretch['splits']['theirs']['team_ID']

        for j, tmp_tag in enumerate(tmp_tags):
            p = stretch['splits'][tmp_tag]
            p['opp_ID'] = team1_ID if p['team_ID'] == team2_ID else team2_ID
            p['tup'] = (p['team_ID'], game_ID, p['seq'])
            
            if p['tup'] not in [z['tup'] for z in existing]:
                #print("\n Stretch")
                #zc.print_dict(stretch)
                #print("\n Team Split")
                #zc.print_dict(p)
                
                query = "INSERT INTO LaxRef_Game_Stretches (seq, game_order, game_ID, team_ID, opp_ID, active, start_wp, end_wp, start_pct_complete, end_pct_complete, time_to_first_shot, avg_poss_duration, gbs, shots, goals, assists, possessions, turnovers, sog, total_poss_duration, possession_pct, pct_of_possessions, sog_rate, on_goal_shooting_pct, shooting_pct, efficiency, turnover_rate, shots_per_possession) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
                param = [p['seq']
                , p['game_order']
                , game_ID
                , p['team_ID']
                , p['opp_ID']
                , 1
                , p['start_wp']
                , p['end_wp']
                , stretch['start_pct_complete']
                , stretch['end_pct_complete']
                , p['time_to_first_shot']
                , None if p['avg_poss_duration'] is None else float(p['avg_poss_duration'].replace("s", ""))
                , p['gbs']
                , p['shots']
                , p['goals']
                , p['assists']
                , p['n']
                , p['turnovers']
                , p['sog']
                , p['total_poss_duration']
                , p['possession_pct']
                , p['pct_of_possessions']
                , p['sog_rate']
                , p['on_goal_shooting_pct']
                , p['shooting_pct']
                , p['efficiency']
                , p['turnover_rate']
                , p['shots_per_possession']]
                queries.append(query); params.append(param)
                game_stretches_added  += 1

    if len(queries) > 0:
        print (" Adding %d game_stretches to the DB..." % (len(queries)))
        n = float(len(queries))
        start_ms = time.time()
        if '--use-fast-upload' not in sys.argv:
            cursor.execute("START TRANSACTION")
            for q, p in zip(queries, params):

                cursor.execute(q, p)
                print ("Query %s w/ %s" % (q, p))
            if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
        else:
            param_list = []
            for q, p in zip(queries, params):

                param_list.append(p)

            cursor.executemany(queries[0], param_list)
            print ("  Inserted {:,} rows".format(cursor.rowcount))
            if '--no-commit' not in sys.argv: conn.commit()

        end_ms = time.time()
        per_n = (end_ms - start_ms)/n



        print ("  It took %.3f seconds per game_stretch" % (per_n))


def process_man_up_opportunities(muos, game_ID, existing, game_date, next_man_up_ID, conn, cursor):

 
    for e in existing:
        e['tup'] = (e['team_ID'], e['game_ID'], e['sequence'])

    queries = []; params = []
    muos_added = 0

    for i, p in enumerate(muos):
        if 'shots' not in p:
            p['shots'] = None

        #if i==0: zc.print_dict(p)
        seq = len([1 for z in muos if z['team_ID'] == p['team_ID'] and p['ID'] >= z['ID']])

        p['tup'] = (p['team_ID'], game_ID, seq)
        if p['tup'] not in [z['tup'] for z in existing]:

            query = "INSERT INTO LaxRef_Man_Up (ID, game_ID, opp_ID, team_ID, sequence, team_odds, start_time, end_time, goals, active, shots_taken) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
            param = [next_man_up_ID, game_ID, p['opp_ID'], p['team_ID'], seq, p['team_odds'], p['start_time'], p['end_time'], p['goals'], 1, p['shots']]
            queries.append(query); params.append(param)
            next_man_up_ID += 1
            muos_added  += 1

    if len(queries) > 0:
        print (" Adding %d man-ups to the DB..." % (len(queries)))
        cursor.execute("START TRANSACTION")
        for q, p in zip(queries, params):
            cursor.execute(q, p)
        if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
    return next_man_up_ID
    
def add_scheduled_game_to_DB(game):
    query = None
    param = None

    return query, param

def ask_for_player_team_clarification(msg):

    if '-quiet' in sys.argv: print (msg)
    zc.send_telegram(msg, bot_token)

    ask_dt = time.time()
    listen_bot = telepot.Bot(token=bot_token)
    go_on = True
    is_home = None
    while go_on:
        res = None
        updates = listen_bot.getUpdates()

        for u in updates:

            msg = u['message']
            if 'text' in msg:
                u['date_str'] = datetime.fromtimestamp(float(msg['date'])).strftime("%I:%M:%S %p")
                u['after'] = True if msg['date'] > ask_dt else False
                u['is_an_answer'] = False
                u['home'] = False
                if u['after'] and ("HOME" in msg['text'].strip().upper() or "AWAY" in msg['text'].strip().upper() or "-1" in msg['text'].strip().upper()):
                    u['is_an_answer'] = True
                    if "HOME" in msg['text'].strip().upper():
                        u['home'] = True; res = "HOME"
                    elif "AWAY" in msg['text'].strip().upper():
                        res = "AWAY"
                    elif "-1" in msg['text'].strip().upper():
                        res = "-1"
        fmt = "{:<10}{:<10}{:<15}{:<10}{:<100}"
        header = fmt.format("Answer?", "HOME?", "Date", "After", "Msg")
        output = "\n\n" + header + "\n" + ("-"* len(header))

        for u in updates:
            if 'is_an_answer' in u:
                output += "\n"+ fmt.format(u['is_an_answer'], u['home'], u['date_str'], u['after'], '' if 'text' not in u['message'] else u['message']['text'])

        print (output)

        if res is not None:
            is_home = res
            go_on = False

        if go_on:
            for ij in range(10):
                time.sleep(1)


    listen_bot = None
    return is_home

def ask_for_yes_or_no(msg):

    if '-quiet' in sys.argv: print (msg)
    zc.send_telegram(msg, bot_token)

    ask_dt = time.time()
    listen_bot = telepot.Bot(token=bot_token)
    go_on = True
    is_home = None
    while go_on:
        res = None
        updates = listen_bot.getUpdates()

        for u in updates:

            msg = u['message']
            if 'text' in msg:
                u['date_str'] = datetime.fromtimestamp(float(msg['date'])).strftime("%I:%M:%S %p")
                u['after'] = True if msg['date'] > ask_dt else False
                u['is_an_answer'] = False
                u['home'] = False
                if u['after'] and ("Y" in msg['text'].strip().upper() or "N" in msg['text'].strip().upper() or "YES" in msg['text'].strip().upper() or "NO" in msg['text'].strip().upper()):
                    u['is_an_answer'] = True
                    if "Y" in msg['text'].strip().upper():
                        return 1
                    elif "N" in msg['text'].strip().upper():
                        return 0

        fmt = "{:<10}{:<15}{:<10}{:<100}"
        header = fmt.format("Answer?", "Date", "After", "Msg")
        output = "\n\n" + header + "\n" + ("-"* len(header))

        for u in updates:
            if 'text' in u['message']:
                output += "\n"+ fmt.format(u['is_an_answer'], u['date_str'], u['after'],u['message']['text'])

        print (output)

        if res is not None:

            go_on = False

        if go_on:
            for ij in range(10):
                time.sleep(1)


    listen_bot = None
    return None



def process_game_shots_db(shots, goalies, possessions, players, game_obj, existing, next_shot_ID, confirmed_away_team, confirmed_home_team, away_ID, home_ID, game_date, league, conn, cursor):
    for ip, p in enumerate(players):
        p['tup'] = (hash_player_name(p['player']))

    def time_t(shot, game_obj, type_t):
        return convert_pct_complete_to_time_str(float(shot['%s_time' % type_t])/3600., game_obj['detail']['date'].year, game_obj['league'])

    
   
    for s in shots:
        if s['goalie'] is None:
            check1 = ('first_%d' % s['oppID']) not in goalies
            opp_alt_team = game_obj['alt_away_team'] if s['team'] == game_obj['alt_home_team'] else game_obj['alt_home_team']
            check1 = ('first_%d' % s['oppID']) not in goalies
            check2 = "--%s-starting-goalie" % (opp_alt_team.replace(" ", "")) not in sys.argv
            
            if check1 and check2:
                # We haven't specified the opponent's starting goalie and the goalie was not found in the pxp
                msg = "Fatal Error occurred (A): shot by %s occurred but goalie was not set: time=%s" % (s['team'], s['time_elapsed']) 
                query = "UPDATE LaxRef_Games set processing_error=%s where ID=%s"
                param = [msg, game_obj['ID']]
                msg += "\n\nGame ID: %d" % game_obj['ID']
                msg += "\n\nQuery %s w/ %s" % (query, param)
                
                ecursor = zc.zcursor("LR")
                db_game = ecursor.dqr("SELECT a.log_url, a.game_date from LaxRef_Games a where a.active and a.ID=%s", [game_obj['ID']])
                ecursor.execute(query, param)
                ecursor.commit()
                ecursor.close()
                
                if len(db_game) > 0:
                    msg += "\n\nGame Date: %s; Log URL: %s" % (db_game[0]['game_date'].strftime("%b %d, %Y").replace(" 0", " "), db_game[0]['log_url'])
                
                
                msg +="\nShot"
                msg += zc.print_dict(s)
                msg += "keys: %s" % sorted(game_obj.keys())
                
                msg += "\n\nTo reprocess the game with goalies specified ahead of time, use this command python view_game_details.py -g %d --refresh-game-dict -basic" % game_obj['ID']
                msg += " --%s-starting-goalie [name]" % (game_obj['alt_away_team'].replace(" ", ""))
                msg += " --%s-starting-goalie [name]" % (game_obj['alt_home_team'].replace(" ", ""))
                
                zc.send_telegram(msg, bot_token)
                
                
                print (msg)
                zc.exit("MISSING GOALIE")
            
            elif check1 and not check2:
                # We couldn't identify the goalie from the pxp, but we did specify it manually in the python call via a flag
                s['goalie'] = sys.argv[sys.argv.index("--%s-starting-goalie" % (opp_alt_team.replace(" ", ""))) + 1]
                goalies['first_%d' % s['oppID']] = s['goalie']
                input("Starting goalie for %s has been set to %s" % (opp_alt_team, s['goalie']))
            else:
                s['goalie'] = goalies['first_%d' % s['oppID']]
         

    for i, shot in enumerate(shots):

        shot['possession_started_with'] = None
        seq_matching_possessions = []
        if shot['goal']:
            time_matching_possessions = [z for z in possessions if not z['removed'] and shot['confirmed_team'] == z['team'] and z['start_time'] <= shot['time_elapsed'] <= z['end_time']]
            seq_matching_possessions = [z for z in possessions if not z['removed'] and shot['confirmed_team'] == z['team'] and z['last_play_seq'] == shot['seq']]
        elif shot['play_type'].endswith("Shot"):
            time_matching_possessions = [z for z in possessions if not z['removed'] and shot['confirmed_team'] == z['team'] and z['start_time'] <= shot['time_elapsed'] <= z['end_time']]
        sequence_wrapping_possessions = [z for z in possessions if not z['removed'] and shot['confirmed_team'] == z['team'] and z['first_play_seq'] < shot['seq'] < z['last_play_seq']]
        goal_match = []; wrap_match = []
        if len(time_matching_possessions) > 1:
            resolved = False
            end_time_match = [z for z in time_matching_possessions if z['end_time'] == shot['time_elapsed']]
            if len(end_time_match) == 1:
                shot['possession_started_with'] = end_time_match[0]['started_with']
                resolved = True
            goal_match = [z for z in time_matching_possessions if z['end_time'] == shot['time_elapsed'] and z['ended_with'].endswith("Goal")]
            wrap_match = [z for z in time_matching_possessions if z['first_play_seq'] <= shot['seq'] <= z['last_play_seq']]
            if not resolved and len(goal_match) == 1:
                shot['possession_started_with'] = goal_match[0]['started_with']
                resolved = True
            if not resolved and len(wrap_match) == 1:
                shot['possession_started_with'] = wrap_match[0]['started_with']
                resolved = True
            if not resolved and len(seq_matching_possessions) == 1:
                shot['possession_started_with'] = seq_matching_possessions[0]['started_with']
                resolved = True


            if not resolved:
                if 1 or '--just-print-them' in sys.argv:
                    f = open(os.path.join(lr_fldr, 'Logs', 'shots_with_multiple_possessions'), 'a')
                    f.write("Game%d,PlaySeq%d\n" % (game_obj['ID'], shot['seq']))
                    f.close()
                else:
                    if shot['ID'] not in [487687]:
                        print ("\n\nShot\n----------------")
                        zc.print_dict(shot);
                        print ("{:<15}{:<15}{:<65}{:<20}{:<20}".format("Time", "Play Seq", "Details", "Goal Matches", "Wrap Matches"))
                        print ("{:<15}{:<15}{:<65}{:<20}{:<20}".format(convert_pct_complete_to_time_str(shot['pct_complete'], game_obj['detail']['date'].year, league), shot['seq'], shot['details'][0:60], len(goal_match), len(wrap_match)))
                        print ("\n\nMatching Time Possessions\n")
                        fmt = "{:<15}{:>15}{:>15}{:>15}{:>15}{:>5}{:>30}{:>35}{:>10}{:>20}"
                        header = fmt.format("Team", "Play Seqs", "Start Time", "End Time", "Duration", "Rem", "Started With", "Ended With", "Play ID", "Play")
                        msg = header + "\n" + "-"*len(header)
                        tmp = sorted([z for z in possessions if abs(z['start_time'] - shot['time_elapsed']) < 300], key=lambda x:x['ID'])

                        msg += "\n" + "\n".join([fmt.format(z['team'], "%d-%d" % (z['first_play_seq'], z['last_play_seq']), time_t(z, game_obj, 'start'), time_t(z, game_obj, 'end'), z['duration'], z['zero_duration_penalty_possession'], z['started_with'], z['ended_with'], z['play_ID'], z['triggered_by']) for z in tmp])
                        msg += "\nGame ID: %d\t\tLog URL: %s\n\n" % (game_obj['ID'], game_obj['log_url'])
                        print (msg)

                        if '-manual' in sys.argv:
                            raw_input("Go On?")
                        else:
                            bot_msg = "Could not match shot to a single possession in %s v %s (ID=%d)" % (shot['confirmed_team'], shot['opp'], game_obj['ID'])
                           
                            
                            print (bot_msg)
                            zc.send_telegram(bot_msg, bot_token)
                            zc.exit("laxref0038")
        elif len(time_matching_possessions) == 0:
            if 1 or '--just-print-them' in sys.argv:
                f = open(os.path.join(lr_fldr, 'Logs', 'shots_with_multiple_possessions'), 'a')
                f.write("Game%d,Play%s\n" % (game_obj['ID'], shot['ID']))
                f.close()
                
            else:
                if game_obj['detail']['date'].strftime("%Y%m%d") == "20170430" and "Shot by MICH Schlosser" in shot['details']:
                    pass # Schlosser scored a goal and got a penalty for unsportsmanlike, somehow Michigan had the ball next, which doesn't make sense
                else:
                    print ("\n\nNo Matching Possession Shot\n")
                    zc.print_dict(shot);
                    print ("{:<15}{:<15}{:<65}{:<20}{:<20}".format("Time", "Play Seq", "Details", "Goal Matches", "Wrap Matches"))
                    print ("{:<15}{:<15}{:<65}{:<20}{:<20}".format(convert_pct_complete_to_time_str(shot['pct_complete'], game_obj['detail']['date'].year, league), shot['seq'], shot['details'][0:60], len(goal_match), len(wrap_match)))
                    fmt = "{:<15}{:>15}{:>15}{:>15}{:>15}{:>5}{:>30}{:>35}{:>10}{:>20}"

                    header = fmt.format("Team", "Play Seqs", "Start Time", "End Time", "Duration", "Rem", "Started With", "Ended With", "Play ID", "Play")
                    msg = header + "\n" + "-"*len(header)

                    msg += "\n" + "\n".join([fmt.format(z['team'], "%d-%d" % (z['first_play_seq'], z['last_play_seq']), time_t(z, game_obj, 'start'), time_t(z, game_obj, 'end'), z['duration'], z['zero_duration_penalty_possession'], z['started_with'], z['ended_with'], z['play_ID'], z['triggered_by']) for z in possessions if abs(z['start_time'] - shot['time_elapsed']) < 200])
                    msg += "\nGame ID: %d\t\tLog URL: %s\n\n" % (game_obj['ID'], game_obj['log_url'])
                    print (msg)
                    
                    bot_msg = "Could not match shot to any possession in %s v %s (ID=%d)" % (shot['confirmed_team'], shot['opp'], game_obj['ID'])
                    print (bot_msg)
                    zc.send_telegram(bot_msg, bot_token)

                    zc.exit("laxref0039")
        else:
            tmp = time_matching_possessions[0]
            shot['possession_started_with'] = tmp['started_with']
        shot['ID']

        shot['on_goal'] = 1 if (shot['play_type'] in ["Pipe Shot", "Saved Shot"] or shot['play_type'].endswith("Goal")) else 0
        shot['on_keeper'] = 1 if (shot['play_type'] in ["Saved Shot"] or shot['play_type'].endswith("Goal")) else 0
        shot['possession_seq'] = len([1 for z in shots if z['poss_ID'] == shot['poss_ID'] and shot['time_elapsed'] > z['time_elapsed']]) + 1
        shot['game_ID'] = game_obj['ID']
        shot['opp'] = confirmed_away_team if shot['confirmed_team'] == confirmed_home_team else confirmed_home_team
        shot['oppID'] = away_ID if shot['team_ID'] == home_ID else home_ID
        shot['possession_elapsed'] = shot['time_elapsed'] - shot['poss_start']
        if shot['player1'] in [None, ""]:
            shot['shooter'] = shot['player']
        else:
            shot['shooter'] = shot['player1']
        
        
        shot['goal'] = 1 if shot['play_type'].endswith("Goal") else 0
        shot['goal_str'] = "YES" if shot['goal'] == 1 else ""
        
        if '--ignore-assists' not in sys.argv:
            shot['assister'] = None
            if shot['goal'] and shot['player3'] not in [None, '']:
                shot['assister'] = shot['player3']
            elif shot['goal'] and shot['player2'] not in [None, '']:
                shot['assister'] = shot['player2']
                
        #print (fmt.format(shot['confirmed_team'], shot['shooter'], shot['time_elapsed'], shot['possession_elapsed'], shot['goal_str'], shot['goalie'], shot['details']))
        shot['tup'] = {'possession_seq': shot['possession_seq'], 'game_ID': shot['game_ID'], 'oppID': shot['oppID'], 'shooter': shot['shooter'], 'time_elapsed': shot['time_elapsed'], 'possession_elapsed': shot['possession_elapsed'], 'goal': shot['goal']}
        
    for shot in shots:
        shot['same_time_shots'] = len([1 for z in shots if z['time_elapsed'] == shot['time_elapsed']])
        shot['weird'] = 0
        if shot['possession_elapsed'] ==  0:
            shot['weird'] = 1
        elif shot['same_time_shots'] > 1:
            shot['weird'] = 1
        shot['assister_ID'] = None
        shot['shooter_ID'] = None
        shot['goalie_ID'] = None
    

    for e in existing:
        e['tup'] = (e['team_ID'], e['game_ID'], e['possession_seq'])

    queries = []; params = []
    shots_added = 0

    start_ms = time.time()
    for i, shot in enumerate(shots):
        shot['free_position'] = 0
        sdl = shot['details'].lower().replace(' ', '')
        if league is not None and "Women" in league and "freeposition" in sdl or "fpgoal" in sdl:
            shot['free_position'] = 1

        if None in [shot['goalie'], shot['shooter']]:
            msg = "Shot Fail: Game ID: %d, shooter_ID=%s, goalie_ID=%s\n%s\n%s vs %s" % (game_obj['ID'], shot['shooter'], shot['goalie'], shot['details'], confirmed_home_team, confirmed_away_team)
            print (msg)

            if '--clear-plays-on-shot-fail' in sys.argv:
                conn, cursor = zc.mysql_connect("LR")
                cursor.execute("UPDATE LaxRef_Events set active=0 where game_ID=%s", [game_obj['ID']])
                cursor.execute("UPDATE LaxRef_Games a set n_db_events=0 where a.ID=%s", [game_obj['ID']])
                conn.commit()
                cursor.close(); conn.close()

            zc.send_telegram(msg, bot_token)

            zc.exit("laxref0040")

        tup = (hash_player_name(shot['shooter']))
        if tup in [z['tup'] for z in players]:
            shot['shooter_ID'] = players[ [z['tup'] for z in players].index(tup) ]['ID']

        tup = (hash_player_name(shot['goalie']))
        if tup in [z['tup'] for z in players]:
            shot['goalie_ID'] = players[ [z['tup'] for z in players].index(tup) ]['ID']

        if '--ignore-assists' not in sys.argv:
            if shot['assister'] is not None:
                tup = (hash_player_name(shot['assister']))
                if tup in [z['tup'] for z in players]:
                    shot['assister_ID'] = players[ [z['tup'] for z in players].index(tup) ]['ID']

    end_ms = time.time()
    for i, p in enumerate(shots):



        if '--play-ID' in sys.argv and p['ID'] == int(sys.argv[sys.argv.index("--play-ID") + 1]):
            zc.print_dict(p)
            zc.exit("laxref0051")
        p['tup'] = (p['team_ID'], p['game_ID'], p['possession_seq'])

        if p['tup'] not in [z['tup'] for z in existing]:
            p['prior_game_state'] = p['team_game_state']
            if p['goal']:
                p['prior_game_state'] -= 1



            query = "INSERT INTO LaxRef_Shots (ID, game_ID, opp_ID, team_ID, possession_seq, team_odds, time_elapsed, possession_elapsed, on_goal, on_keeper, goal, weird, penalty_remaining, game_state, possession_started_with, man_up, shot_clock_remaining, shooter_ID, goalie_ID, assister_ID, free_position, one_pass_free_position, active) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
            param = [next_shot_ID, game_obj['ID'], p['oppID'], p['team_ID'], p['possession_seq'], p['team_odds'], p['time_elapsed'], p['possession_elapsed'], p['on_goal'], p['on_keeper'], p['goal'], p['weird'], p['penalty_remaining'], p['prior_game_state'], p['possession_started_with'], p['is_man_up'], p['shot_clock_remaining'], p['shooter_ID'], p['goalie_ID'], p['assister_ID'], p['free_position'], p['one_pass_free_position'], 1]
            queries.append(query); params.append(param)

            next_shot_ID += 1
            shots_added  += 1

    if len(queries) > 0:
        print (" Adding %d shots to the DB..." % (len(queries)))
        n = float(len(queries)); start_ms = time.time()
        if '--use-fast-upload' not in sys.argv:
            cursor.execute("START TRANSACTION")
            for q, p in zip(queries, params):
                cursor.execute(q, p)
            if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
        else:
            q = queries[0]; param_list = []
            for q, p in zip(queries, params):
                p[0] = next_shot_ID; next_shot_ID += 1
                param_list.append(p)
            cursor.executemany(q, param_list)
            print ("  Uploaded {:,} shots".format(cursor.rowcount))
            if '--no-commit' not in sys.argv: conn.commit()

        end_ms = time.time()
        per_n = (end_ms - start_ms)/n

        print ("  It took %.3f seconds per shot" % (per_n))
    
    return shots, next_shot_ID
    
def process_faceoffs(orig_plays_list, possessions, players, game_obj, existing, confirmed_away_team, confirmed_home_team, away_ID, home_ID, game_date, league, home_team, away_team, next_faceoff_ID, conn, cursor):
    plays_list = [z for z in json.loads(json.dumps(orig_plays_list)) if z['play_type'] not in ['Timeout', 'Substitution']]

    
    
    #fmt = "{:<20}{:<30}"
    #print (fmt.format("Start time", "Started with"))
    #print ("\n").join([fmt.format(z['start_time'], z['started_with']) for z in possessions])
    #zc.exit("kd29iefeasdffds")

    
    for ip, p in enumerate(players):
        p['tup'] = (hash_player_name(p['player']))

    for i, fo in enumerate(plays_list):
        fo['oppID'] = away_ID if fo['team_ID'] == home_ID else home_ID


        if i == 0:
            fo['last_play'] = {'play_type': 'StartofGame'}
        else:
            fo['last_play'] = plays_list[i-1]
        if i == len(plays_list)-1:
            fo['next_play'] = None
        else:
            fo['next_play'] = json.loads(json.dumps(plays_list[i+1]))

    faceoffs = [z for z in plays_list if z['play_type'] == "Faceoff Win"]
    shots = [z for z in plays_list if z['play_type'].endswith("Shot") or z['play_type'].endswith("Goal")]
    turnovers = [z for z in plays_list if z['play_type'].endswith("Turnover")]

    #print "34j23orjefwdsfdsafewr"
    #zc.print_dict(turnovers[0:1])
    
    poss1_match = 0
    for i, fo in enumerate(faceoffs):
        lp = fo['last_play']
        np = fo['next_play']

        fo['possession_ID'] = None

        fo['winner_ID'] = None
        fo['loser_ID'] = None
        fo['picked_up_by_ID'] = None

        fo['winner'] = fo['player1'] if fo['player1_team'] == fo['team'] else fo['player2']
        fo['loser'] = fo['player1'] if fo['player1_team'] != fo['team'] else fo['player2']
        fo['picked_up_by'] = fo['player3'] if fo['player3'] not in [home_team['alt_team'], away_team['alt_team'], fo['winner'], '', None] else None


        if None in [fo['winner'], fo['loser']]:
            msg = "Faceoff Fail: Game ID: %d, winner=%s, loser=%s\n%s" % (game_obj['ID'], fo['winner'], fo['loser'], fo['details'])
            print (msg)
            zc.send_telegram(msg, bot_token)
            zc.exit("laxref0042")
        fo['following'] = "quarter"
        if lp['play_type'].endswith("Goal"):
            fo['following'] = "myGoal" if lp['team'] == fo['team'] else "theirGoal"
        

        fo['seconds_until_shot'] = None
        if np != None and (np['play_type'].endswith("Shot") or np['play_type'].endswith("Goal")) and fo['team'] == np['team']:
            fo['seconds_until_shot'] = np['time_elapsed'] - fo['time_elapsed']

        fo['seconds_until_goal'] = None
        if np != None and np['play_type'].endswith("Goal") and fo['team'] == np['team']:
            fo['seconds_until_goal'] = np['time_elapsed'] - fo['time_elapsed']

        fo['seconds_until_turnover'] = None
        if np != None and np['play_type'].endswith("Turnover"):
            fo['seconds_until_turnover'] = np['time_elapsed'] - fo['time_elapsed']


        fo['won_on_violation'] = 1 if 'violation' in fo['details'] else 0
        fo['weird'] = 0
        if fo['seconds_until_shot'] != None and fo['seconds_until_shot'] == 0:
            fo['weird'] = 1
        elif fo['seconds_until_goal'] != None and fo['seconds_until_goal'] == 0:
            fo['weird'] = 1
        elif fo['picked_up_by'] == fo['loser']:
            fo['weird'] = 1
        elif fo['won_on_violation'] and fo['picked_up_by'] != None:
            fo['weird'] = 1
        elif fo['following'] == "quarter" and fo['time_elapsed'] % 60 > 0:
            fo['weird'] = 1

        
    
    
    start_ms = time.time()
    for i, fo in enumerate(faceoffs):


        tup = (hash_player_name(fo['winner']))
        if tup in [z['tup'] for z in players]:
            fo['winner_ID'] = players[ [z['tup'] for z in players].index(tup) ]['ID']

        tup = (hash_player_name(fo['loser']))
        if tup in [z['tup'] for z in players]:
            fo['loser_ID'] = players[ [z['tup'] for z in players].index(tup) ]['ID']

        if fo['picked_up_by'] != None:
            tup = (hash_player_name(fo['picked_up_by']))
            if tup in [z['tup'] for z in players]:
                fo['picked_up_by_ID'] = players[ [z['tup'] for z in players].index(tup) ]['ID']


    end_ms = time.time()

    for i, fo in enumerate(faceoffs):
        
        poss1 = [z for z in possessions if z['start_time'] == fo['time_elapsed']]
        n_poss1 = len(poss1)
        poss1_match += 1 if n_poss1 > 0 else 0
        
        """ Determing whether this faceoff transitioned to a real possession
        ORIGINAL
        1. Possession lasts at least 20 seconds or (No. 1)
        2. A shot is taken by someone other than the FOGO (No. 4)
        3. The FOGO takes a shot that is not saved (No. 5)
        4. It is the last possession of the game (No. 3)
        5. Someone other than the fogo turned it over inside of 20 seconds (No. 6)
        6. The possession resulted in a goal (No. 2)
        7. The faceoff has been marked weird; give them the benefit of the doubt (No. 7)
        
        UPDATED (Feedback was that this was too harsh on FOGO shots)
        1. Possession lasts at least 20 seconds or (No. 1)
        2. A shot is taken by someone other than the FOGO (No. 4)
        3. The FOGO takes a shot whether it is saved or not (No. 5)
        4. It is the last possession of the game (No. 3)
        5. Someone other than the fogo turned it over inside of 20 seconds (No. 6)
        6. The possession resulted in a goal (No. 2)
        7. The faceoff has been marked weird; give them the benefit of the doubt (No. 7)
        
        """
        triggers = []
        triggers.append({'num': 0, 'desc': 'No Possession'})
        triggers.append({'num': 1, 'desc': 'Duration > 20'})
        triggers.append({'num': 2, 'desc': 'Goal Scored'})
        triggers.append({'num': 3, 'desc': 'Last Possession'})
        triggers.append({'num': 4, 'desc': 'Non-FOGO shot'})
        triggers.append({'num': 5, 'desc': 'FOGO shot'})
        triggers.append({'num': 6, 'desc': 'Non-FOGO Turnover'})
        triggers.append({'num': 7, 'desc': 'Weird possession'})
        fo['converted_to_possession'] = 0
        fo['converted_trigger'] = 0
        if n_poss1 > 0:
            tmp_poss = poss1[0]
            #zc.print_dict(tmp_poss); 
            
            last_poss = 1 if len([1 for z in possessions if z['start_time'] > tmp_poss['start_time']]) == 0 else 0
            
            if tmp_poss['duration'] >= 20 or (fo['seconds_until_shot'] is not None and fo['seconds_until_shot'] >= 20):
                fo['converted_to_possession'] = 1
                fo['converted_trigger'] = 1
            elif tmp_poss['goal_scored']:
                fo['converted_to_possession'] = 1
                fo['converted_trigger'] = 2
            elif last_poss:
                fo['converted_to_possession'] = 1
                fo['converted_trigger'] = 3
            elif fo['weird']:
                fo['converted_to_possession'] = 1
                fo['converted_trigger'] = 7
            else:
            
                subsequent_shots_in_poss = [z for z in shots if z['team_ID'] == fo['team_ID'] and tmp_poss['end_time'] >= z['time_elapsed'] >= tmp_poss['start_time']]
                n_non_fogo_subsequent_turnovers_in_poss = len([1 for z in turnovers if z['player'] != fo['winner'] and z['player1'] != fo['winner'] and z['team_ID'] == fo['team_ID'] and tmp_poss['end_time'] >= z['time_elapsed'] >= tmp_poss['start_time']])
                #print("Possession Shots")
                #zc.print_dict(subsequent_shots_in_poss)
                n_fogo_shots = len([1 for z in subsequent_shots_in_poss if z['player1'] == fo['winner']])
                other_shooter = 1 if len([1 for z in subsequent_shots_in_poss if z['player1'] != fo['winner']]) else 0
                if other_shooter:
                    fo['converted_to_possession'] = 1
                    fo['converted_trigger'] = 4
                elif n_fogo_shots > 0:
                    fo['converted_to_possession'] = 1
                    fo['converted_trigger'] = 5
                elif n_non_fogo_subsequent_turnovers_in_poss > 0:
                    fo['converted_to_possession'] = 1
                    fo['converted_trigger'] = 6
                    
                    
            
        
            
            
            #print "{:<20}{:<20}{:<20}{:<20}".format(convert_pct_complete_to_time_str(fo['time_elapsed']/3600., game_obj['detail']['year'], game_obj['league']), tmp_poss['duration'],  fo['seconds_until_shot'], fo['converted_trigger'])
        orig_play = plays_list[ [z['seq'] for z in plays_list].index(fo['seq'])]
        if 'converted_to_possession' in fo:
            orig_play['converted_to_possession'] = fo['converted_to_possession']
    
    if abs(len(faceoffs) - poss1_match) > 5:
        msg = "In game %d, there were %d faceoffs, but %d of them matched a possession start time. Note: this does not affect downstream processing. Game will still be uploaded/updated." % (game_obj['ID'], len(faceoffs),poss1_match)
        print ("\n\n%s\n\n" % msg)
        zc.send_telegram(msg, bot_token)
    
    
    if '--print-faceoffs' in sys.argv:
        fmt = "{:<10}{:>9}{:>30}{:>30}{:>30}{:>13}{:>13}{:>13}{:>13}{:>13}{:>8}{:>8}{:>10}"
        header = fmt.format("Team", "Time", "Winner (ID)", "Loser (ID)", "PickedUpBy (ID)", "Sec to Shot", "Sec to Goal", "Sec to TO", "Following", "Violation", "Weird", "Poss", "Trigger")
        print ("\n\nGame %d %s at %s (%.3f s to get IDs)\n" % (game_obj['ID'], confirmed_away_team, confirmed_home_team, end_ms-start_ms) + header + "\n" + ("-"* len(header)))
        
        print ("\n".join([fmt.format(
        f['team']
        , convert_pct_complete_to_time_str(f['time_elapsed']/3600.
        , game_obj['detail']['year']
        , game_obj['league'])
        , "%s (%s)" % (f['winner'], f['winner_ID'])
        , "%s (%s)" % (f['loser'], f['loser_ID'])
        , "%s (%s)" % (f['picked_up_by'], f['picked_up_by_ID'])
        , "" if f['seconds_until_shot'] is None else f['seconds_until_shot']
        , "" if f['seconds_until_goal'] is None else f['seconds_until_goal']
        , "" if f['seconds_until_turnover'] is None else f['seconds_until_turnover']
        , "" if f['following'] is None else f['following']
        , "" if f['won_on_violation'] is None else f['won_on_violation']
        , "" if f['weird'] is None else f['weird']
        , f['converted_to_possession']
        , f['converted_trigger']) for f in faceoffs]))
        for t in triggers:
            t['n'] = sum([1. for z in faceoffs if z['converted_trigger'] == t['num']])
            t['pct'] = 100. * t['n'] / float(len(faceoffs))
        triggers = sorted(triggers, key=lambda x:x['pct'], reverse=True)
        
        fmt = "{:<20}{:>7}{:>7}{:>7}"
        header = fmt.format("Trigger", "ID", "n", "Pct")
        print (header + "\n" + ("-"* len(header)))
        fmt = "{:<20}{:>7}{:>7}{:>7}"
        print ("\n".join([fmt.format(
        "" if z['desc'] is None else z['desc']
        , "" if z['num'] is None else ("{:.0f}".format(z['num']))
        , "" if z['n'] is None else ("{:.0f}".format(z['n']))
        , "" if z['pct'] is None else ("{:.0f}%".format(z['pct']))
        ) for z in triggers]))
        
        n = float(len(faceoffs))
        n_poss = sum([1. for z in faceoffs if z['converted_to_possession']])
        pct_poss = n_poss / n * 100.
        print ("In this game, %d of %d faceoffs were converted to possessions (%.0f%%)" % (n_poss, n, pct_poss))
    

    
    if '--debug-conversions' in sys.argv:
        input("Processing faceoffs")
    
    for e in existing:
        e['tup'] = (e['game_ID'], e['time_elapsed'], e['game_state'])

    queries = []; params = []
    faceoffs_added = 0

    for i, p in enumerate(faceoffs):

        #zc.print_dict(p)

        if '--play-ID' in sys.argv and p['ID'] == int(sys.argv[sys.argv.index("--play-ID") + 1]):
            zc.print_dict(p)
            zc.exit("laxref0043")
        p['tup'] = (game_obj['ID'], p['time_elapsed'], p['game_state'])
        if p['tup'] not in [z['tup'] for z in existing]:
            query = "INSERT INTO LaxRef_Faceoffs (ID, game_ID, active, team_ID, opp_team_ID, possession_ID, team_odds, time_elapsed, game_state, winner_ID, loser_ID, picked_up_by_ID, following, seconds_until_shot, seconds_until_turnover, weird, won_on_violation, converted_to_possession) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
            param = [next_faceoff_ID, game_obj['ID'], 1, p['team_ID'], p['oppID'], p['possession_ID'], p['team_odds'], p['time_elapsed'], p['game_state'], p['winner_ID'], p['loser_ID'], p['picked_up_by_ID'], p['following'], p['seconds_until_shot'], p['seconds_until_turnover'], p['weird'], p['won_on_violation'], p['converted_to_possession']]
            queries.append(query); params.append(param)
            next_faceoff_ID += 1
            faceoffs_added  += 1
        elif '--update-fo-conversion' in sys.argv:
            fo_rec = [z['ID'] for z in existing if z['tup'] == p['tup']]
            if len(fo_rec) == 1:
                query = "UPDATE LaxRef_Faceoffs set converted_to_possession=%s where ID=%s"
                param = [p['converted_to_possession'], fo_rec[0]]
                queries.append(query); params.append(param)
                print ("Query %s w/ %s" % (queries[-1], params[-1]))
                
    if len(queries) > 0:
        print (" Adding %d faceoffs to the DB..." % (len(queries)))
        

        n = float(len(queries)); start_ms = time.time()
        if '--use-fast-upload' not in sys.argv:
            cursor.execute("START TRANSACTION")
            for q, p in zip(queries, params):
                cursor.execute(q, p)
            if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
        else:
            q = queries[0]; param_list = []
            for q, p in zip(queries, params):
                p[0] = next_faceoff_ID; next_faceoff_ID += 1
                param_list.append(p)
            cursor.executemany(q, param_list)
            print ("  Uploaded {:,} faceoffs".format(cursor.rowcount))
            if '--no-commit' not in sys.argv: conn.commit()

        end_ms = time.time()
        per_n = (end_ms - start_ms)/n

        print ("  It took %.3f seconds per faceoff" % (per_n))
    return faceoffs, next_faceoff_ID
    
def populate_team_summary_table(game_log_IDs, home, away, g, next_game_summary_ID, stat_summaries_with_filters):
    show_cgd_timedstamps = 1 if '--show-cgd-timestamps' in sys.argv else 0
    if g['ID'] is not None:
        print("     {:<95}{:<15}".format("Begin populate_team_summary_table...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
          
        tags = []
        if 1 or '--test-TGS-FP' in sys.argv:
            tags.append({'col': 'fp_attempts'})
            tags.append({'col': 'fp_goals'})
            tags.append({'col': 'fp_shots'})
            tags.append({'col': 'fp_shots_off_one_pass'})
            tags.append({'col': 'fp_efficiency'})
            tags.append({'col': 'fp_utilization'})
            tags.append({'col': 'fp_shooting_pct'})
            tags.append({'col': 'fp_shooter_pct'})
                
        tags.append({'col': 'turnovers'})
        tags.append({'col': 'poss_w_shot'})
        tags.append({'col': 'forced_turnovers'})
        tags.append({'col': 'unforced_turnovers'})
        tags.append({'col': 'goals'})
        tags.append({'col': 'second_chance_goals'})
        tags.append({'col': 'second_chance_possessions'})
        tags.append({'col': 'man_up_goals'})
        tags.append({'col': 'man_down_goals'})
        tags.append({'col': 'man_up_chances'})
        tags.append({'col': 'assists'})
        tags.append({'col': 'assist_rate'})
        tags.append({'col': 'faceoff_wins', 'stat': 'faceoffs'})
        tags.append({'col': 'faceoff_losses', 'stat': 'faceoffs', 'opp': True})
        tags.append({'col': 'faceoff_conversions'})
        tags.append({'col': 'fo_conv_fails'})
        tags.append({'col': 'forced_fo_conv_fails', 'stat': 'fo_conv_fails', 'opp': True})
        tags.append({'col': 'gbs_won', 'stat': 'gbs'})
        tags.append({'col': 'number_of_contributors', 'stat': 'player_cnt'})
        tags.append({'col': 'gbs_lost', 'stat': 'gbs', 'opp': True})
        tags.append({'col': 'sog_faced', 'stat': 'sog', 'opp': True})
        tags.append({'col': 'on_keeper_shots_faced', 'stat': 'on_keeper_shots', 'opp': True})
        tags.append({'col': 'shots_saved', 'stat': 'saves', 'opp': True})
        tags.append({'col': 'saves'})
        tags.append({'col': 'possessions'})
        tags.append({'col': 'multiple_shot_possessions'})
        tags.append({'col': 'multiple_shot_possession_rate'})
        tags.append({'col': 'shots'})
        tags.append({'col': 'failed_clears'})
        tags.append({'col': 'possessions_plus_failed_clears'})
        tags.append({'col': 'successful_rides', 'stat': 'failed_clears', 'opp': True})
        tags.append({'col': 'ride_opportunities', 'stat': 'possessions_plus_failed_clears', 'opp': True})
        #tags.append({'col': 'ride_rate', 'stat': 'clear_rate', 'opp': True, 'calc': '1.0minus'})
        tags.append({'col': 'fc_forced'})
        tags.append({'col': 'good_clears'})
        tags.append({'col': 'sog'})
        tags.append({'col': 'sog_rate'})
        tags.append({'col': 'shooting_EGA'})
        tags.append({'col': 'possession_margin'})
        tags.append({'col': 'shots_per_possession'})
        tags.append({'col': 'efficiency', 'stat': 'off_efficiency'})
        tags.append({'col': 'on_goal_shooting_pct'})
        tags.append({'col': 'shooting_pct'})
        tags.append({'col': 'weird_time_as_pct', 'game': True})
        tags.append({'col': 'time_of_possession', 'stat': 'top'})
        tags.append({'col': 'avg_possession_length', 'stat': 'time_per_possession'})
        tags.append({'col': 'time_to_first_shot', 'stat': 'avg_time_to_shot'})
        tags.append({'col': 'on_keeper_shots'})
        tags.append({'col': 'assist_to_turnover_ratio'})
        
        #zc.print_dict(g['faceoffs'][0:10]); zc.exit("g['faceoffs'][0:10]")

        all_tags = "IDiuygame_IDiuygoalsiuypossessionsiuysub_30_possiuy30_60_possiuy60_plus_possiuysub_30_poss_goalsiuy30_60_poss_goalsiuy60_plus_poss_goalsiuyshotsiuysogiuyefficiencyiuysave_pctiuyshooting_pctiuysog_rateiuyfaceoff_winsiuyfaceoff_lossesiuyfaceoff_win_rateiuyforced_turnoversiuyunforced_turnoversiuyturnover_rateiuygbs_woniuygbs_lostiuygb_win_rateiuytime_of_possessioniuyavg_possession_lengthiuytime_to_first_shotiuyshots_per_possessioniuynumber_of_contributorsiuyweird_time_as_pctiuyteamiuyopponentiuydata_typeiuysavesiuyturnovers".split("iuy")
        for tz in tags:
            if 'stat' not in tz:
                tz['stat'] = tz['col']
            elif 'col' not in tz:
                tz['col'] = tz['stat']
            if 'calc' not in tz: tz['calc'] = None
        insert_queries = []; insert_params = []
        update_queries = []; update_params = []

        combos = []
        combos.append({'data_team': 'home', 'alt_data_team': 'away', 'query_team': "home", 'data_type': "offense"})
        combos.append({'data_team': 'away', 'alt_data_team': 'home', 'query_team': "away", 'data_type': "offense"})
        combos.append({'data_team': 'away', 'alt_data_team': 'home', 'query_team': "home", 'data_type': "defense"})
        combos.append({'data_team': 'home', 'alt_data_team': 'away', 'query_team': "away", 'data_type': "defense"})

        inc_cnt = 0
        if show_cgd_timedstamps:
            print("          {:<90}{:<15}".format("Parse summary stats...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]))
        for ftr in stat_summaries_with_filters:
            for zcy, combo in enumerate(combos):

                data = {'ID': next_game_summary_ID + inc_cnt if game_log_IDs is None else None, 'game_ID': g['ID'], 'data_type': combo['data_type']}
                inc_cnt += 1

                for tz in tags:
                    try:

                        if 'game' in tz:
                            if g['%s' % (tz['stat'])] is None:
                                data[tz['col']] = g['%s' % (tz['stat'])]
                            else:
                                data[tz['col']] = float(g['%s' % (tz['stat'])])
                        elif 'opp' in tz:
                            if tz['calc'] is None:
                                if ftr['stat_summaries']['%s_%s' % (combo['alt_data_team'], tz['stat'])]['val'] is None:
                                    data[tz['col']] = ftr['stat_summaries']['%s_%s' % (combo['alt_data_team'], tz['stat'])]['val']
                                else:
                                    data[tz['col']] = float(ftr['stat_summaries']['%s_%s' % (combo['alt_data_team'], tz['stat'])]['val'])
                            elif tz['calc'] == "1.0minus":
                                if ftr['stat_summaries']['%s_%s' % (combo['alt_data_team'], tz['stat'])]['val'] is None:
                                    data[tz['col']] = None
                                else:
                                    data[tz['col']] = 1.0 - float(ftr['stat_summaries']['%s_%s' % (combo['alt_data_team'], tz['stat'])]['val'])
                        else:
                            if ftr['stat_summaries']['%s_%s' % (combo['data_team'], tz['stat'])]['val'] is None:
                                data[tz['col']] = ftr['stat_summaries']['%s_%s' % (combo['data_team'], tz['stat'])]['val']
                            else:
                                data[tz['col']] = float(ftr['stat_summaries']['%s_%s' % (combo['data_team'], tz['stat'])]['val'])
                    except Exception:
                        print (traceback.format_exc())
                        filter_type = ftr['filter']
                        filter_value = ftr['filter_val']
                        msg = "Error occurred in game dict flow (populate_team_summary_table). In trying to process %s for data type=%s and data_team=%s where the filter was %s and the filter value was %s\n\n" % (tz['stat'], combo['data_type'], combo['data_team'], filter_type, filter_value)
                        if 'game' in tz:
                            print(g['%s' % (tz['stat'])])
                            msg += "%s\n" % g['%s' % (tz['stat'])]
                        elif 'opp' in tz:
                            
                            msg += "%s\n" % zc.print_dict(ftr['stat_summaries']['%s_%s' % (combo['alt_data_team'], tz['stat'])])
                        else:
                            msg += "%s\n" % zc.print_dict(ftr['stat_summaries']['%s_%s' % (combo['data_team'], tz['stat'])])

                        print (msg)
                        
                        zc.send_telegram(msg, bot_token)
                        zc.exit("laxref0044")
                # Add in the possession length stuff
                for tz in tags:
                    for tzx in ['sub_30', '30_60', '60_plus']:
                        data['%s_poss' % tzx] = ftr['stat_summaries']['%s_possessions_by_length' % combo['data_team']]['val'][tzx]
                        data['%s_poss_goals' % tzx] = ftr['stat_summaries']['%s_goals_by_poss_length' % combo['data_team']]['val'][tzx]
                # Add in the rate stuff
                data['turnover_rate'] = data['turnovers']/data['possessions'] if data['possessions'] > 0 else None
                data['assist_to_turnover_ratio'] = data['assists']/data['turnovers'] if data['turnovers'] > 0 else None
                data['shooting_efficiency'] = data['shooting_EGA']/data['shots'] if data['shots'] > 0 else None
                if '--debug-conversions' in sys.argv:
                    #zc.print_dict(ftr);
                    print ("{:<30}{:<30}{:<30}{:<30}{:<30}".format("", combo['data_team'], "" if ftr['filter_val'] is None else ftr['filter_val'], data['faceoff_wins'], data['faceoff_conversions']))
                    
                data['faceoff_conversion_rate'] = None if data['faceoff_wins'] == 0 else (data['faceoff_conversions'] / data['faceoff_wins'])
                data['true_faceoff_wins'] = data['faceoff_conversions'] + data['forced_fo_conv_fails']
                data['true_faceoff_losses'] = (data['faceoff_wins'] + data['faceoff_losses']) - data['true_faceoff_wins']
                data['true_faceoff_win_rate'] = None if data['faceoff_wins'] + data['faceoff_losses'] == 0 else ((data['faceoff_conversions'] + data['forced_fo_conv_fails']) / (data['faceoff_wins'] + data['faceoff_losses']))
                data['faceoff_win_rate'] = data['faceoff_wins']/(data['faceoff_wins'] + data['faceoff_losses']) if (data['faceoff_wins'] + data['faceoff_losses']) > 0 else None
                data['gb_win_rate'] = data['gbs_won']/(data['gbs_won'] + data['gbs_lost']) if (data['gbs_won'] + data['gbs_lost']) > 0 else None

                data['filter'] = ftr['filter']
                data['filter_val'] = ftr['filter_val']
                data['team_ID'] = g['%s_team' % combo['query_team']]['ID']
                data['opp_team_ID'] = g['%s_team' % ("home" if combo['query_team'] == "away" else "away")]['ID']

                # Save Pct

                if combo['data_type'] == "offense":

                    if combo['data_team'] == "home":

                        if ftr['stat_summaries']['away_on_keeper_shots']['val'] > 0:
                            data['save_pct'] = ftr['stat_summaries']['home_saves']['val'] / ftr['stat_summaries']['away_on_keeper_shots']['val']
                            #if data['filter'] is None: print "{:<5}{:>4}{:>10} {:>10.0f}{:>10.0f}{:>10.3f}".format(combo['data_team'], data['team_ID'], combo['data_type'],ftr['stat_summaries']['home_saves']['val'], ftr['stat_summaries']['away_sog']['val'], data['save_pct'])
                        else:
                            data['save_pct'] = None

                        data['win'] = None
                        if ftr['stat_summaries']['home_goals']['val'] > ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 1
                        elif ftr['stat_summaries']['home_goals']['val'] < ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 0

                    else:
                        if ftr['stat_summaries']['home_on_keeper_shots']['val'] > 0:
                            data['save_pct'] = ftr['stat_summaries']['away_saves']['val'] / ftr['stat_summaries']['home_on_keeper_shots']['val']
                            #if data['filter'] is None: print "{:<5}{:>4}{:>10} {:>10.0f}{:>10.0f}{:>10.3f}".format(combo['data_team'], data['team_ID'], combo['data_type'],ftr['stat_summaries']['away_saves']['val'], ftr['stat_summaries']['home_sog']['val'], data['save_pct'])
                        else:
                            data['save_pct'] = None

                        data['win'] = None
                        if ftr['stat_summaries']['home_goals']['val'] > ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 0
                        elif ftr['stat_summaries']['home_goals']['val'] < ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 1

                else:
                    if combo['data_team'] == "home":
                        if ftr['stat_summaries']['away_on_keeper_shots']['val'] > 0:
                            data['save_pct'] = ftr['stat_summaries']['home_saves']['val'] / ftr['stat_summaries']['away_on_keeper_shots']['val']
                            #if data['filter'] is None: print "{:<5}{:>4}{:>10} {:>10.0f}{:>10.0f}{:>10.3f}".format(combo['data_team'], data['team_ID'], combo['data_type'],ftr['stat_summaries']['home_saves']['val'], ftr['stat_summaries']['away_sog']['val'], data['save_pct'])
                        else:
                            data['save_pct'] = None

                        data['win'] = None
                        if ftr['stat_summaries']['home_goals']['val'] > ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 1
                        elif ftr['stat_summaries']['home_goals']['val'] < ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 0
                    else:
                        if ftr['stat_summaries']['home_on_keeper_shots']['val'] > 0:
                            data['save_pct'] = ftr['stat_summaries']['away_saves']['val'] / ftr['stat_summaries']['home_on_keeper_shots']['val']
                            #if data['filter'] is None: print "{:<5}{:>4}{:>10} {:>10.0f}{:>10.0f}{:>10.3f}".format(combo['data_team'], data['team_ID'], combo['data_type'],ftr['stat_summaries']['away_saves']['val'], ftr['stat_summaries']['home_sog']['val'], data['save_pct'])
                        else:
                            data['save_pct'] = None

                        data['win'] = None
                        if ftr['stat_summaries']['home_goals']['val'] > ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 0
                        elif ftr['stat_summaries']['home_goals']['val'] < ftr['stat_summaries']['away_goals']['val']:
                            data['win'] = 1
                data['active'] = 1
                #data['possessions_plus_failed_clears'] = data['possessions'] + data['failed_clears']
                data['modified_possession_margin'] = data['faceoff_wins'] - data['faceoff_losses'] + data['successful_rides'] - data['failed_clears']
                data['clear_rate'] = None if data['possessions_plus_failed_clears'] == 0 else data['possessions']/data['possessions_plus_failed_clears']
                data['ride_rate'] = None if data['ride_opportunities'] == 0 else data['successful_rides']/data['ride_opportunities']
                data['emo_efficiency'] = None if data['man_up_chances'] == 0 else data['man_up_goals']/data['man_up_chances']

                data['game_date'] = None if 'date' not in g['detail'] else g['detail']['date']
                data['date_added'] = datetime.now()
                
                
                insert_query = "INSERT INTO LaxRef_Team_Game_Summaries (%s) VALUES (%s)" % (", ".join(data.keys()), ", ".join(["%s"] * (len(data.keys()))))
                insert_param = data.values()



                update_ID = None
                if game_log_IDs is not None:
                    tmp_list = [z for z in game_log_IDs if z['filter']==data['filter'] and z['filter_val']==data['filter_val'] and z['data_type']==data['data_type'] and data['team_ID']==z['team_ID']]
                    if tmp_list != [] :
                        update_ID = tmp_list[0]['ID']

                USE_INDEXED_QUERY=1
                if USE_INDEXED_QUERY:
                    update_query = "UPDATE LaxRef_Team_Game_Summaries set %s where team_ID=%%s and data_type=%%s and IFNULL(filter,'None')=%%s and IFNULL(filter_val,'None')=%%s and game_ID=%%s" % (", ".join(["%s=%%s" % (z) for z in data.keys() if z not in ['game_ID', 'team_ID', 'data_type', 'filter', 'active', 'ID']]))
                    update_param = [z for z, y in zip(data.values(), data.keys()) if y not in ['game_ID', 'team_ID', 'data_type', 'filter', 'active', 'ID']] + [data['team_ID'], data['data_type'], "None" if data['filter'] is None else data['filter'], "None" if data['filter_val'] is None else data['filter_val'], g['ID']]
                    if data['team_ID'] == 700 and data['filter'] is None and data['data_type'] == "offense":
                        print ("Query %s w/ %s" % (update_query, update_param))
                else:
                    update_query = "UPDATE LaxRef_Team_Game_Summaries set %s where ID=%%s" % (", ".join(["%s=%%s" % (z) for z in data.keys() if z not in ['active', 'ID']]))
                    update_param = [z for z, y in zip(data.values(), data.keys()) if y not in ['active', 'ID']] + [update_ID]
                    
                #print "Query %s w/ %s" % (update_query, str(update_param)); zc.exit("UPDATE LRTGS")
                if update_ID is None:
                    insert_queries.append(insert_query); insert_params.append(insert_param)
                else:
                    if '--debug-conversions' in sys.argv:
                        print (data['faceoff_wins'], data['faceoff_conversions'], data['forced_fo_conv_fails'])
                        
                    update_queries.append(update_query); update_params.append(update_param)

	    
        if '--skip-TGS-updates' not in sys.argv:
            n = float(len(insert_queries) + len(update_queries)); start_ms = time.time()
            
            print("          {:<90}{:<15}".format("Execute %d queries..." % n, datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
            if len(update_queries) > 0 or len(insert_queries) > 0:
                zconn, zcursor = zc.mysql_connect("LR")

            if '--use-fast-upload' not in sys.argv:
                if len(insert_queries) > 0:
                    zcursor.execute("START TRANSACTION")
                    for q, p in zip(insert_queries, insert_params):
                        zcursor.execute(q, p)
                    print ("   Inserted {:,} summary rows".format(len(insert_params)))
                    if '--no-commit' not in sys.argv: zcursor.execute("COMMIT")

                if len(update_queries) > 0:

                    zcursor.execute("START TRANSACTION")
                    for q, p in zip(update_queries, update_params):
                        #print ("Query %s w/ %s" % (q, p))
                        zcursor.execute(q, p)
                    print ("   Updated {:,} summary rows".format(len(update_params)))
                    if '--no-commit' not in sys.argv: zcursor.execute("COMMIT")
            else:
                if zcursor is None:
                    if zconn is None:
                        zconn, zcursor = zc.mysql_connect("LR")
                    else:
                        zcursor = zconn.cursor()
                if len(update_queries) > 0:
                    zcursor.executemany(update_query, update_params)
                    print ("   Updated {:,} summary rows".format(len(update_params)))

                if len(insert_queries) > 0:
                    for tmp in insert_params:
                        #print ("Query %s w/ %s" % (insert_query, tmp))
                        zcursor.execute(insert_query, tmp)
                    #zcursor.executemany(insert_query, insert_params)
                    print ("  Inserted {:,} summary rows".format(len(insert_params)))
                if '--no-commit' not in sys.argv: zconn.commit()




            if len(update_queries) > 0 or len(insert_queries) > 0:
                zcursor.close(); zconn.close()

            end_ms = time.time()
            per_n = 0. if n == 0 else (end_ms - start_ms)/n

        #print "  It took %.3f seconds per update/insert" % (per_n);


def scan_play(src, team, player, play, play_obj):

    play['fp_shot'] = 0
    sdl = play['details'].lower().replace(" ", "")
    if "freepositionshot" in sdl or "fpgoal" in sdl:
        play['fp_shot'] = 1
            
    fmt = "{:<10}{:<5}{:<25}{:<25}{:>10}{:>50}"
    if False and player == "TD Ierlan":
        zc.print_dict(play_obj)
        print (fmt.format(team, src, player, play['play_type'], play['regex'][5:] + "  ", play['details']))
    return play

def classify_details(p, game_ID, classifiers, settings = {}):
    final_res = {'player': '','player1': '','player2': '','player3': '','player_play': '','player1_play': '','player2_play': '','player3_play': '', 'regex': None}
    successful_classification = False
    classification_error = None
    

    possibles = []
    if not p['details'].strip().endswith("."):
        p['details'] = p['details'].strip() + "."

    
    #print "\n Details: " + p['details']
    for c in classifiers:

        matches = re.findall(c['regex'], p['details'])
        for m in matches:
            m = [m] if not isinstance(m, tuple) else m

            res = {'Regex': c['ID'], 'weight': c['wght'],
            'player': "" if 'p_group' not in c else m[c['p_group']]
            ,'player1': "" if 'p1_group' not in c else m[c['p1_group']]
            ,'player2': "" if 'p2_group' not in c else m[c['p2_group']]
            ,'player3': "" if 'p3_group' not in c else m[c['p3_group']]
            ,'player_play': "" if 'p_group' not in c else (p['play_type'] if c['p_play'] == "ptype" else c['p_play'])
            ,'player1_play': "" if 'p1_group' not in c else (p['play_type'] if c['p1_play'] == "ptype" else c['p1_play'])
            ,'player2_play': "" if 'p2_group' not in c else (p['play_type'] if c['p2_play'] == "ptype" else c['p2_play'])
            ,'player3_play': "" if 'p3_group' not in c else (p['play_type'] if c['p3_play'] == "ptype" else c['p3_play'])}

            #Air Force      Faceoff Win                   |
            #print (m)
            if 'print' in c and c['print']:
                print ("{:<10}{:<30}{:<30}{:<30}{}".format(res['Regex'], res['player1'], res['player2'], res['player3'], p['details']))

            suffixes = ['', '1', '2', '3']
            #print("Play:  %s  Details: %s" % ("{:<30}".format(p['play_type']), p['details']))
            #print("Team:  %s \n" % ("{:<30}".format(p['team'])))

            for suffix in suffixes:
                res['player%s_team' % suffix] = ""
                if 'p%s_group' % suffix in c:
                    #print (c)
                    #print ("{:30}{:<30}".format('p%s_team' % suffix, c['p%s_team' % suffix]))
                    if c['p%s_team' % suffix] == "???":
                        if res['player%s' % suffix] == p['team']:
                            res['player%s_team' % suffix] = p['team']
                        elif res['player%s' % suffix] == p['opp']:
                            res['player%s_team' % suffix] = p['opp']
                        elif res['player%s' % suffix] == settings['away_team']:
                            res['player%s_team' % suffix] = settings['away_team']
                        elif res['player%s' % suffix] == settings['home_team']:
                            res['player%s_team' % suffix] = settings['home_team']
                        else:
                            res['player%s_team' % suffix] = "???"
                    elif c['p%s_team' % suffix] == "":
                        res['player%s_team' % suffix] = "" if p['team'] is None else p['team']
                    elif c['p%s_team' % suffix] == "other":
                        res['player%s_team' % suffix] = "" if p['opp'] is None else p['opp']
                    elif isinstance(c['p%s_team' % suffix], int):
                        res['player%s_team' % suffix] = "" if m[c['p%s_team' % suffix]] is None else m[c['p%s_team' % suffix]]



            #if 'p1_team' in c and c['p1_team'] == "ifnot3":
            #       res['player1_team'] = p['opp'] if res['player1_team']

            possibles.append(res)

    if len(possibles) > 0:

        possibles = sorted(possibles, key=lambda x:x['weight'], reverse=True)
        final_res = possibles[0]
        successful_classification = True

    else:
        print("Error, no regex matched")
        zc.print_dict(p)
        classification_error = "In classify_details; no regex matched this play (game_ID=%s): %s" % (game_ID, p['details'])
        
        ecursor = zc.zcursor("LR")
        db_game = ecursor.dqr("SELECT a.log_url, a.game_date from LaxRef_Games a where a.active and a.ID=%s", [game_ID])
        ecursor.close()
        
        if len(db_game) > 0:
            classification_error += "\n\nGame Date: %s; Log URL: %s" % (db_game[0]['game_date'].strftime("%b %d, %Y").replace(" 0", " "), db_game[0]['log_url'])
            
        if game_ID is not None:
            classification_error += "\n\nhttp://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % (game_ID)
            classification_error += "\n\nhttp://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % (game_ID)
        
        if " at goalie" in p['details']:
            try:
                tmp = p['details'].split(" at goalie")[-1]
                when_code = tmp.replace(" by ", "").replace(" for ", "").strip().split(" ")[0]
                from_code= tmp.replace(" by ", "").replace(" for ", "").strip()
                to_code = tmp.replace(" by ", "").replace(" for ", "").strip().replace(" ", "")
                if from_code.endswith("."): from_code = from_code[0:-1]
                if to_code.endswith("."): to_code = to_code[0:-1]
                if game_ID is not None:
                    classification_error += "\n\npython scratchpad.py --game-ID %s --when-team-is \"%s\" -change \"%s\" -to \"%s\" -quiet -approve --modify-game-short-code" % (game_ID, when_code, from_code, to_code)
            except Exception:
                classification_error += "\n\n%s" % traceback.format_exc()
                

        print (classification_error)
        zc.send_telegram(classification_error, bot_token)

        return None, classification_error

    for k, v in zip(final_res.keys(), final_res.values()):
        if k in ["player", "player1", "player2", "player3"]:
            if "," in v:
                tokens = [z.strip() for z in v.split(",")]
                if len(tokens) == 2:

                    final_res[k] = tokens[1] + " " + tokens[0]

                else:
                    if game_ID is not None:
                        classification_error = "Need to adjust player name with comma (via replacement text): %s (Game ID=%s)" % (v, game_ID)
                        conn, cursor = zc.mysql_connect("LR")
                        cursor.execute("SELECT log_url from LaxRef_Games where ID=%s", [game_ID])
                        tmp = zc.dict_query_results(cursor)
                        if len(tmp) > 0 and tmp[0]['log_url'] is not None:
                            classification_error += "\n\nPXP: %s" % (tmp[0]['log_url'])
                        cursor.close(); conn.close();
                        classification_error += "\nGame DB Record: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % game_ID
                        classification_error += "\nDB Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % game_ID
                    
                        classification_error += "\n\nUPDATE LaxRef_Games set replacement_text='%s|' where ID=%s" % (p['details'].replace("'", "''"), game_ID)
                    else:
                        classification_error = "Need to adjust player name with comma (via replacement text): %s" % (v)
                        classification_error += "\n\nDetails: %s" % p['details']
                    
                    
                                     
    
                    classification_error += "\n\nPlay obj\n%s" % zc.print_dict(p)
                    classification_error += "\n\nFinal Res\n%s" % zc.print_dict(final_res)
                    print(classification_error)
                    
                    #zc.send_telegram(classification_error, bot_token)

                    return None, classification_error
                  
            # Prior to July 13, 2022, this logic would ensure that a player name didn't include a parenthesis. If it did, it would fail. Because there was a valid player name with a parenthesis (Elizabeth (Libby) St), it was crashing. Because I'd ever seen this issue before, I chose to resolve it by removing the (Libby) from her name via laxref.cleanse_data. If this happens too many times, it may be worthwhile to consider a more permanent fix.
            if ("(" in v or ")" in v) and ('home_team' in settings and v.strip() not in [settings['home_team'], settings['away_team'], (settings['home_team'] + "."), (settings['away_team'] + ".")]):
                    zc.print_dict([p, final_res])
                    print("Player name contained a weird character: %s" % v)
                    cursor = zc.zcursor("LR")
                    data = cursor.dqr("Select a.log_url, a.ID game_ID, a.game_date from LaxRef_Games a where a.ID=%s", [game_ID])
                    
                    query = "UPDATE LaxRef_Games set processing_error=%s where ID=%s"
                    param = ["Player name contained a weird character: %s" % v, game_ID]
                    
                    cursor.execute(query, param)
                    cursor.commit()
                    cursor.close()
                    
                    
                    
                    
                    msg = "Player name contained a weird character: %s, game=%s, Regex ID=%s\n\nThe script is going to exit as a result of this error. It must be resolved.\n\nFull: %s\n\nRegex: ???" % (v, game_ID, final_res['Regex'], p['details'])
                    
                    
                    if len(data) > 0:
                        data = data[0]
                        msg += "\n\nThis error..."
                        msg += "\n\nGame ID: %d" % data['game_ID']
                        msg += "\nLog URL: %s" % data['log_url']
                        msg += "\nGame DB Record: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % data['game_ID']
                        msg += "\nDB Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % data['game_ID']
                        
                    #msg += "\n\nSettings\n\n%s" % (zc.print_dict(settings))
                    msg += "\n\nPlay Obj\n\n%s" % (zc.print_dict(p))
          
                    classification_error = msg
                    print ("\n\nSettings\n\n%s" % (zc.print_dict(settings)))
                    print (msg)
                    if '-quiet' not in sys.argv:
                        if 'from_web' not in settings:
                            classifier = classifiers[ [z['ID'] for z in classifiers].index(final_res['Regex']) ]
                            msg = msg.replace("Regex: ???", "Regex: %s" % (classifier['regex_str']))
                        msg += get_game_crash_info(data['game_ID'])
                        zc.send_crash(msg, bot_token)
                        
                            
                    return None, classification_error
                    
    for k, v in zip(final_res.keys(), final_res.values()):
        if k in ["player", "player1", "player2", "player3"]:
            final_res[k] = v.replace(".", "")

    # If it look like it might be a situation where a player goes by initials (T.J.) but only the first letter was grabbed because of period issues in the regexes, deal with that here
    player0_check = 1 if (len(final_res['player']) == 1 and (" %s." % (final_res['player'])) in p['details']) else 0
    player1_check = 1 if (len(final_res['player1']) == 1 and (" %s." % (final_res['player1'])) in p['details']) else 0
    player2_check = 1 if (len(final_res['player2']) == 1 and (" %s." % (final_res['player2'])) in p['details']) else 0
    player3_check = 1 if (len(final_res['player3']) == 1 and (" %s." % (final_res['player3'])) in p['details']) else 0
    
    def fix_initials(final_res, p, game_ID, tag):
        #print ("In a %s play: %s" % (p['play_type'], p['details']))
        tmp_player = final_res['player%s' % tag]
        orig_tmp_player = final_res['player%s' % tag]
        if '--test-initials-fix' in sys.argv:
            print (" In we found a player with just one initial: %s" % (tmp_player))
        
        if final_res['player%s_play' % tag] == "Unassisted Goal":
            regex = re.compile(r'Goal by .*?{}\.(.+)'.format(orig_tmp_player), re.IGNORECASE)
            match = regex.search(p['details'])
            if match:
                tmp_player = "%s.%s" % (orig_tmp_player, match.group(1))
        if p['play_type'] == "Faceoff Win" and final_res['player%s_play' % tag] == "Ground Ball":
            regex = re.compile(r'Ground ball pickup by .*?{}\.(.+)'.format(orig_tmp_player), re.IGNORECASE)
            match = regex.search(p['details'])
            if match:
                tmp_player = "%s.%s" % (orig_tmp_player, match.group(1))
            
        
        msg = "The fix_initials function was called in game ID %s" % game_ID
        msg += "\n\nIn a %s play: %s" % (p['play_type'], p['details'])
        msg += "\n\nwe found a player (player%s) with just one initial: %s" % (tag, orig_tmp_player)
        if tmp_player != orig_tmp_player:
            msg += "\n\nThe algorithm would propose that player%s should actually be: %s" % (tag, tmp_player)
        msg += "\n\nIt's likely that this could have been fixed so that the entire player's name was grabbed instead of just the first initial, but before making any permanent changes, let's just collect some examples of the issue and then decide what to do."
        msg += "\n\nhttps://pro.lacrossereference.com/admin_cockpit?game_ID=%s" % (game_ID)
        msg += "\n\n%s" % (json.dumps(final_res, default=zc.json_handler, indent=1))
        #print ("Send admin email")
        #print (msg)
        #zc.send_email(msg, {'subject': "Initials Fix"})
        
        final_res['player%s' % tag] = tmp_player
            
        return final_res
    
    if '--test-initials-fix' in sys.argv and "sena-Littles" in p['details']:
        print ("{:90}{:20}{:<7}{:<7}{:<7}{:<7}".format(p['details'], "" if final_res['player'] is None else final_res['player'], player0_check, player1_check, player2_check, player3_check))
    if player0_check:
        
        final_res = fix_initials(final_res, p, game_ID, "")
        
    elif player1_check:
        final_res = fix_initials(final_res, p, game_ID, "1")
        
    elif player2_check:
        final_res = fix_initials(final_res, p, game_ID, "2")
        
    elif player3_check:
        final_res = fix_initials(final_res, p, game_ID, "3")
    
    return final_res['player'], final_res['player1'], final_res['player2'], final_res['player3'], final_res['player_play'], final_res['player1_play'], final_res['player2_play'], final_res['player3_play'], final_res['player_team'], final_res['player1_team'], final_res['player2_team'], final_res['player3_team'], final_res['Regex'], successful_classification, classification_error

def possessions_append(possessions, npa, play_obj, play_ID, play_type):
    possessions.append(npa)
    
    npa['turnover'] = 1 if npa['ended_with'] is not None and npa['ended_with'].endswith("Turnover") else 0
        
    if '--test-turnover-counts' in sys.argv:
        #print (sorted(npa.keys()))
        
        #zc.print_dict(play_obj)
        #zc.print_dict(npa)
        if '--team-ID' not in sys.argv or (int(sys.argv[sys.argv.index('--team-ID') + 1]) == play_obj['team_ID']):
            if '--just-turnovers' not in sys.argv or npa['turnover']:
                print ("{:<10}{:<10}{:<20}{:<10}{:<30}{:<30}{:<15}{:<15}{:<25}{}".format(
                convert_pct_complete_to_time_str(npa['start_time']/3600., datetime.now().year, "NCAA D1 Men")
                , convert_pct_complete_to_time_str(npa['end_time']/3600., datetime.now().year, "NCAA D1 Men")
                , play_obj['team']
                , "FC" if npa['failed_clear'] else ""
                , "" if npa['ended_with'] is None else  npa['ended_with']
                , "" if npa['weird'] is None else sum(npa['weird'])
                , "TO" if npa['turnover'] else ""
                , "PlayID: %s" % play_ID
                , "" if play_type is None else play_type
                ,  "" if play_obj['details'] is None else play_obj['details']))
        
    return possessions

def cleanse_data(data, url):
    data = data.replace("&#039;", "'")
    data = data.replace("&#39;", "'")
    data = data.replace("&#x27;", "")
    data = data.replace("&#x27;", "'")
    data = data.replace("p.m.<", "pm<")
    data = data.replace("Elizabeth (Libby) St", "Elizabeth St")
    data = data.replace("K. Francis-Thompson", "Francis-Thompson, Kainen")
    data = data.replace("LEWIS&amp;", "LEWIS").replace("LEWIS&", "LEWIS").replace("LEWISamp;", "LEWIS")
    data = data.replace("W&M", "WM").replace("W&amp;M", "WM")
    data = data.replace("W&J", "WJ").replace("W&amp;J", "WJ")
    data = data.replace("DAVISamp;", "DAVISAND")
    data = data.replace("WASH. & JEFF.", "WASHANDJEFF")
    data = data.replace("NOTRE DAME DE NAMUR", "NOTREDAME DE NAMUR")
    
    data = data.replace("WASH. &amp; JEFF.", "WASHANDJEFF")
    data = data.replace("JOHNSON AMP WALES (RI)", "JWURI")
    data = data.replace("JOHNSON & WALES (RI)", "JWURI")
    data = data.replace("JOHNSON &amp; WALES (RI)", "JWURI")
    
    data = data.replace("a.m.<", "am<")
    data = data.replace("FLORIDA TECH", "FLORIDATECH")
    data = data.replace(" LA SALLE ", " LASALLE ")
    data = data.replace(" LA SALLE,", " LASALLE,")
    data = data.replace(" LA SALLE.", " LASALLE.")
    data = data.replace("TD IRELAN", "TD IERLAN")
    data = data.replace("BLATZ, Jr", "BLATZ Jr")

    data = data.replace("p.m<", "pm<")
    data = data.replace("a.m<", "am<")
    data = data.replace(" Noon<", " 12 pm<")
    data = data.replace("{shot from far right wing}", "")
    data = data.replace("{free position shot}", "(free position shot)")
    data = data.replace("(FPGOAL) (free position shot)", "(FPGOAL)")
    data = data.replace("{free position attempt}", "(free position attempt)")
    data = data.replace("{fpgoal}", "(fpgoal)")


    #tmp = [".", ",", " "]
    #for tm in tmp:
    #    data = data.replace("SACRED H%s" % tm, "SACREDH%s" % tm)
    #    data = data.replace("ST. BONA%s" % tm, "STBONA%s" % tm)

    #data = data.replace("BING(1~M) ", "BINGM")
    #data = data.replace("MER(1)", "MER")
    #data = data.replace("11:-3", "11:03")
    #data = data.replace("&amp;", "&")
    #data = data.replace("1025 Clear attempt", "Clear attempt")
    if '4322820' in url['url']:
        data = data.replace("W&M", "WM")
        
    if '5244137' in url['url']:
        data = data.replace("TIMEOUT LRU", "TIMEOUT by LRU")
        
    if '5049079' in url['url']:
        data = data.replace("Timeout Maritime", "TIMEOUT by MTIME")
        data = data.replace("Timeout Manhattanville", "TIMEOUT by MVILLEWL")
        
    if '5033900' in url['url']:
        data = data.replace("Michael Peters (a)", "Michael Peters")
    
    # Remove non-ascii version and replace it with ascii version of characters
    tmp_apos = "%s%s%s" % (chr(226), chr(128), chr(153))
    data = data.replace(tmp_apos, "'")
    
    if '5248406' in url['url']:
        data = data.replace("SAINT LE", "SAINTLE")
    
    if '5226803' in url['url']:
        data = data.replace("Time Out D'Youville", "Timeout by DYOUVIL")
        data = data.replace("Time Out D&E", "Timeout by DAVISAND")
        data = data.replace("TIME OUT D&E", "Timeout by DAVISAND")
        data = data.replace("Time Out D'Y", "Timeout by DYOUVIL")
    
    if '5246527' in url['url']:
        data = data.replace("goal number \ for season", "goal number 0 for season")
        data = data.replace("Timeout Plymouth", "Timeout PLYMOUTHST")
        data = data.replace("Timeout PSU", "Timeout PLYMOUTHST")
        
    if '5236776' in url['url']:
        data = data.replace("Free position attempt for NPMLX22.", "[IGNORE PLAY]")
    
    if '5244504' in url['url']:
        data = data.replace("Foul on previous shot results in no draw", "[IGNORE PLAY]")
    

    if '5049079' in url['url']:
        data = data.replace("Timeout Maritime", "Timeout by MTIME")
    if '5228942' in url['url']:
        data = data.replace("Timeout NEC", "Timeout by NEWENGL")
        data = data.replace("Timeout Fitchburg", "Timeout by FITCHBUR")
    
    if '5251013' in url['url']:
        data = data.replace("goal number e", "goal number 0")
    if '5264149' in url['url']:
        data = data.replace("goal number E", "goal number 0")
    if '5265344' in url['url'] or '5286066' in url['url'] or '5244521' in url['url'] or '5232071' in url['url']:
        data = data.replace("goal number ]", "goal number 0")
        
    if '5069040' in url['url']:
        data = data.replace(">at goalie for ANNA.<", ">5 at goalie for ANNA.<")
        
    if '5244504' in url['url']:
        data = data.replace("Foul on previous shot results in no draw", "[IGNORE PLAY]")
        
    if '5248755' in url['url']:
        data = data.replace("TRINE1 substitution: Jillian Rejczyk for Maddy Kasten.", "[IGNORE PLAY]")
        
    if '5247866' in url['url']:
        data = data.replace("yellow card on bench", "[IGNORE PLAY]")
        
    if '5219383' in url['url']:
        data = data.replace("-3:-5", "03:05")
        
    if '5230170' in url['url']:
        data = data.replace("SJCLI get ball to start bc unsportsmanlike on WC to end half", "[IGNORE PLAY]")
    
    if '5275291' in url['url']:
        data = data.replace("GOAL by WIT Connor Charron (MAN-DOWN), Assist by TEAM.", "[IGNORE PLAY]")
        
    data = data.replace("injury timeout", "[IGNORE PLAY]")
    
    if '5076738' in url['url'] or '5067739' in url['url']:
        data = data.replace(">at goalie for SAL.<", ">66 at goalie for SAL.<")
        
    
    if '5211613' in url['url']:
        data = data.replace("Ground ball pickup by WU 3`.", "")
    
    
    if '5014274' in url['url']:
        data = data.replace("SLASH.Y1:00", "SLASH1:00")
    
    if '5053447' in url['url']:
        data = data.replace("S1:00)", "S/1:00)")
        data = data.replace("G1:00)", "G/1:00)")
        data = data.replace("K1:00)", "K/1:00)")
        data = data.replace("E1:00)", "E/1:00)")
    
    if '5275176' in url['url']:
        data = data.replace("TRI[", "TRIP")
    
    if '5272844' in url['url']:
        tmp = """<td class="smtext"></td>
	   <td class="smtext">Draw control by DEL Kellie Ann Matey.</td>"""
        rep = """<td class="smtext">15:00</td>
	   <td class="smtext">Draw control by DEL Kellie Ann Matey.</td>"""
        data = data.replace(tmp, rep)

    if '4948421' in url['url']:
        tmp = """s="smtext"></td>
   <td class="smtext">Draw co"""
        rep = """s="smtext">30:00</td>
   <td class="smtext">Draw co"""
        data = data.replace(tmp, rep)

    if '5244137' in url['url']:
        data = data.replace("TIMEOUT W'J", "Timeout by WJC")
    if '5078282' in url['url']:
        data = data.replace("Loyola Maryland", "Loyola MD")
    if '4578009' in url['url']:
        data = data.replace("GLASER, Callie,", "GLASER, Callie")
    if '5000662' in url['url']:
        data = data.replace("00:00", "30:00")
    if '4765776' in url['url']:
        data = data.replace("36:00", "26:00")
    if '4731813' in url['url']:
        data = data.replace("15:00", "30:00")
    if '4095670' in url['url']:
        data = data.replace("15:00", "30:00")
    if '4085768' in url['url']:
        data = data.replace("15:00", "30:00")
    if '4340005' in url['url']:
        data = data.replace("00:00", "30:00")
    if '4043793' in url['url']:
        data = data.replace("111:49", "11:49")
    if '4052003' in url['url']:
        data = data.replace("09:5229", "09:52")
    if '4009598' in url['url']:
        data = data.replace("15:00", "30:00", 2)
    if '3815386' in url['url']:
        data = data.replace("15:00", "30:00")
        data = data.replace("14:59", "29:59", 5)
        data = data.replace("14:59", "27:36")
        
    if '5275291' in url['url']:    
        data = data.replace("GOAL by WIT Connor Charron (MAN-DOWN), Assist by TEAM.", "")
    if '5279558' in url['url']:
        data = data.replace("Raleigh, N.C&gt;", "Raleigh, N.C")
        
    if '5065360' in url['url']:
        data = data.replace("reate and edit social-friendly content for Twitter, Instagram and YouT", "")
        data = data.replace("reate and execute social marketing campaigns and event coverage strate", "")
        

    if '4123802' in url['url']:
        data = data.replace(", goal number 07:35 for season", "")
    if '3813147' in url['url']:
        data = data.replace("Foul on UVa - Illegal Stick", "Foul on VA")

    if '4360690' in url['url']:
        data = data.replace("45:57", "25:57")
    if '3812003' in url['url']:
        data = data.replace("Serafini, Rachelle,", "Serafini, Rachelle")
    if '3797127' in url['url']:
        data = data.replace("Serafini, Rachelle,", "Serafini, Rachelle")
    if '3807355' in url['url']:
        data = data.replace("Timeout: Ohio State (04:34)", "Timeout by OSU")
        data = data.replace("Timeout: Ohio State (00:31)", "Timeout by OSU")
        data = data.replace("Timeout: Ohio State (02:43)", "Timeout by OSU")
        data = data.replace("Timeout: Hofstra (06:06)", "Timeout by HOFSTRA")
        data = data.replace("Timeout: Ohio State (03:20)", "Timeout by OSU")

    """
    if '' in url['url']:
        data = data.replace("", "Timeout by ")
        data = data.replace("", "Timeout by ")
        data = data.replace("", "Timeout by ")
        data = data.replace("", "Timeout by ")
        data = data.replace("", "Timeout by ")
    """

    if '3853560' in url['url']:
        data = data.replace("Timeout: Ohio State (08:14)", "Timeout by OSU")
        data = data.replace("Timeout: Maryland (03:59)", "Timeout by UMD")
        data = data.replace("Timeout: Maryland (13:54)", "Timeout by UMD")
        data = data.replace("Timeout: Ohio State (05:37)", "Timeout by OSU")
        data = data.replace("Timeout: Media", "Media timeout")
        data = data.replace("Timeout: Media", "Media timeout")
        data = data.replace("Timeout: Ohio State (02:11)", "Timeout by OSU")
        data = data.replace("Timeout: Maryland (01:25)", "Timeout by UMD")
        data = data.replace("Timeout: Ohio State (03:36)", "Timeout by OSU")
        data = data.replace("Timeout: Maryland (01:53)", "Timeout by UMD")


    if '3840567' in url['url']:
        data = data.replace("UMBC Timeout at 27:29 of second half", "Timeout by UMBC")
        data = data.replace("UNH timeout at 8:15 of second half", "Timeout by UNH")

    if '3822652' in url['url']:
        data = data.replace("SBU Timeout at 20:46 in 2nd half", "Timeout by SBU")
        data = data.replace("UNH Timeout at 15:01 in 2nd half", "Timeout by UNH")
        data = data.replace("SBU Timeout at 3:36 in 2nd half", "Timeout by SBU")

    if '3850903' in url['url']:
        data = data.replace("BU timeout at 17:15", "Timeout by BU")

    if '3811064' in url['url']:
        data = data.replace("Drexel Timeout at 20:48", "Timeout by DREXEL")

    if '3803903' in url['url']:
        data = data.replace(" OWN GOAL", " AUS, Rachel")

    if '3847022' in url['url']:
        data = data.replace("WIDE, goal number 30 for season", "WIDE")

    if '3843698' in url['url']:
        data = data.replace("Binghamton timeout at 1:38 of the first half", "Timeout by BING")
        data = data.replace("UNH timeout at 9:03 in the second half", "Timeout by UNH")
        data = data.replace("Timeout Binghamton at 2:58 of the second half", "Timeout by BING")

    if '3840187' in url['url']:
        data = data.replace("Timeout: Johns Hopkins (6:06)", "Timeout by JHU")
        data = data.replace("Timeout: Johns Hopkins (09:18)", "Timeout by JHU")
        data = data.replace("Timeout: Ohio State (04:15)", "Timeout by OSU")
        data = data.replace("Timeout: Ohio State (03:22)", "Timeout by OSU")
        data = data.replace("Timeout: TV Timeout (05:05)", "Media timeout")
        data = data.replace("Timeout: Ohio State (01:51)", "Timeout by OSU")
        data = data.replace("Timeout: TV Timeout (05:06)", "Media timeout")
        data = data.replace("Timeout: Johns Hopkins (01:55)", "Timeout by JHU")
        data = data.replace("Timeout: Johns Hopkins (01:23)", "Timeout by JHU")
        data = data.replace("Timeout: Ohio State (00:42)", "Timeout by OSU")


    if '3816611' in url['url']:
        data = data.replace("Timeout: Ohio State - 14:21", "Timeout by OSU")
        data = data.replace("Timeout: Denver 4:50", "Timeout by DEN")
        data = data.replace("Timeout: Ohio State 2:52", "Timeout by OSU")
        data = data.replace("Timeout: Officials 10:27", "Media timeout")
        data = data.replace("Timeout: Ohio State 0:54", "Timeout by OSU")
        data = data.replace("Timeout: Ohio State 0:48", "Timeout by OSU")


    if '4089306' in url['url']:
        data = data.replace("Cinn calls a timeout at 8:08 in the first half", "Timeout by CIN")
        data = data.replace("Cinn calls a timeout at 20:23 in the first half", "Timeout by CIN")
        data = data.replace("Cinn calls a timeout at 13:27 in the 2nd half", "Timeout by CIN")

    if '4079583' in url['url']:
        data = data.replace("Nova calls a timeout at 4:44", "Timeout by VU")
        data = data.replace("Nova calls a timeout at 14:40", "Timeout by VU")
        data = data.replace("Nova calls a timeout at 29:43", "Timeout by VU")
        data = data.replace("UConn calls a timeout at 14:09", "Timeout by UCONN")

    if '4068064' in url['url']:
        data = data.replace("Timeout Fairfield at 17:54 in the first", "Timeout by FAIRFD")
        data = data.replace("Timout Fairfield at 25:37 in the first", "Timeout by FAIRFD")

    if '4060765' in url['url']:
        data = data.replace("Timeout UConn at 7:13 in the first half", "Timeout by UCONN")
    if '4022274' in url['url']:
        data = data.replace("timeout JMU", "Timeout by JMU")
        data = data.replace("timeout UConn", "Timeout by UCONN")
    if '4015895' in url['url']:
        data = data.replace("timeout Quinnipiac", "Timeout by QUW")
        data = data.replace("timeout UConn", "Timeout by UCONN")

    if '4564346' in url['url']:
        data = data.replace("15:00", "30:00")
    if '4345372' in url['url']:
        data = data.replace("MOUNT-W\t", "MOUNT-W ")
        data = data.replace("SFU\t", "SFU ")
        data = data.replace("MOUNT-W  ", "MOUNT-W ")
        data = data.replace("SFU  ", "SFU ")
        data = data.replace("MOUNT-W .", "MOUNT-W.")
        data = data.replace("SFU .", "SFU.")
    if '3798074' in url['url']:
        data = data.replace("20:00", "15:00")
    if '4559640' in url['url']:
        data = data.replace("25:00", "15:00")
    if '4300795' in url['url']:
        data = data.replace("Timeout UConn", "Timeout by UConn")
    if '4329743' in url['url']:
        data = data.replace("Timeout UConn", "Timeout by UConn")
        data = data.replace("Timeout Georgetown", "Timeout by GU")
    if '4296219' in url['url']:
        data = data.replace("Timeout UConn", "Timeout by UConn")
        data = data.replace("Timeout BC", "Timeout by BC")
    if '4343140' in url['url']:
        data = data.replace("Timeout UConn", "Timeout by UConn")
        data = data.replace("Timeout Butler", "Timeout by BULAX")


    if '4544386' in url['url']:
        data = data.replace("14:265", "14:26")
        data = data.replace("142:12", "14:12")
    if '4281579' in url['url']:
        data = data.replace("29:", "14:")
    if '4921666' in url['url']:
        data = data.replace("00:00", "30:00")
    if '4114047' in url['url']:
        data = data.replace("2-point Shot by UMBC Maxwell, Max MISSED, Assist by Haldeman, Max", "Shot by UMBC Maxwell, Max WIDE")
    if '4502452' in url['url']:
        data = data.replace("2-point Shot by BU McCarthy, Bridget MISSED, Assist by Conry, Kailey, goal number 4 for season", "2-point Shot by BU McCarthy, Bridget WIDE")
    if '4533235' in url['url']:
        data = data.replace("00:00", "30:00")
    if '4329910' in url['url']:
        data = data.replace("03:45 CLEAR:03:59", "03:59")
    if '4358870' in url['url']:
        data = data.replace("07:32 TOUT:07:19", "07:32")
    if '4346967' in url['url']:
        data = data.replace("00:00", "15:00", 1)
    if '4306332' in url['url']:
        data = data.replace("00:00", "15:00", 1)
    if '4302085' in url['url']:
        data = data.replace("2nd Quarter", "[Removed]", 3)
    if '4707754' in url['url']:
        data = data.replace("00:00", "30:00")
    if '4299198' in url['url']:
        data = data.replace("30:00", "15:00")
    if '4747999' in url['url']:
        matches = re.findall(re.compile(r'([\s\S]{20}00\:00[\s\S]{50})'), data)
        for i, m in enumerate(matches):

            if i > 0:
                m_alt = m.replace("00:00", "15:00")
                data = data.replace(m, m_alt)

    
    # Clean up bad goal number suffixes
    regex = re.compile('(goal number ([0-9]+)(.*?)( for|\.|$))', re.IGNORECASE)
    matches = re.findall(regex, data)
    for m in matches:
        #print ("\n")
        #print m
        orig = m[0]
        new_str = "goal number %s%s" % (m[1], m[3])
        #print "replace %s with %s" % (orig, new_str)
        data = data.replace(orig, new_str)
        
    regex = re.compile('(goal number ([^0-9]+?)( for|\.|$))', re.IGNORECASE)
    matches = re.findall(regex, data)
    for m in matches:
        #print ("\n")
        #print m
        orig = m[0]
        new_str = "goal number 0%s" % (m[2])
        #print "replace %s with %s" % (orig, new_str)
        data = data.replace(orig, new_str)
        #zc.exit("BAD GOAL")
    
    # Clean up manually entered Timeout records
    regex = re.compile('(>Timeout ([^\s]+?)<)', re.IGNORECASE)
    matches = re.findall(regex, data)
    for m in matches:
        #print ("\n")
        #print m
        orig = m[0]
        new_str = ">Timeout by %s<" % m[1]
        #print "replace %s with %s" % (orig, new_str)
        data = data.replace(orig, new_str)
    regex = re.compile('(>([^\s]+?) Timeout<)', re.IGNORECASE)
    matches = re.findall(regex, data)
    for m in matches:
        #print ("\n")
        #print m
        orig = m[0]
        new_str = ">Timeout by %s<" % m[1]
        #print "replace %s with %s" % (orig, new_str)
        data = data.replace(orig, new_str)

    
    if '4366014' in url['url']:
        regex = re.compile(r'(>00:00<.*?[\s\r\n]+.*?<td[^>]*?>Faceoff)')
        match = regex.search(data)
        if match is None:
            print ("No match");
        else:
            print (match.group(1), "becomes", match.group(1).replace("00:00", "15:00"))
            data = data.replace(match.group(1), match.group(1).replace("00:00", "15:00"))

    if '4043184' in url['url']:
        data = data.replace("10:50", "00:01")
        data = data.replace("End of 2nd Quarter", "[Removed]", 1)
        data = data.replace("End of 4th Quarter", "[Removed]", 1)
        regex1 = re.compile(r'(<tr>[\s\r\n]+?.*?11:35.*?[\s\r\n]+?.*?[\s\r\n]+?.*?9\-10.*?[\s\r\n]+?.*?[\s\r\n]+?.*?</tr>)')
        match1 = regex1.search(data)
        regex2 = re.compile(r'(<tr>[\s\r\n]+?.*?11:47.*?[\s\r\n]+?.*?[\s\r\n]+?.*?7\-7.*?[\s\r\n]+?.*?[\s\r\n]+?.*?</tr>)')
        match2 = regex2.search(data)
        if match1 is None:
            print ("No match")
        else:
            play1 = match1.group(1)
            print ("Found the out of place play:\n%s\n"% play1)

            data = data.replace(play1, "")
            play1 = play1.replace("9-10", "7-7")
            if match2 is None:
                print ("2nd no match")
            else:

                play2 = match2.group(1)
                print ("Found the previous play:\n%s\n"% play2)
                data = data.replace(play2, play2 + play1)



    if '4302385' in url['url']:
        regex = re.compile(r'(>00:02<.*?[\s\r\n]+.*?<td[^>]*?>Ground ball pickup by NC Brian Balkam)')
        match = regex.search(data)
        if match is None:
            print ("No match")
        else:
            print (match.group(1), "becomes", match.group(1).replace("00:02", "00:04"))
            data = data.replace(match.group(1), match.group(1).replace("00:02", "00:04"))

    if '4363474' in url['url']:
        regex = re.compile(r'>(.*?3:36)<')
        matches = re.findall(regex, data)
        for m in matches:
            if m != "13:36":
                print ("replace %s w/ %s" % (m, "3:36")); time.sleep(5)
                data = data.replace(m, "3:36")



    data = data.replace("BOSTON U", "BOSTONU")
    data = data.replace("by ROBERT M", "by ROBERTM")
    data = data.replace("for ROBERT M", "for ROBERTM")

    if '3846117' in url['url']:
        data = data.replace("SAINT JO ", "SAINTJO ")
        data = data.replace("SAINT JO.", "SAINTJO.")
        data = data.replace("SAINT JO,", "SAINTJO,")

    if '4364260' in url['url']:
        data = data.replace("15:43", "14:43")
        data = data.replace("15:37", "14:37")
    if '4800748' in url['url']:
        data = data.replace("-3:37", "03:37")
        data = data.replace("-2:-2", "03:37")
    if '4515981' in url['url']: data = data.replace("00:00", "30:00")
    if '4949335' in url['url']: data = data.replace("00:00", "30:00")
    if '4765776' in url['url']: data = data.replace("Shot clock violation 22:50", "Shot clock violation by WOF")
    if '4759064' in url['url']: data = data.replace(">Hartford Timeout #1<", ">Timeout by Hartford.<")
    if '4727665' in url['url']: data = data.replace(", goal number 27:06 for season", "")
    if '4736779' in url['url']: data = data.replace("GEORGE W", "GEORGEW")
    if '4567594' in url['url']: data = data.replace("GEORGE M", "GEORGEM")
    if '4727665' in url['url']: data = data.replace("ROBERT M", "ROBERTM").replace("GEORGE W", "GEORGEW")
    if '4773846' in url['url']: data = data.replace("MOUNT ST", "MOUNTST")
    if '4759101' in url['url']: data = data.replace("LIU B", "LIUB")
    if '4785478' in url['url']: data = data.replace("Timeout Binghamton", "Timeout by BING").replace("Timeout Ohio State", "Timeout by OSU")
    if '4943259' in url['url']:
        rows = data.split("\n")
        times_seen = 0
        for ir, r in enumerate(rows):
            if "00:00" in r:
                if times_seen < 7:

                    r = r.replace("00:00", "")


                times_seen += 1
            rows[ir] = r
        data = "\n".join(rows)



    while "  " in data:
        data = data.replace("  ", " ")

    final_data = ""
    for d in data:
        if ord(d) == 235:
            final_data += "e"
        else:
            final_data += d

    return data

def log_timestamps_generic(txt, target_dir, fname, specs={}):
    """
    This function is a generic function that logs timestamps for a given process. Specify the file directory, the name of the file and the txt to be stored.
    """
    
    if 'clear' in specs and specs['clear']:
        f = open(src, 'w'); f.write("%s\n" % txt); f.close()
    
    if txt not in [None, '']:
        src = os.path.join(target_dir, fname)
        if os.path.isdir(target_dir):
            f = open(src, 'a'); f.write("%s\n" % txt); f.close()
        else:
            print (" [WARNING] in log_timestamps_generic, target path not found: %s" % src)
        
def set_ended_with(option_a, last_plays, poss, play_obj, play, play_ID):
    #print "{:<20.0f}{:<40}{:<20}{}".format(play_obj['pct_complete']*3600., option_a, "PlayID: %s" % play_ID, play_obj['details'])
    
    if poss is not None:
        poss['ended_with'] = option_a
    
    
        if option_a == "Failed Clear" and len(last_plays) > 0 and last_plays[-1].endswith("Turnover"):
            # For other statistical reasons (i.e. how we ID turnovers), if there is a failed clear that is caused by a TO, we want the possession to end with the TO, not the failed clear.
            poss['ended_with'] = last_plays[-1]
        elif option_a == "EOG" and len(last_plays) > 0 and last_plays[-1].endswith("Turnover"):
            # For other statistical reasons (i.e. how we ID turnovers), if the last play of the game is a turnover, then the possession should end with the turnover.
            poss['ended_with'] = last_plays[-1]
            
        
    
    return poss
    
def telegram_alert(s):
    """ 
    Instead of using send_telegram, which will default to an email, this function explicitly sends a message to the Admin Telegram channel
    """
    
    send_msg = 1; not_sent_reason = ""
    
    if s is not None and "StaleElementReferenceException" in s:
        send_msg = 0; not_sent_reason = "Do not alert because of a StaleElement; these are no errors that must be addressed"
    
    if send_msg:
    
        try:
            send_bot = telepot.Bot(token=bot_token)
            
            chat_id_path = os.path.join(piFolder, "ask_chat_id")
            if not os.path.isfile(chat_id_path):
                # Waits for the first incoming message
                updates=[]
                while not updates:
                    updates = send_bot.getUpdates()

                # Gets the id for the active chat
                chat_id=updates[-1]['message']['chat']['id']
                f = open(chat_id_path, 'w'); f.write(str(chat_id)); f.close()
            else:
                chat_id = open(chat_id_path, 'r').read()

            # Sends a message to the chat

            send_bot.sendMessage(chat_id=chat_id, text=s)
        except Exception:
            src = os.path.join(lr_fldr, "Logs", "FailedTelegrams_%s.txt" % datetime.now().strftime("%Y%m%d"))
            f_log = io.open(src, 'a', encoding="utf8")
            f_log.write("[%s]\n%s\n" % (datetime.now().strftime("%H:%M:%S"), s))
            f_log.close()
    else:
        print ("Telegram Msg not sent: %s" % (not_sent_reason))
        
def add_odds_to_plays_list(plays, game_data, specs):
    """
    This function is designed to be the source-of-truth for adding win probabilities to a list of plays
    """
    error = None
    last_quarter = None; last_odds = None
    play_buffer = []
    weight_param = 100.
    game_state = 0
    
    #print game_data['plays']
    
    for i, r in enumerate(plays):
        #r['seq'] = i
        
        r['pct_complete'] = float(r['game_elapsed']) / 3600.0
        r['is_new_quarter'] = 0
        if last_quarter not in [r['quarter'], None]:
            r['is_new_quarter'] = 1
        
        r['section'] = int(r['pct_complete'] * specs['sections'])
        if r['section'] >= 120:
            ot = True
        else:
            ot = False
        r['section'] = min(r['section'], specs['sections']-1)
    
        #print "{:<30}{:<10}".format(r['event_type'], r['event_type'] not in game_data['plays'])
        if r['event_type'] not in game_data['plays']:
            if 'description' in game_data:
                msg = ("Unknown play type in %s!!!\n\n" % game_data['description'])
            else:
                msg = ("Play %d/%d: unknown play type %s!!!\n\nList of play types: %s\n\n" % (i+1, len(plays), r['event_type'], game_data['plays']))
            msg += (r['detail'])
            print (msg); 
            try:
                msg += "\n\n" + zc.print_dict(r)
            except Exception:
                pass
            #zc.send_telegram(msg, bot_token)
            # Do not show the full msg because it includes the sequence of the play, which means that the error message is going to change with each parse. That means even though it's the same play, the msg changes each time. We just want to get the message once.
            #error = "Bad Play Type: %s\n\n%s" % (r['detail'], msg)
            error = "Bad Play Type: %s (%s)" % (r['detail'], game_data['description'])
            
            return plays, error
             
        
        try:
            r['starting_odds_weight'] = max(0, (ln(weight_param+1) - ln(r['pct_complete']*100.0/(100.0/weight_param)+1))/ln(weight_param+1))
            r['game_state_weight'] = 1.0 - r['starting_odds_weight']
        except Exception:
            error = "In %s, could not calculate the starting odds from the pct complete value (%.3f). If the pct_complete value is negative, that typically means that the timestamps do not start with the correct amount of minutes. For example if the first timestamp is 30:00, use replacement text in the admin cockpit to switch 30:00 to 15:00." % ("???" if 'description' not in game_data else game_data['description'], r['pct_complete'])
            
            error += json.dumps(r, default=zc.json_handler, indent=2)
            
            error += "\n\n%s" % traceback.format_exc()
            r['game_state_weight'] = 1.0
            r['starting_odds_weight'] = 0.0
            
        

        last_quarter = r['quarter']
        
        
    for i, r in enumerate(plays):
    
        if r['is_new_quarter']:
            play_buffer = []
            

        if "GOAL" in r['event_type'].upper() and "GOALIE CHANGE" not in r['event_type'].upper():
            if r['team'].strip() == game_data['home_team']:
                game_state += 1
                
            elif r['team'].strip() == game_data['away_team']:
                game_state -= 1
                
        r['game_state'] = game_state        
        
        loc = 22 + game_state
        loc = max(min(41, loc), 0)

        if r['team'].strip().upper() in game_data['home_abbreviations']:
            play = [r['event_type'], game_data['play_values_for'][game_data['plays'].index(r['event_type'])], game_data['play_values_against'][game_data['plays'].index(r['event_type'])], int(r['game_elapsed'])]
        else:
            play = [r['event_type'], game_data['play_values_against'][game_data['plays'].index(r['event_type'])], game_data['play_values_for'][game_data['plays'].index(r['event_type'])], int(r['game_elapsed'])]
        play_buffer.append(play)

        # Remove plays that have aged out of the analysis
        if r['pct_complete'] > .9:
            while int(r['game_elapsed']) - play_buffer[0][3] > (game_data['window_length']/3.0):
                play_buffer.pop(0)
        else:
            while int(r['game_elapsed']) - play_buffer[0][3] > game_data['window_length']:
                #if r['pct_complete'] > .9864: print("  (%d) Remove %s" % (game_data['window_length'], str(playbuffer[0])))
                play_buffer.pop(0)

        r['adjusted_diff'] = float(game_state)
        r['diff_offset'] = 0


        for play in play_buffer:
            #if r['pct_complete'] > .9864: print("\t\t%s" % str(play))
            r['adjusted_diff'] += play[1]
            r['adjusted_diff'] -= play[2]
            r['diff_offset'] += play[1]
            r['diff_offset'] -= play[2]
        
        #input("sections in game_data: %s" % ('sections' in game_data))
        #r['raw_odds'] = get_adj_odds(r['section'], r['adjusted_diff'], game_data['win_odds_data'], game_data['win_odds_ID'])
        r['raw_odds'] = get_adj_db_odds(r['section'], game_state, r['adjusted_diff'], game_data)

        #if r['pct_complete'] > 0.9864: print("Initial odds: %s" % r['raw_odds'])
        if r['raw_odds'] == -1:
            if r['adjusted_diff'] > 5:
                r['raw_odds'] = 1
            elif r['adjusted_diff'] < -5:
                r['raw_odds'] = 0
            else:
            
                
                msg = ("In live win odds; epic Fail 4kfir.1!!!\n\n")
                msg += ("\tSection = %d\tr['diff_offset'] = %f\tAdjusted Diff = %f" % (r['section'], r['diff_offset'], r['adjusted_diff']))
                if error is None:
                    error = msg


        if r['quarter'] >= 5 and game_state == 1:
            r['raw_odds'] = 1
        elif r['quarter'] >= 5 and game_state == -1:
            r['raw_odds'] = 0

        
        
        if '--debug-wp-calc' in sys.argv:
            print ("{:<5}{:>10.3f}{:>10.0f}{:>10.3f}{:>10.3f}{:>10.3f}{:>10.3f}{:>10.0f}{:>10.3f} final odds = {:.3f}".format(r['quarter'], r['pct_complete'], r['game_elapsed'], 1. - r['raw_odds'], r['section'], r['adjusted_diff'], game_data['home_win_odds'], game_state, 1. - (r['raw_odds'] * r['game_state_weight'] + game_data['home_win_odds'] * r['starting_odds_weight']), r['raw_odds'] * r['game_state_weight'] + game_data['home_win_odds'] * r['starting_odds_weight']))
        r['odds'] = r['raw_odds'] * r['game_state_weight'] + game_data['home_win_odds'] * r['starting_odds_weight']
        
        
        if 'use_db_plays' in game_data and game_data['use_db_plays']:
            if i == len(plays) - 1:
                if game_state > 0:
                    r['odds'] = 1
                else:
                    r['odds'] = 0
        else:
            if r['quarter'] >= 5 and game_state == 1:
                r['odds'] = 1
            elif r['quarter'] >= 5 and game_state == -1:
                r['odds'] = 0
            elif r['pct_complete'] > .97 and 'end_of_period' in game_data and game_data['end_of_period'] and game_state > 0:
                print("The quarter has ended, so the game must be over.")
                r['odds'] = 1
            elif r['pct_complete'] > .97 and 'end_of_period' in game_data and game_data['end_of_period'] and game_state < 0:
                print("The quarter has ended, so the game must be over.")
                r['odds'] = 0
            elif i == len(plays)-1 and '-over' in sys.argv and game_state > 0:
                print("The quarter has ended, so the game must be over.")
                r['odds'] = 1
            elif i == len(plays)-1 and '-over' in sys.argv and game_state < 0:
                print("The quarter has ended, so the game must be over.")
                r['odds'] = 0

        r['home_pre_wp'] = (100.0*r['odds']) if last_odds is None else (100.0*last_odds)
        r['home_post_wp'] = (100.0*r['odds'])
        r['home_wp_change'] = None if None in [r['home_post_wp'] , r['home_pre_wp']] else r['home_post_wp'] - r['home_pre_wp']

        r['away_pre_wp'] = (100.0*(1.0-r['odds'])) if last_odds is None else (100.0*(1.0-last_odds))
        r['away_post_wp'] = (100.0*(1.0-r['odds']))
        r['away_wp_change'] = None if None in [r['away_post_wp'] , r['away_pre_wp']] else r['away_post_wp'] - r['away_pre_wp']

        last_odds = r['odds']
        last_quarter = r['quarter']
        
    return plays, error

def process_free_positions(events, shots, next_man_up_ID, existing, db_players, fp_type_counts, g, conn, cursor):
    """
    This function takes in a set of LaxRef_Events and a set of LaxRef_Shots and processes them to establish the appropriate free position tags.
    """
    
    for e in existing:
        e['tup'] = (e['team_ID'], e['game_ID'], e['sequence'])
        
        
    

    home_ID = g['home_team']['ID']
    away_ID = g['away_team']['ID']
    home_team = g['home_team']['team']
    away_team = g['away_team']['team']
    seq = 0
    for i, s in enumerate(shots):
        s['on_goal'] = 1 if (s['play_type'] in ["Pipe Shot", "Saved Shot"] or s['play_type'].endswith("Goal")) else 0
        s['on_keeper'] = 1 if (s['play_type'] in ["Saved Shot"] or s['play_type'].endswith("Goal")) else 0
        
        s['post'] = 1 if s['on_goal'] and not s['on_keeper'] else 0
        s['saved'] = 1 if s['on_goal'] and s['on_keeper'] and not s['goal'] else 0
        s['missed'] = 1 if not s['on_goal'] else 0

        
    # 1. Establish the sequencing of the LaxRef_Events to help with identifying whether a shot came after an FP Attempt
    for i, e in enumerate(events):
        e['seq'] = i
        
    # 2. When an event is encountered, categorize whether it is an FP-based event and what type of event it is based on the play type (or lack there of if it's just noting an FP attempt)
    for e in events:
        e['fp_shot'] = 0; e['fp_attempt'] = 0; e['fp_save'] = 0; e['fp_goal'] = 0; e['fp'] = 0
        sdl = e['details'].lower().replace(" ", "")
       
        if "freepositionshot" in sdl or "fpgoal" in sdl:
            e['fp'] = 1
            e['fp_shot'] = 1
            e['fp_save'] = 1 if " save " in sdl or " saved " in sdl else 0
            if "fpgoal" in sdl:
                e['fp_goal'] = 1
        elif "freepositionattempt" in sdl:
            e['fp_attempt'] = 1
            e['fp'] = 1
    
        #print "{:<5}{:<5}{}".format("YES" if e['fp'] else "", e['time_elapsed'], e['details'])
        
    # 3. We don't need to do anything to game events that have nothing to do with free position attempts; also, if a pxp log entry is just noting that there is an FP attempt, and the subsequent play is the actual free position play, we can get rid of the pxp line that is just noting that an FP has been awared. If we didn't do this, we'd be double counting the number of free positions awarded. Anything that is either the start of an FP attempt or a non-FP event will be removed.
    for e in events:
        e['remove'] = 0
        if e['fp_attempt']:
            tmp = [z for z in events if z['team'] == e['team'] and z['seq'] > e['seq'] and z['fp'] and z['seq'] - e['seq'] == 1]
            if len(tmp) > 0: # A subsequent FP shot exists
                e['remove'] = 1
    fp_events = sorted([z for z in events if z['fp'] and not z['remove']], key=lambda x:x['time_elapsed'])
    
    if '--print-fp-events' in sys.argv:
        for fp in fp_events:
            fp['time_str'] = convert_pct_complete_to_time_str(fp['time_elapsed']/3600., 2021, "NCAA D1 Women")
    
        print ("Processing %d fp_events out of %d total plays list objects" % (len(fp_events), len(events)))
        print ("{:<20}{:<20}{:<20}".format("Elapsed", "Time", "Team"))
        print ("-"*200)
        print ("\n".join(["{:<20}{:<20}{:<20}".format(z['time_elapsed'], z['time_str'], z['team']) for z in fp_events]))
    
    
    # 4. For every FP event left, determine what happened and set the flags that will allow the record to be entered into the database. Every FP event is given a type value...
    
    """
    1 = No shots were taken
    2 = Free position shot was taken
    5 = SHOT OFF 1 PASS
    6 = GOAL OFF 1 PASS
    """
    
    # 4a. To do this, we are mostly checking the list of shots to see if there is a) a shot marked as an FP shot that occurred at the same time as the FP attempt was noted OR came within a few seconds and wasn't marked as an FP event (i.e. a shot off one pass)
    
    for s in fp_events:

        s['team_ID'] = home_ID if home_team == s['team'] else away_ID
        
        my_shots = [z for z in shots if z['team_ID'] == s['team_ID']]
        s['opp_ID'] = away_ID if home_ID == s['team_ID'] else home_ID
        #s['team_odds'] = None
        
        
        sdl = s['details'].lower().replace(" ", "")
        if s['fp_goal']:
            tmp = [z for z in my_shots if z['goal'] and z['time_elapsed'] - s['time_elapsed'] == 0]
        elif s['fp_save']:
            tmp = [z for z in my_shots if not z['goal'] and z['saved'] and abs(z['time_elapsed'] - s['time_elapsed']) == 0]
        elif s['fp_shot']:
            tmp = sorted([z for z in my_shots if not z['goal'] and z['time_elapsed'] - s['time_elapsed'] == 0], key=lambda x:x['seq'])
        elif s['fp_attempt']:
            tmp = sorted([z for z in my_shots if 0 <= s['time_elapsed'] - z['time_elapsed'] < 5], key=lambda x:x['seq'])
            
            
        else:
            msg = "In the free position shot categorization model, we couldn't determine how to process an FP event in the following game.  Note, this isn't going to stop the script from running, but it may mean that an FP event isn't getting processed correctly.\n\n%s\n\n%s" % (zc.print_dict(g), zc.print_dict(s))
            zc.send_telegram(msg, bot_token)
            tmp = []
            
        # Record in the shot record that it was an FP shot
        
        for t in tmp:
            t['time_diff'] = abs(t['time_elapsed'] - s['time_elapsed'])
        tmp = sorted(tmp, key=lambda x:x['time_diff'])
        
        n_matches = len(tmp)
        
        if s['fp_attempt'] and n_matches == 1:
            
            s['shot_ID']= tmp[0]['ID']
            s['type'] = 5
            if tmp[0]['goal']:
                s['type'] = 6
            t['one_pass_free_position'] = 1
            
            # A shot within 5 seconds matched, so record that as a shot off-one-pass
        elif s['fp_attempt'] and n_matches > 1:
            
            s['type'] = 5
            t = tmp[0]
            if t['goal']:
                s['type'] = 6
            t['one_pass_free_position'] = 1

            # Multiple shots within 5 seconds matched, so record the first one as a shot off-one-pass
        elif s['fp_attempt'] and n_matches == 0:
       
            s['type'] = 1
            # No shots match, so no immediate shots of a pass was taken
            pass
        elif (s['fp_shot'] or s['fp_goal']) and n_matches == 1:
            s['type'] = 2
            s['shot_ID']= tmp[0]['ID']
            tmp[0]['free_position '] = 1
            
            # We found a single matching shot record; record as a LaxRef_Man_Up record and flag the shot record as a free position
            pass
        elif (s['fp_shot'] or s['fp_goal']) and n_matches == 0:
            s['type'] = 3
            #print "\n\n{:<10}{:<10}{:<10}{:<10}{:<20}{:<20}{:<20}{}".format(s['time_str'], s['time_elapsed'], s['team'], s['team_ID'], "n matches=%d" % n_matches, "Shot? %s" % ("YES" if s['fp_shot'] else "NO"), "Goal? %s" % ("YES" if s['fp_goal'] else "NO"), s['details'])
            # No shot record matched
            pass
        elif (s['fp_shot'] or s['fp_goal']) and n_matches > 1:
            s['type'] = 2
            s['alt_type'] = 0
            # More than one shot record matched; look at the shooters to try and figure out which shot it was
            name_matched = 0
            t = tmp[0]
            t['free_position'] = 1

        else:
            s['type'] = None
        
        
        s['goal'] = 1 if s['fp_goal'] or s['type'] == 6 else 0
        s['shots_taken'] = 1 if s['type'] not in [1, None] else 0
        s['fp_shot_taken'] = 1 if s['fp_goal'] or s['fp_shot'] or s['fp_save'] else 0
        
        insert_man_up_query = "INSERT INTO LaxRef_Man_Up (ID, game_ID, opp_ID, team_ID, sequence, team_odds, start_time, goals, active, shots_taken, fp_shot_taken) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
        s['param'] = None
        s['tup'] = (s['team_ID'], g['ID'], seq)
        if s['tup'] not in [z['tup'] for z in existing]:
            s['param'] = [next_man_up_ID, g['ID'], s['opp_ID'], s['team_ID'], seq, s['team_odds'], s['time_elapsed'], s['goal'], 1, s['shots_taken'], s['fp_shot_taken']]
            next_man_up_ID += 1
        #    print "{:<10}{}".format("Add", str(s['tup']))
        #else:
        #    print "{:<10}{}".format("", str(s['tup']))
        seq += 1
    man_ups_params = [z['param'] for z in fp_events if z['param'] is not None]
    
    
    if len(man_ups_params) > 0:
        #msg = "In Game ID %d, there were %d free-position rows added" % (g['ID'], len(man_ups_params)); zc.send_telegram(msg, bot_token)
        print (" Adding %d free position attempts to the DB..." % (len(man_ups_params)))
        n = float(len(man_ups_params)); start_ms = time.time()
        if '--use-fast-upload' not in sys.argv:
            cursor.execute("START TRANSACTION")
            for p in man_ups_params:
                cursor.execute(insert_man_up_query, p)
            if '--no-commit' not in sys.argv: cursor.execute("COMMIT")
        else:
            cursor.executemany(insert_man_up_query, man_ups_params)
            print ("  Uploaded {:,} free positions".format(cursor.rowcount))
            if '--no-commit' not in sys.argv: conn.commit()

        end_ms = time.time()
        per_n = (end_ms - start_ms)/n

        print ("  It took %.3f seconds per free position" % (per_n))
    
    return shots, next_man_up_ID, fp_type_counts, fp_events
    
def laxdotcom_PGS_queries(specs):
    """
    This function takes in a set of players and their stats from Live Win Odds and checks them against the LaxDotCom game_data* tables to see if records need to be inserted or updated. The queries are returned as a list to be run by the requesting script.
    """
    insert_query = ""
    update_query = ""
    
    insert_params = []; update_params = []
    
    return specs, insert_query, insert_params, update_query, update_params

def create_game_dict(cursor, game_ID, play_data, settings, to_screen):
    show_cgd_timedstamps = 1 if '--show-cgd-timestamps' in sys.argv else 0
    
    if show_cgd_timedstamps:
        print("     {:<95}{:<15}".format("Begin create_game_dict...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
        
    EXPORT_ERRORS=1
    
    """
    Error codes for laxref.create_game_dict

    1. LRP JSON game file is empty
    2. LRP JSON game file is corrupted
    3. Home or Away Elo is not set ( is equal to ??? )
    4. Game has > 400 active LaxRef_Events
    5. Possession attribution error
    6. No play could be determined from details
    7. Classification didn't yield valid play (i.e. unsportsmanlike on the bench)
    8. Classification error (regex parsing of play details caused error)
    9. Pct Complete value was < 0
    10.Faceoff players could not be tagged to either team
    11. Play not identified as type Offense/defense/FOGO
    12. Player could not be identified from details
    """
    
    
    steps = [{'step': 'Start', 'time': time.time()}]
    # Set up regexes
    classifiers = []
    team_pattern = "A-Z\-0-9\&\~\(\)\_\.\'"
    pregame_home_wp = None
    
    errors = []

    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Clear attempt by ([tp]+) (failed|good)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Timeout(?: by| for|:)? ([tp]+)(?:(?: -)?\s*?[\(\)0-9\:]+)?(?:\s?\(?[a-z]+ half\)?)?\.?', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Timeout(?: by)? ([tp]+)(?:(?: -)?\s*?at\s*?[\(\)0-9\:]+)?(?:\s?\([a-z]+ half\))?\.?', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Timeout(?: by| for|:)? ([tp]+)(?:\s*?with)?\s*?[\(\)0-9:]+(?:\s*?on the clock)?\.?', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})

    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '([tp]+) Timeout(?:(?: -)?\s*?[\(\)0-9\:]+)?(?:\s?\(?[a-z]+ half\)?)?\.?', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '([tp]+) Timeout(?:(?: -)?\s*?at\s*?[\(\)0-9\:]+)?(?:\s?\([a-z]+ half\))?\.?', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '([tp]+) Timeout(?:\s*?with)?\s*?[\(\)0-9:]+(?:\s*?on the clock)?\.?', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})

    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:30-second|shot) clock warning (?:against|by) ([tp]+)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:30-second |shot )?clock violation (?:against|by) ([tp]+)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '([tp]+) (?:30-second |shot )?clock violation\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})

    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(.*?) (?:in goal|at goalie) (?:by|for) ([tp]+?)\s*?\.', 'p_group': 0, 'p_play': "ptype", 'p_team': 1})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '\s*(?:in goal|at goalie) (?:by|for) ([tp]+?)\s*?\.', 'p_group': 0, 'p_play': "ptype", 'p_team': 0})


    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Shot by ([tp]+)[\s,]+(.*?)(?: \(?free position shot\)?)?,? (?:MISSED|WIDE|WIDE LEFT|WIDE RIGHT|HIGH|PIPE|BLOCKED|DEFENSIVE SAVE|HIT POST|HIT CROSSBAR)(?: \(?free position shot\)?)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1,    'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Shot by ([tp]+)[\s,]+(.+?)(?: \(?free position shot\)?)?, (?:DEFENSIVE )?SAVE (?:by )?(.+?)(?: \(?free position shot\)?)?(,? goal number(?: [\S]+)?(?: for)?(?: season)?)?\.$', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Save", 'p1_team': "", 'p2_team': "other"})
    classifiers.append({'wght': 1,    'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Shot by ([tp]+)[\s,]+(.+?) (?:DEFENSIVE )?SAVE (?:by )?(.+?)(?: \(?free position shot\)?)?\.$', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Save", 'p1_team': "", 'p2_team': "other"})
    classifiers.append({'wght': .9,   'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Shot by ([tp]+),? (?:DEFENSIVE )?SAVE (?:by )?(.+?)(?: \(?free position shot\)?)?\.', 'p1_group': 0, 'p1_play': "ptype", 'p2_group': 1, 'p2_play': "Save", 'p1_team': "", 'p2_team': "other"})
    classifiers.append({'wght': .8,   'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Shot by ([tp]+)[\s;,]+(.+?)(?: Blocked by [tp]+)?(?: \(?free position shot\)?)?(,? goal number(?: [\S]+)?(?: for)?(?: season)?)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})


    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:Foul|Yellow card|Green card|Red card) (?:on|by) ([tp]+) (.+)\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:Foul|Yellow card|Green card|Red card) (?:on|by) ([tp]+)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)[;,]?(?: \(?30-Second Count\)?| \(?30-Second Timer\)?| \(?[a-z]+ GOAL\)?| \(?MAN-UP\)?| \(?MAN-DOWN\)?| \(?FPGOAL\)?| \(?free position shot\)?)?(?: \(?30-Second Count\)?| \(?30-Second Timer\)?| \(?[a-z]+ GOAL\)?| \(?MAN-UP\)?| \(?MAN-DOWN\)?| \(?FPGOAL\)?| \(?free position shot\)?)?(?: \(?30-Second Count\)?| \(?30-Second Timer\)?| \(?[a-z]+ GOAL\)?| \(?MAN-UP\)?| \(?MAN-DOWN\)?| \(?FPGOAL\)?| \(?free position shot\)?)?(,? goal number(?: [\S]+)?(?: for)?(?: season)?)\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    
    classifiers.append({'wght': .5, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.+?)\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    
    
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.+?)[,;](?: \(MAN-UP\)| \(MAN-DOWN\)| \([a-z]+ GOAL\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?: \(?free position shot\)?)?| \(man-down\))?,? goal number(?: [\S]+)?(?: for)?(?: season)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)[;,](?: \([a-z]+ GOAL\)| \(MAN-UP\)| \(MAN-DOWN\)| \(FPGOAL\)(?: \(?free position shot\)?)? \([a-z]+ GOAL\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?: \(?free position shot\)?)?| \(man-down\))?(?:,? goal number(?: [\S]+)?(?: for)?(?: season)?)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': .98, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)[;,] \(MAN-UP\) \(FPGOAL\)(?: \(?free position shot\)?)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1.2, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)[;,](?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\) \(man-down\))? \([a-z]+ GOAL\)(?:,? goal number(?: [\S]+)?(?: for)?(?: season)?)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str':'(?:2\-point )?Goal by ([tp]+) (.+?) \([a-z]+ GOAL\) \(30-Second Timer\), goal number [0-9]+ for season\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 2, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\s\(?free position shot\)?)?| \(man-down\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\sfree position shot)?| \(man-down\))?,? Assist by (.*?)(?:[;,] goal number(?: [\S]+)?(?: for)?(?: season)?)\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Assist", 'p1_team': 0, 'p2_team' : 0})
    classifiers.append({'wght': 2.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\s\(?free position shot\)?)?| \(man-down\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\sfree position shot)?| \(man-down\))?(?: \(free position shot\)),? Assist by (.*?)(?:, goal number(?: [\S]+)?(?: for)?(?: season)?)\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Assist", 'p1_team': 0, 'p2_team' : 0})
    classifiers.append({'wght': 2, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\s\(?free position shot\)?)?| \(man-down\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\s\(?free position shot\)?)?| \(man-down\))?,? Assist by (.+)\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Assist", 'p1_team': 0, 'p2_team' : 0})
    classifiers.append({'wght': 2.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\s\(?free position shot\)?)?| \(man-down\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\)(?:\s\(?free position shot\)?)?| \(man-down\))?,? Assist by (.*?)(?:\s\(?free position shot\)?)\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Assist", 'p1_team': 0, 'p2_team' : 0})
    classifiers.append({'wght': 2.09, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\) \(man-down\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\) \(man-down\))?,? Assist by (.*?)(?: and [a-z-\s,]+?)(?:, goal number(?: [\S]+)?(?: for)?(?: season)?)?\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Assist", 'p1_team': 0, 'p2_team' : 0})
    classifiers.append({'wght': 2.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?) \([a-z]+ GOAL\)(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \(Man-up\)| \(FPGOAL\) \(man-down\))?,? Assist by (.*?)(?:, goal number(?: [\S]+)?(?: for)?(?: season)?)?\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Assist", 'p1_team': "", 'p2_team': ""})
    classifiers.append({'wght': 2.2, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)(?: \(MAN-UP\))? \(FIRST GOAL\), Assist by (.*?)(?:, goal number(?: [\S]+)?(?: for)?(?: season)?)?\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Assist", 'p1_team': "", 'p2_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.*?)(?: \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-down\)| \(FPGOAL\) \(man-down\))?(?: \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(MAN-(?:DOWN|UP)\) \(FPGOAL\)| \(FPGOAL\)| \(FPGOAL\) \(man-down\))?(?: \(Shot Timer\)| \(30-Second Timer\)| \([a-z]+ GOAL\)| \(Man-down\)| \(Man-up\)| \(FPGOAL\) \(man-down\)| \(MAN-(?:DOWN|UP)\) \(FPGOAL\)| \(FPGOAL\) \(free[\s\-]position[\s\-]shot\))?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?Goal by ([tp]+) (.+?),?(?: \([a-z]+ GOAL\))?(?: \(30-Second Count\)| \(30-Second Timer\)| \(Shot Timer\)| \([a-z]+ GOAL\)| \(Man-up\)| \(FPGOAL\) \(FPGOAL\)| \(man-down\))?,? goal number(?: [\S]+)?(?: for)?(?: season)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})


    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Ground ball pickup by ([tp]+),? (.+)\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Ground ball pickup by ([tp]+)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Turnover by ([tp]+)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1.2, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Turnover by ([tp]+) (.*?),? \((?:forced|caused) by (.*?)(?: interception| blocked pass| drawn charge| stick check)?\)\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Forced a Turnover", 'p1_team': "", 'p2_team': "other"})
    classifiers.append({'wght': 1.2, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Turnover by ([tp]+),? \(caused by (.*?),?(?: interception| blocked pass| drawn charge| stick check)?\)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': "other"})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Turnover by ([tp]+) (.+)\.', 'p_group': 1, 'p_play': "ptype", 'p_team': 0})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Turnover by ([tp]+) (.*?),? \((?:forced|caused) by (.*?)\)\.', 'p1_group': 1, 'p1_play': "ptype", 'p2_group': 2, 'p2_play': "Forced a Turnover", 'p1_team': 0, 'p2_team': "other"})

    
    
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Bench misconduct (?:on|by) ([tp]+).*?\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:Red|Green|Yellow|Blue) card (?:on|by) ([tp]+).*?\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:Red|Green|Yellow|Blue) card \([a-z\s\-/0-9]+/?[0-9:]+\)\ (?:on|by) ([tp]+) (.+?)\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Penalty (?:on|by)\s+([tp]+),? (.*?) \([a-z\s\-/\`]+/?[0-9:]+\) Extra-man opportunity(\([0-9]+\))?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': .9, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Penalty (?:on|by) (.*?) \([a-z\s\-/0-9]+/?[0-9:]+\)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Penalty (?:on|by) ([tp]+),? (.*?) \([a-z\s\-/0-9]+/?[0-9:]+\)\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Penalty (?:on|by) ([tp]+),? (.*?) \([0-9:]+/?[0-9:]+\)(?: Extra-man opportunity(\([0-9]+\))?)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Penalty (?:on|by) ([tp]+),? (.*?) \([0-9:]+/?[0-9:]+\)(?: Extra-man)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Penalty (?:on|by) ([tp]+),? (.*?) \([a-z\s\-/0-9]+/?[0-9:]+\) (?:Power-play|Extra-man)(?: opportunity)?\.', 'p_group': 1, 'p_play': "ptype", 'p_team': ""})

    classifiers.append({'wght': .8,   'ID': "Regex#%d" % (len(classifiers)), 'regex_str': '(?:2\-point )?\(?Free position attempt\)? (?:by|for) ([tp]+)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': 0})

    classifiers.append({'wght': 1.2, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Faceoff TEAM vs(?: TEAM)? won by ([tp]+)( \(on faceoff violation\))?\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Faceoff (.*?) vs (.*?) won by ([tp]+)(?:\s?[\[0-9:\]]+\s?)?( \(on faceoff violation\))?\.', 'p1_group': 0, 'p1_play': "", 'p2_group': 1, 'p2_play': "", 'p3_group': 2, 'p3_play': "ptype", 'p1_team': "???", 'p2_team': "???", 'p3_team': "???"})
    classifiers.append({'wght': 1.11, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Faceoff (.*?) vs (.*?) won by ([tp]+),? (?:\s*?[\[0-9:\]]+\s?)?Ground(?: ball)?(?: pickup)? by ([tp]+)? (.+?)(?: \(on faceoff violation\))?\.', 'p1_group': 0, 'p1_play': "", 'p2_group': 1, 'p2_play': "", 'p3_group': 4, 'p3_play': "Ground Ball", 'p1_team': "???", 'p2_team': "???", 'p3_team': 3})
    
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Faceoff (.*?) vs (.*?) won by ([tp]+),? (?:\s*?[\[0-9:\]]+\s?)?Draw Control by ([tp]+)? (.+)\.', 'print': False, 'p1_group': 0, 'p1_play': "", 'p2_group': 1, 'p2_play': "", 'p3_group': 4, 'p3_play': "Ground Ball", 'p1_team': "???", 'p2_team': "???", 'p3_team': 3})
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Faceoff (.*?) vs (.*?) won by ([tp]+),? (?:\s*?[\[0-9:\]]+\s?)?Draw Control by ([tp]+)?\.', 'p1_group': 0, 'p1_play': "", 'p2_group': 1, 'p2_play': "", 'p1_team': "???", 'p2_team': "???"})
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'print': False, 'regex_str': 'Faceoff (.*?) vs (.*?) won by ([tp]+)(?:\s?[\[0-9:\]]+\s?)?( \(on faceoff violation\))?,? Draw Control by ([tp]+)? (.+)\.', 'p1_group': 0, 'p1_play': "", 'p2_group': 1, 'p2_play': "", 'p3_group': 2, 'p3_play': "ptype", 'p1_team': "???", 'p2_team': "???", 'p3_team': "???"})
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'print': False, 'regex_str': 'Draw Control by ([tp]+)? (.+)\.', 'p1_group': 1, 'p1_play': "Ground Ball", 'p1_team': 0})
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'print': False, 'regex_str': 'Draw Control by ([tp]+)\.', 'p_group': 0, 'p_play': "ptype", 'p_team': ""})
    classifiers.append({'wght': 1.2, 'ID': "Regex#%d" % (len(classifiers)), 'print': False, 'regex_str': 'Draw Control by ([tp]+)? (.+), Ground ball pickup by .*?\.', 'p1_group': 1, 'p1_play': "Ground Ball", 'p1_team': 0})
    
    classifiers.append({'wght': 1.1, 'ID': "Regex#%d" % (len(classifiers)), 'regex_str': 'Faceoff (.*?) vs (.*?) won by ([tp]+),? (?:\s*?[\[0-9:\]]+\s?)?Ground(?: ball)?(?: pickup)?(?: by)? ([tp]+)? (.+)\.', 'p1_group': 0, 'p1_play': "", 'p2_group': 1, 'p2_play': "", 'p3_group': 4, 'p3_play': "Ground Ball", 'p1_team': "???", 'p2_team': "???", 'p3_team': 3})
    
    for c in classifiers:
        c['regex_str'] = c['regex_str'].replace("[tp]", "[%s]" % team_pattern)
        c['regex'] = re.compile(c['regex_str'], re.IGNORECASE)

    classifiers = sorted(classifiers, key=lambda x:x['wght'], reverse=True)
    
    steps.append({'step': 'Set up classifiers', 'time': time.time()})
    game_json_path = os.path.join(lr_fldr, "Logs", "GameJSONs", "%d.json"% game_ID) if game_ID not in [None, -1, ''] else None
    
    
    if '--refresh-game-dict' not in sys.argv and game_json_path is not None and os.path.isfile(game_json_path):
        g = json.loads(open(game_json_path, 'r').read())
        g['detail']['date'] = datetime.strptime(g['detail']['date'], "%m-%d-%Y %H:%M:%S")
        g['from_file'] = True
        g['success'] = 1

    else:
        timestamps = {'start': time.time()}
        global to_screen_val


        manual_player_teams = [
        {'year': 2017, 'player': 'GAGE BRADSHAW', 'team': 'RU'}
        , {'year': 2017, 'player': 'BRANDON BAILEY', 'team': 'SBU'}
        , {'year': 2017, 'player': 'MALCOLM FEENEY', 'team': 'COLGATE'}
        , {'year': 2015, 'player': 'ANDREW BURNETT', 'team': 'SHU'}
        , {'year': 2015, 'player': 'JONATHAN MARINELLI', 'team': 'DART'}
        , {'year': 2017, 'player': 'TEDDY HENDERSON', 'team': 'DU'}
        , {'year': 2016, 'player': 'TYLER PANTALONE', 'team': 'SIE'}
        , {'year': 2016, 'player': 'LUC LEBLANC', 'team': 'VERMONT'}
        , {'year': 2016, 'player': 'HUNTER SANNA', 'team': 'SIE'}
        , {'year': 2020, 'player': 'JIMMEH KOITA', 'team': 'DREX', 'confirmed_team': 'Drexel'}
        , {'year': 2020, 'player': 'JUSTIN COPPOLA', 'team': 'NOVA', 'confirmed_team': 'Villanova'}
        , {'year': 2020, 'player': 'ADRIAN ENCHILL', 'team': 'BRWN', 'confirmed_team': 'Brown'}
        , {'year': 2020, 'player': 'TYLER SANDOVAL', 'team': 'PRIN', 'confirmed_team': 'Princeton'}
        , {'year': 2020, 'player': 'ZACK HOCHMAN', 'team': 'MASS', 'confirmed_team': 'Massachusetts'}
        , {'year': 2020, 'player': 'MITCHELL MYERS', 'team': 'DART', 'confirmed_team': 'Dartmouth'}
        , {'year': 2020, 'player': 'JT SIMONTON', 'team': 'BELL', 'confirmed_team': 'Bellarmine'}
        , {'year': 2020, 'player': 'DANNY TESLER', 'team': 'CSU', 'confirmed_team': 'Cleveland State'}
        , {'year': 2020, 'player': 'JACK ALMOND', 'team': 'STB', 'confirmed_team': 'St. Bonaventure'}
        , {'year': 2020, 'player': 'NICK BARRY', 'team': 'NAVY', 'confirmed_team': 'NAVY'}
        , {'year': 2020, 'player': 'BRENDAN HIGGINS', 'team': 'WAG', 'confirmed_team': 'Wagner'}
        , {'year': 2020, 'player': 'KRIS CASEY', 'team': 'FUR', 'confirmed_team': 'Furman'}
        , {'year': 2020, 'player': 'ALEX POMA', 'team': 'UMBC', 'confirmed_team': 'UMBC'}
        , {'year': 2020, 'player': 'JACOB GRIFFIN', 'team': 'RICH', 'confirmed_team': 'Richmond'}
        , {'year': 2020, 'player': 'JASON ZOU', 'team': 'SIE', 'confirmed_team': 'Siena'}
        , {'year': 2020, 'player': 'ANDREW MOYNIHAN', 'team': 'HFD', 'confirmed_team': 'Hartford'}
        , {'year': 2020, 'player': 'CONOR GAFFNEY', 'team': 'LEH', 'confirmed_team': 'Lehigh'}
        , {'year': 2020, 'player': 'MORGAN BATES', 'team': 'CIN', 'confirmed_team': 'Cincinnati'}
        , {'year': 2020, 'player': 'JAKOB PHAUP', 'team': 'SYR', 'confirmed_team': 'Syracuse'}
        , {'year': 2020, 'player': 'ANGELO PETRAKIS', 'team': 'COR', 'confirmed_team': 'Cornell'}
        , {'year': 2020, 'player': 'RENZ CONLON', 'team': 'STONY', 'confirmed_team': 'Stony Brook'}
        , {'year': 2020, 'player': 'TOMMY BURKE', 'team': 'UVM', 'confirmed_team': 'Vermont'}
        , {'year': 2020, 'player': 'BRANDON RIZZUTO', 'team': 'BING', 'confirmed_team': 'Binghamton'}
        , {'year': 2020, 'player': 'CHARLES LEONARD', 'team': 'ND', 'confirmed_team': 'Notre Dame'}
        , {'year': 2020, 'player': 'JAKE GIAQUINTO', 'team': 'SAC', 'confirmed_team': 'Sacred Heart'}
        , {'year': 2020, 'player': 'MITCH ROTHSTEIN', 'team': 'CORCRO1', 'confirmed_team': 'Cornell'}
        , {'year': 2020, 'player': 'ANDREW ALBERTSON', 'team': 'HPUM', 'confirmed_team': 'High Point'}
        , {'year': 2020, 'player': 'TURNER LOCKYEAR', 'team': 'BELL', 'confirmed_team': 'Bellarmine'}
        , {'year': 2020, 'player': 'ADAM SHANK', 'team': 'SBUM', 'confirmed_team': 'St. Bonaventure'}
        , {'year': 2020, 'player': 'IAN WEINBERG', 'team': 'MON', 'confirmed_team': 'Monmouth'}
        , {'year': 2020, 'player': 'NICHOLAS VASQUEZ', 'team': 'HARTFORD', 'confirmed_team': 'Hartford'}
        , {'year': 2020, 'player': 'DANIEL RODRIGUEZ', 'team': 'SHU', 'confirmed_team': 'Sacred Heart'}
        , {'year': 2020, 'player': 'SHANE CALDERWOOD', 'team': 'HOF', 'confirmed_team': 'Hofstra'}
        , {'year': 2016, 'player': 'SEAN SEABERG', 'team': 'SBU'}
        , {'year': 2016, 'player': 'BEN WILLIAMS', 'team': 'SU'}
        , {'year': 2016, 'player': 'BEN GJOKAJ', 'team': 'DETROIT'}
        , {'year': 2014, 'player': 'JONATHAN REESE', 'team': 'YALE'}
        , {'year': 2014, 'player': 'BEN GJOKAJ', 'team': 'DETROIT'}
        , {'year': 2013, 'player': 'BEN GJOKAJ', 'team': 'DETROIT'}
        , {'year': 2013, 'player': 'FRANCIS WHEELER-LARU', 'team': 'HARTFORD'}
        , {'year': 2013, 'player': 'CARLOS HARGETT', 'team': 'NAVY'}
        , {'year': 2015, 'player': 'BEN GJOKAJ', 'team': 'DETROIT'}
        , {'year': 2015, 'player': 'KEVIN WYLIE', 'team': 'MICH'}
        , {'year': 2016, 'player': 'TYLER MARDIAN', 'team': 'DELAWARE'}
        , {'year': 2016, 'player': 'DANNY MANNING', 'team': 'SJU'}
        , {'year': 2016, 'player': 'Noah Rak', 'confirmed_team': 'Massachusetts', 'team': 'UMASS'}
        , {'year': 2016, 'player': 'Alex Daly', 'confirmed_team': 'Army', 'team': 'ARMY'}
        , {'year': 2014, 'player': 'JOSH REINSON', 'team': 'MD'}
        , {'year': 2014, 'player': 'WILL BIAGI', 'team': 'MICH'}
        , {'year': 2014, 'player': 'MICHAEL TSIANG', 'team': 'VU'}
        , {'year': 2018, 'player': 'GARRETT SMITH', 'team': 'RICH'}
        , {'year': 2019, 'player': 'JACOB FRANE', 'team': 'ND'}
        , {'year': 2013, 'player': 'Vinny Colatriano', 'confirmed_team': "Hofstra", 'team': 'HOFSTRA'}
        , {'year': 2013, 'player': 'Phil Hession', 'confirmed_team': "Dartmouth", 'team': 'DART'}
        , {'year': 2019, 'player': 'Fernando Robinson', 'confirmed_team': "Detroit", 'team': 'DETMERCY'}
        , {'year': 2019, 'player': 'Shawn Raum', 'confirmed_team': 'mount st marys', 'team': 'MOUNT'}
        , {'year': 2019, 'player': 'Mike Loscalzo', 'confirmed_team': 'navy', 'team': 'NAVY'}
        , {'year': 2019, 'player': 'Colin McCarthy', 'confirmed_team': 'loyola md', 'team': 'LOYOLA'}
        , {'year': 2019, 'player': 'Cade Heverly', 'confirmed_team': 'georgetown', 'team': 'GU'}
        , {'year': 2019, 'player': 'Rory McElligatt', 'confirmed_team': 'Furman', 'team': 'Furman'}
        , {'year': 2018, 'player': 'Rory McElligatt', 'confirmed_team': 'Furman', 'team': 'Furman'}
        , {'year': 2019, 'player': 'Jacob Griffin', 'confirmed_team': 'Richmond', 'team': 'UR'}
        , {'year': 2019, 'player': 'Alex Giovinco', 'confirmed_team': 'Jacksonville', 'team': 'JU'}

        ]

        if '--use-manual-players' not in sys.argv: manual_player_teams = []


        to_screen_val = to_screen
        if '-debug' in sys.argv: to_screen=True
        #print_stuff("Create game_dict for game ID: %d" % game_ID)
        # Set up parameters
        window_length = 60
        sections= 60
        last_elapsed = 0
        consec = 0


        fp_type_counts = [{'type': z, 'cnt': 0.} for z in [1, 2, 3, 4, 5, 6, None]]
        fp_type_counts[0]['desc'] = "NO SHOTS"
        fp_type_counts[1]['desc'] = "SINGLE MATCH"
        fp_type_counts[2]['desc'] = "No Matches"
        fp_type_counts[3]['desc'] = "Too many matches"
        fp_type_counts[4]['desc'] = "SHOT OFF 1 PASS"
        fp_type_counts[5]['desc'] = "GOAL OFF 1 PASS"
        fp_type_counts[6]['desc'] = "Fail"

        # Set up log file
        penalty_out_of_order = 0
        f = None#open(os.path.join(settings['topFolder'], settings['folder'], "Game %03d" % game_ID), 'w')
        
        game_status = None
        home_starting_elo_rank = None
        away_starting_elo_rank = None
        home_ending_elo_rank = None
        away_ending_elo_rank = None
        steps.append({'step': 'Set up vars', 'time': time.time()})
        alt_home_team = None
        alt_away_team = None
        home_team_name = None
        away_team_name = None
        replacement_text = None
        log_url = None
        # Pull data for this game from the database
        if cursor is None and "db" in settings:
            cursor = zc.zcursor(settings['db'])
        if game_ID is not None:

            if 'db_game_obj' in settings:
                #print ("\n\n db_game_obj")
                #zc.print_dict(settings['db_game_obj']); input("DB")
                game_date = settings['db_game_obj']['game_date']
                confirmed_home_team = settings['db_game_obj']['confirmed_home_team']
                confirmed_away_team = settings['db_game_obj']['confirmed_away_team']
                log_url = settings['db_game_obj']['log_url']
                alt_away_team = settings['db_game_obj']['alt_away_team']
                alt_home_team = settings['db_game_obj']['alt_home_team']
                home_ID = settings['db_game_obj']['home_ID']
                away_ID = settings['db_game_obj']['away_ID']
                home_team_name = settings['db_game_obj']['home_team']
                away_team_name = settings['db_game_obj']['away_team']
                league_tag = settings['db_game_obj']['league'].replace("NCAA ", "").lower().replace(" Men", "m").replace(" Women", "w")
                pregame_home_wp = settings['db_game_obj']['pregame_home_wp']
                home_win_odds = pregame_home_wp
                home_elo = settings['db_game_obj']['home_elo']
                away_elo = settings['db_game_obj']['away_elo']
                home_elo_transfer = settings['db_game_obj']['elo_transfer'] if settings['db_game_obj']['home_score'] > settings['db_game_obj']['away_score'] else (-1.0*settings['db_game_obj']['elo_transfer'])
                replacement_text = []
                game_status = settings['db_game_obj']['status']
                
                if settings['db_game_obj']['replacement_text'] is not None:
                    replacement_text = [{'from': z.split("|")[0], 'to': z.split("|")[1]} for z in settings['db_game_obj']['replacement_text'].split("~~~") if len(z.split("|")) == 2]
                
                league = settings['db_game_obj']['league']
            else:
                query = "Select ID, confirmed_away_team, confirmed_home_team, away_score, home_score, log_url, alt_away_team, away_team, alt_home_team, home_team, game_date, home_ID, away_ID, league, pregame_home_wp, home_elo, away_elo, CASE WHEN home_score > away_score THEN elo_transfer ELSE -1*elo_transfer END home_elo_transfer, replacement_text, status from LaxRef_Games where status like 'complete%%' and ID=%s and active=1"
                param = [game_ID]
                print ("Query %s w/ %s" % (query, param))
                cursor.execute(query, param)
                game_res = cursor.fetchone()
                if game_res is None:
                    msg = "In laxref.create_game_dict, there is no active game record associated with ID=%d.\n\nThis is a fatal error and we are going to exit." % game_ID
                    msg += "\n\n%s" % get_game_crash_info(game_ID)
                    msg += "\n\nIf it looks like there is a valid pxp, you can try and update the record using the below command:\n\npython get_official_ncaa_game_data.py --game-ID {} -manual --replace-plays -u \"\"".format(game_ID)
                        
                    msg += "\n\nsys.argv: %s" % (" ".join(sys.argv))
                    print (msg)
                    zc.send_crash(msg, bot_token)
                    zc.exit("No Game Record")
                game_date = game_res[10]
                confirmed_home_team = game_res[2]
                confirmed_away_team = game_res[1]
                log_url = game_res[5]
                alt_away_team = game_res[6]
                alt_home_team = game_res[8]
                home_ID = game_res[11]
                away_ID = game_res[12]
                home_team_name = game_res[9]#.replace("(M~1", "M")
                away_team_name = game_res[7]#.replace("(M~1", "M")
                league_tag = "d1m" if game_res[13] == "NCAA D1 Men" else "d1w"
                pregame_home_wp = game_res[14]
                home_win_odds = game_res[14]
                home_elo = game_res[15]
                away_elo = game_res[16]
                home_elo_transfer = game_res[17]
                replacement_text = []
                game_status = game_res[19]
                
                if game_res[18] is not None:
                    replacement_text = [{'from': z.split("|")[0], 'to': z.split("|")[1]} for z in game_res[18].split("~~~") if len(z.split("|")) == 2]
                
                league = game_res[13]
            steps.append({'step': 'Query Games table', 'time': time.time()})
            LRP_json_fname = "game%07d_LRP.json" % game_ID
        else:
            game_date = settings['game_date']
            confirmed_home_team = settings['confirmed_home_team']
            confirmed_away_team = settings['confirmed_away_team']
            home_ID = settings['home_ID']
            away_ID = settings['away_ID']
            home_elo = settings['home_elo']
            away_elo = settings['away_elo']
            home_win_odds = settings['pregame_home_wp']
            home_elo_transfer = 0.
            home_team_name = settings['home_team']#.replace("(M~1", "M")
            away_team_name = settings['away_team']#.replace("(M~1", "M")
            league_tag = settings['league_obj']['tag']
            league = settings['league_obj']['name']
            pregame_home_wp = settings['pregame_home_wp']
            
            steps.append({'step': 'Load game data from settings', 'time': time.time()})
            LRP_json_fname = "game%07d_LRP.json" % settings['ID']
        #LRP_json_path = os.path.join(lr_fldr, "Logs", "LRPGameJSONs", league.replace(" ", ""), "%d" % game_date.year, LRP_json_fname)
        LRP_json_path = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GameData", LRP_json_fname)
        
        recreate_game_dict = 0
        if os.path.isfile(LRP_json_path) and '--overwrite-LRP-json' not in sys.argv:
            tmp_data = open(LRP_json_path, 'r').read()
            if len(tmp_data) == 0:
                recreate_game_dict = 1
            else:
                try:
                
                    LRP_json = json.loads(tmp_data)
                    print ("Game Status: %s" % game_status)
                    if game_status == "completedFromNCAA":
                        LRP_json['rapid'] = 0
                    
                except Exception:
                    
                    msg = "In laxref.create_game_dict, the LRP JSON file at %s was not empty, but it could not be converted to a JSON object. Try re-running this script with the --overwrite-LRP-json flag set." % LRP_json_path
                    print (msg)
                    if EXPORT_ERRORS:
                        errors.append({'type': 'LRP JSON file was corrupted', 'code': 2, 'text': msg})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(msg, bot_token)
                        return None
        else:
            recreate_game_dict = 1
            
            
        if recreate_game_dict:
            LRP_json = {'results': {'TopStars': None
            , 'BasicSummaryCounting': None
            , 'ExcessShooting': None
            , 'ExcessSaves': None
            , 'FOGOBattle': None
            , 'QuarterBreakdown': None
            , 'SituationalSplits': None
            , 'WinProbabilityChart': None
            , 'team_summary_stats': None
            , 'TeamComparisononRateStats': None
            , 'SplitsbyPossessionType': None
            , 'SplitsbyPossessionLength': None
            , 'RawvsAdjustedInformation': None
            , 'PreviewvsActuals': None
            , 'PositionalBreakdownvsAvg': None
            , 'PlayerTrends': None
            , 'KeyStretches': None
            , 'PostSeasonImplications': None}
            , 'preview': {}}


            
        """
        There doesn't seem to be any reason to query all of this stored DB data when we are calling this function as part of live_win_odds.py processing. The exception could be the alternate player names (which could be loaded within settings like we are doing for play values), test it out and if you don't see any data quality issues, you'll probably cut the live win odds parse time by 80%.  
        """
        if game_ID is not None:
            db_queries_run = 0
            # Only run these queries if we are post-processing a completed game (as opposed to processing a live win odds game)
            

            db_existing_players = None
            db_existing_player_seasons = None
            db_existing_shots = None
            db_existing_faceoffs = None
            db_existing_possessions = None
            db_existing_stretches = None
            db_existing_players_list = None
            db_existing_man_up = None
            db_players = None
            db_alternate_player_names = None
            if '--skip-db-processing' not in sys.argv:
                if show_cgd_timedstamps:
                    print("     {:<95}{:<15}".format("Start create_game_dict queries...", datetime.now().strftime("%H:%M:%S")));
            
                if 'db_alternate_player_names' in settings:
                    db_alternate_player_names = settings['db_alternate_player_names']
                else:
                    db_tmp_src = os.path.join(lr_fldr, "Logs", "db_alternate_player_names.json")
                    if datetime.now().year == 2022 and datetime.now().minute not in [0, 20, 40] and os.path.isfile(db_tmp_src):
                        if show_cgd_timedstamps:
                            print("          {:<90}{:<15}".format("File %d  (LaxRef_Alternate_Player_Names)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
                        db_alternate_player_names = json.loads(open(db_tmp_src, 'r').read())
                    else:
                        if show_cgd_timedstamps:
                            print("          {:<90}{:<15}".format("Query %d (LaxRef_Alternate_Player_Names)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); 
                        cursor.execute("SELECT player_ID, alternate_name, actual_name, team_ID from LaxRef_Alternate_Player_Names where active", [])
                        db_alternate_player_names = zc.dict_query_results(cursor)
                        if datetime.now().minute in [0, 20, 40] and datetime.now().year == 2022:
                            f = open(os.path.join(lr_fldr, "Logs", "db_alternate_player_names.json"), 'w')
                            f.write(json.dumps(db_alternate_player_names))
                            f.close()
                    db_queries_run += 1
                    
                for p in db_alternate_player_names:
                    p['alternate_cleaned'] = hash_player_name(p['alternate_name'])
                
                
                if 'db_existing_players' in settings:
                    db_existing_players = settings['db_existing_players']
                else:
                    print("          {:<90}{:<15}".format("Query %d (LaxRef_Players)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); db_queries_run += 1
                    cursor.execute("SELECT ID, player from LaxRef_Players where active", [])
                    db_existing_players = zc.dict_query_results(cursor)

                if 'db_existing_player_seasons' in settings:
                    db_existing_player_seasons = [z for z in settings['db_existing_player_seasons'] if z['team_ID'] in [home_ID, away_ID]]
                else:
                    print("          {:<90}{:<15}".format("Query %d (LaxRef_Player_Seasons)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); db_queries_run += 1
                    cursor.execute("SELECT ID, player_ID, team_ID, year from LaxRef_Player_Seasons where active", [])
                    db_existing_player_seasons = zc.dict_query_results(cursor)

                cursor.execute("SELECT IFNULL(max(ID),0)+1 next_shot_ID from LaxRef_Shots", [])
                next_shot_ID = zc.dict_query_results(cursor)[0]['next_shot_ID']
                if 'db_existing_shots' in settings:
                    db_existing_shots = [z for z in settings['db_existing_shots'] if z['team_ID'] in [home_ID, away_ID]]
                else:
                    print("          {:<90}{:<15}".format("Query %d (LaxRef_Shots)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); db_queries_run += 1

                    if '--upload-to-LRP' in sys.argv: # This is needed because this is going to result in the LRP JSON being uploaded, so all data is needed
                        cursor.execute("SELECT ID, team_ID, game_ID, possession_seq, goal, on_keeper, shooter_ID, goalie_ID, assister_ID, time_elapsed, game_state from LaxRef_Shots where active=1 and (team_ID=%s or team_ID=%s)", [home_ID,away_ID])
                    else:
                        cursor.execute("SELECT ID, team_ID, game_ID, possession_seq, time_elapsed, game_state from LaxRef_Shots where active=1 and (team_ID=%s or team_ID=%s)", [home_ID,away_ID])

                    db_existing_shots = zc.dict_query_results(cursor)
            
                cursor.execute("SELECT IFNULL(max(ID),0)+1 next_faceoff_ID from LaxRef_Faceoffs", [])
                next_faceoff_ID = zc.dict_query_results(cursor)[0]['next_faceoff_ID']
                if 'db_existing_faceoffs' in settings:
                    db_existing_faceoffs = [z for z in settings['db_existing_faceoffs'] if z['team_ID'] in [home_ID, away_ID]]
                else:
                    print("          {:<90}{:<15}".format("Query %d (LaxRef_Faceoffs)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); db_queries_run += 1
                    cursor.execute("SELECT ID, team_ID, opp_team_ID, game_ID, game_state, possession_ID, winner_ID, loser_ID, picked_up_by_ID, time_elapsed from LaxRef_Faceoffs where active=1 and (team_ID=%s or team_ID=%s)", [home_ID,away_ID])
                    db_existing_faceoffs = zc.dict_query_results(cursor)

                if 'db_existing_possessions' in settings:
                    db_existing_possessions = [z for z in settings['db_existing_possessions'] if z['team_ID'] in [home_ID, away_ID]]
                else:
                    print("          {:<90}{:<15}".format("Query %d (LaxRef_Possessions)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); db_queries_run += 1
                    if '--upload-to-LRP' in sys.argv: # This is needed because this is going to result in the LRP JSON being uploaded, so all data is needed
                        query = "SELECT ID, team_ID, game_ID, sequence, turnover, num_shots, shots_on_goal, started_with, before_shot, start_time, goal, duration, team_odds from LaxRef_Possessions where active=1 and (team_ID=%s or team_ID=%s)"
                        param = [home_ID,away_ID]
                        #print ("Query %s w/ %s" % (query, param))
                        cursor.execute(query, param)
                    
                    else:
                        cursor.execute("SELECT ID, team_ID, game_ID, sequence, start_time from LaxRef_Possessions where active=1 and (team_ID=%s or team_ID=%s)", [home_ID,away_ID])
                    db_existing_possessions = zc.dict_query_results(cursor)
                    
                    if '--upload-to-LRP' in sys.argv: # This is needed because this is going to result in the LRP JSON being uploaded, so all data is needed
                        for p in db_existing_possessions:
                            p['quarter'] = int(min(3599., p['start_time'])/900.)
                            p['adj_before_shot'] = None if p['before_shot'] is None else min(79, p['before_shot'])
                            p['adj_duration'] = min(79, p['duration'])
        
                if 'db_existing_stretches' in settings:
                    db_existing_stretches = [z for z in settings['db_existing_stretches'] if z['team_ID'] in [home_ID, away_ID]]
                else:
                    print("          {:<90}{:<15}".format("Query %d (LaxRef_Game_Stretches)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); db_queries_run += 1
                    if 'player_game_analyzer.py' not in sys.argv or '--skip-player-and-career-update-queries' not in sys.argv:
                        if '--upload-to-LRP' in sys.argv: # This is needed because this is going to result in the LRP JSON being uploaded, so all data is needed
                            query = "SELECT seq, team_ID, opp_ID, game_ID from LaxRef_Game_Stretches where active=1 and (team_ID=%s or team_ID=%s)"
                            param = [home_ID,away_ID]
                            #print ("Query %s w/ %s" % (query, param))
                            cursor.execute(query, param)
                        
                        else:
                            query = "SELECT seq, team_ID, opp_ID, game_ID from LaxRef_Game_Stretches where active=1 and (team_ID=%s or team_ID=%s)"
                            param = [home_ID,away_ID]
                            #print ("Query %s w/ %s" % (query, param))
                            cursor.execute(query, param)
                        db_existing_stretches = zc.dict_query_results(cursor)
                    else:
                        db_existing_stretches = []
                        
                    if '--upload-to-LRP' in sys.argv: # This is needed because this is going to result in the LRP JSON being uploaded, so all data is needed
                        for p in db_existing_stretches:
                            pass
                            
                
                src = os.path.join(lr_fldr, "LRP", "LRP_flask", "LocalDocs", "GeneralData", "dbLaxRef_Players.json")
                db_players = []
                if os.path.isfile(src):
                    tmp_data = json.loads(open(src, 'r').read())
                    for p in tmp_data['data']:
                        d = {'ID': p[tmp_data['keys'].index('ID')], 'player': p[tmp_data['keys'].index('player')], 'pro_url_tag': p[tmp_data['keys'].index('pro_url_tag')]}
                        d['player_hash'] = hash_player_name(p[tmp_data['keys'].index('player')])
                        db_players.append(d)
            
                cursor.execute("SELECT IFNULL(max(ID),0)+1 next_man_up_ID from LaxRef_Man_Up", [])
                next_man_up_ID = zc.dict_query_results(cursor)[0]['next_man_up_ID']
                if 'db_existing_man_up' in settings:
                    db_existing_man_up = [z for z in settings['db_existing_man_up'] if z['team_ID'] in [home_ID, away_ID]]
                else:
                    print("          {:<90}{:<15}".format("Query %d (LaxRef_Man_Up)" % (db_queries_run + 1), datetime.now().strftime("%H:%M:%S.%f")[0:-3])); db_queries_run += 1
                    cursor.execute("SELECT ID, game_ID, team_ID, sequence from LaxRef_Man_Up where active=1 and (team_ID=%s or team_ID=%s)", [home_ID,away_ID])
                    db_existing_man_up = zc.dict_query_results(cursor)

                
            
                n = 13
                
                if db_existing_players is not None:
                    db_existing_players_list = [[] for z in range(n)]
                    db_existing_player_seasons_list = [[] for z in range(n)]
                    for i in range(n):
                        db_existing_players_list[i] = [z for z in db_existing_players if max(min(12, int((ord(z['player'].upper()[0])-65)/2)), 0) == i]
                        db_existing_player_seasons_list[i] = [z for z in db_existing_player_seasons if z['player_ID'] % n == i]
                
                steps.append({'step': 'Query shots/possession/etc event tables', 'time': time.time()})
                print("     {:<95}{:<15}".format("Done create_game_dict queries...", datetime.now().strftime("%H:%M:%S")));
            
        
        if 'plays' in settings and 'use_one_time_play_values' in settings and settings['use_one_time_play_values']:
            plays = settings['plays']
            play_values_for = settings['play_values_for']
            play_values_against = settings['play_values_against']
            print("     {:<95}{:<15}".format("Collected play values (from settings)...", datetime.now().strftime("%H:%M:%S")));    
        else:
            plays, play_values_for, play_values_against = load_play_values_data(league, league_tag, window_length, None if 'all_leagues_db_play_values' not in settings else settings['all_leagues_db_play_values'])
            if 'all_leagues_db_play_values' not in settings:
                print("     {:<95}{:<15}".format("Collected play values (from load_play_values_data db query)...", datetime.now().strftime("%H:%M:%S")))
            else:
                print("     {:<95}{:<15}".format("Collected play values (from load_play_values_data stored object)...", datetime.now().strftime("%H:%M:%S")));    
        
        processed = ['Missed Shot', 'Saved Shot', 'Pipe Shot', 'Blocked Shot', 'Unforced Turnover', 'Forced Turnover', 'Faceoff Win', 'Unassisted Goal', 'Assisted Goal', "Free Position Attempt"]
        ignore = ["Good Clear", 'Failed Clear', 'Timeout', 'Shot Clock On', 'Goalie Change']
        steps.append({'step': 'Load play values', 'time': time.time()})

        # The win odds (by section / score) can be stored in different variable names within settings; instead of assuming it's just one, check both
        tmp_db_win_odds = None
        if 'all_leagues_db_win_odds' in settings:
            tmp_db_win_odds = settings['all_leagues_db_win_odds']
        elif 'league_db_win_odds' in settings:
            tmp_db_win_odds = settings['league_db_win_odds']
        
        win_odds_ID, win_odds_data = load_win_odds_data(league, league_tag, window_length, sections, tmp_db_win_odds)
        print("     {:<95}{:<15}".format("done with load_win_odds_data...", datetime.now().strftime("%H:%M:%S")));    

        steps.append({'step': 'Load win odds data', 'time': time.time()})
        timestamps['Win odds for plays read in'] = time.time()
        if cursor is not None:
            query = "SELECT a.name, a.ID, a.display_name from LaxRef_Teams a, LaxRef_Team_Seasons b where b.year=%s and b.team_ID=a.ID and a.active and b.league like 'NCAA%%' and b.partial_member != 1"
            cursor.execute(query, [game_date.year])
            team_elos = get_all_team_elo_ratings(zc.dict_query_results(cursor), game_date.strftime("%Y-%m-%d"))
        game_obj = {}
        game_obj['split_pct'] = None
        game_obj['stretch_start_pct'] = None
        game_obj['stretch_end_pct'] = None
        game_obj['league'] = None
        game_obj['log_url'] = None
        game_obj['game_date'] = None

        # Query play data
        #print("     {:<95}{:<15}".format("Begin querying play data...", datetime.now().strftime("%H:%M:%S")));
            
        if game_ID is not None:
            query = "SELECT a.ID, a.game_ID, a.event_type, a.team, a.game_elapsed_minutes, 0, a.game_elapsed_seconds, 0, a.game_state, a.details, a.quarter, a.game_elapsed_minutes * 60 + a.game_elapsed_seconds time_elapsed, b.home_team, b.away_team, b.home_score, b.away_score, b.split_pct, b.stretch_start_pct, b.stretch_end_pct, b.league, b.log_url, b.game_date, b.home_elo, b.away_elo, a.seq from LaxRef_Events a, LaxRef_Games b where b.status like 'complete%%' and b.ID=a.game_ID and a.game_ID=%s and a.active and a.event_type != 'Substitution' order by a.game_elapsed_minutes asc, a.game_elapsed_seconds asc"
            param = [game_ID]
            #print ("Query %s w/ %s" % (query, param))
            cursor.execute(query, param)
            res2 = zc.dict_query_results(cursor)
            
            # If the seq values are set, sort by that, if not the query will sort by elapsed time (sorting by seq is preferred because then plays are processed in the order they were entered into the Play by play log).
            if len(res2) > 0:
                if res2[0]['seq'] is not None:
                    res2 = sorted(res2, key=lambda x:x['seq'])
                elif res2[0]['ID'] is not None:
                    res2 = sorted(res2, key=lambda x:x['ID'])
                    for ij, r in enumerate(res2):
                        r['seq'] = ij + 1
              
            for r in res2:
                r['detail'] = r['details']
            res = [l for l in res2]

            if len(res) > 0:
                game_obj['ID'] = game_ID
                game_obj['split_pct'] = res[0]['split_pct']
                game_obj['stretch_start_pct'] = res[0]['stretch_start_pct']
                game_obj['league'] = res[0]['league']
                game_obj['log_url'] = res[0]['log_url']
                game_obj['game_date'] = res[0]['game_date']
                game_obj['home_elo'] = res[0]['home_elo']
                game_obj['away_elo'] = res[0]['away_elo']
                game_obj['home_team'] = res[0]['home_team']
                game_obj['away_team'] = res[0]['away_team']
                settings['home_team'] = None if res[0]['home_team'] is None else res[0]['home_team'].strip()
                settings['away_team'] = None if res[0]['away_team'] is None else res[0]['away_team'].strip()

            else:
                msg = "Attempted a download of the LaxRef_Events for %d, but none were found. As a result, there is no game object to work off of and this script will fail...exiting." % game_ID
                msg += "\n\nLR Games: http://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%d" % (game_ID)
                msg += "\n\nLR Team Game Summaries: http://192.168.1.240:5000/laxref_query?table=LaxRef_Team_Game_Summaries&game_ID=%d" % (game_ID)
                msg += "\n\nLR Events: http://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%d" % (game_ID)
                query = "SELECT ID, log_url, league, game_date, confirmed_home_team, confirmed_away_team from LaxRef_Games where ID=%s"
                
                param = [game_ID]
                #print ("Query %s w/ %s" % (query, param))
                cursor.execute(query, param)
                tmp = zc.dict_query_results(cursor)
                if len(tmp) > 0:
                    tmp = tmp[0]
                    if tmp['log_url'] is not None:
                        msg += "\nIf the are zero/None, then you might try to re-pull the play by play data using this command:\npython get_official_ncaa_game_data.py --replace-plays -manual --game-ID %d -league \"%s\" -u \"%s\" \n" % (game_ID, tmp['league'], tmp['log_url'])
                    
                    else:
                        msg += "\nIf the are zero/None, then you might try to re-pull the play by play data using this command:\npython get_official_ncaa_game_data.py --replace-plays --game-ID %d -league \"%s\" -u [play by play link for the game] \n" % (game_ID, tmp['league'])
                      
                
                print (msg)
                zc.send_crash(msg, bot_token)
                zc.exit("NO GAME OBJECT")
            steps.append({'step': 'Query LaxRef_Events', 'time': time.time()})

        else:
            """
            0: a.ID
            1: a.game_ID:
            2: a.event_type
            3: a.team
            4: a.game_elapsed_minutes
            5: a.quarter_elapsed_minutes
            6: a.game_elapsed_seconds
            7: a.quarter_elapsed_seconds
            8: a.game_state
            9: a.details
            10: a.quarter
            11: a.game_elapsed_minutes * 60 + a.game_elapsed_seconds
            12: b.home_team
            13: b.away_team
            14: b.home_score
            15: b.away_score
            16: b.split_pct
            17: b.stretch_start_pct
            18: b.stretch_end_pct
            19: b.league
            """


            res2 = [{} for i in range(len(play_data)-1)]
            for i, p in enumerate(play_data[1:]):

                res2[i]['ID'] = i
                res2[i]['game_ID'] = None
                res2[i]['event_type'] = p[3]#.replace("(M~1", "M")
                res2[i]['team'] = p[5]
                elapsed_seconds_total = int(float(p[1])*3600.0)
                elapsed_minutes = int(elapsed_seconds_total / 60)
                elapsed_seconds = elapsed_seconds_total % 60
                res2[i]['game_elapsed_minutes'] = elapsed_minutes
                res2[i]['quarter_elapsed_minutes'] = elapsed_minutes % (15 if "Men" in league else 30)
                res2[i]['game_elapsed_seconds'] = elapsed_seconds
                res2[i]['quarter_elapsed_seconds'] = elapsed_seconds
                res2[i]['game_state'] = int(p[2])
                res2[i]['details'] = p[6].replace(";", ",")
                res2[i]['detail'] = p[6].replace(";", ",")
                res2[i]['seq'] = i + 1
      
                if "Men" in league:
                    res2[i]['quarter'] = int(1 + elapsed_seconds_total/900 + max(0, (elapsed_seconds_total-3600)/240))
                else:
                    res2[i]['quarter'] = int(1 + elapsed_seconds_total/1800 + max(0, (elapsed_seconds_total-3600)/300))

                res2[i]['time_elapsed'] = elapsed_seconds_total
                res2[i]['home_team'] = p[7]
                res2[i]['away_team'] = p[8]
                res2[i]['home_score'] = None
                res2[i]['away_score'] = None
                settings['home_team'] = p[7].strip()
                settings['away_team'] = p[8].strip()
                
            game_obj['league'] = league
            game_obj['game_date'] = game_date
            game_obj['home_team'] = settings['home_team']
            game_obj['away_team'] = settings['away_team']


            res = [z for z in res2 if z['event_type'] != 'Substitution']
            
            steps.append({'step': 'Load LaxRef_Events from settings', 'time': time.time()})

        #print("     {:<95}{:<15}".format("Done querying play data...", datetime.now().strftime("%H:%M:%S")));
            
        timestamps['Query for plays completed'] = time.time()
        play_ID = None
        
        shot_clock_duration = 80. if "Men" in game_obj['league'] else 90.
        reset_duration = 60.
        
        # Query lists from DB
        
        # Figure out pre-game odds
        if 'home_elo' in settings:
            home_elo = settings['home_elo']
            away_elo = settings['away_elo']
            ending_home_elo = None
            ending_away_elo = None
        else:

            if game_ID is not None:
                #print ("Game ID: %s" % game_ID)
                #home_elo = get_team_elo_rating(home_ID, game_date.strftime("%Y-%m-%d"))
                #away_elo = get_team_elo_rating(away_ID, game_date.strftime("%Y-%m-%d"))
                if home_elo_transfer is not None:
                    ending_home_elo = home_elo + home_elo_transfer
                    ending_away_elo = away_elo - home_elo_transfer
                else:
                    ending_home_elo = home_elo
                    ending_away_elo = away_elo
                    
                #home_elo_old = get_team_elo_rating(home_ID, game_date.strftime("%Y-%m-%d"))
                #away_elo_old = get_team_elo_rating(away_ID, game_date.strftime("%Y-%m-%d"))
                #ending_home_elo_old = get_team_elo_rating(home_ID, game_date.strftime("%Y-%m-%d"), False)
                #ending_away_elo_old = get_team_elo_rating(away_ID, game_date.strftime("%Y-%m-%d"), False)
                
                #print "{:<20}{} vs {}".format("Home Starting", home_elo, home_elo_old)
                #print "{:<20}{} vs {}".format("Away Starting", away_elo, away_elo_old)
                #print "{:<20}{} vs {}".format("Home Ending", ending_home_elo, ending_home_elo_old)
                #print "{:<20}{} vs {}".format("Away Ending", ending_away_elo, ending_away_elo_old)
                #zc.exit("ELO Comp")

                home_starting_elo_rank = len([1 for z in team_elos if z['starting_elo'] > home_elo]) + 1
                home_ending_elo_rank = len([1 for z in team_elos if z['ending_elo'] > ending_home_elo]) + 1
                away_starting_elo_rank = len([1 for z in team_elos if z['starting_elo'] > away_elo]) + 1
                away_ending_elo_rank = len([1 for z in team_elos if z['ending_elo'] > ending_away_elo]) + 1

                if game_date.year >= datetime.now().year:
                    team_conferences = get_team_conference(cursor)
                    if game_date.year <= 2023:
                        query = "SELECT name, conf_tournament_start_%d from LaxRef_Conferences" % game_date.year
                    else:
                        query = "SELECT b.name, a.conf_tournament_start conf_tournament_start_{} from LaxRef_Conference_Seasons a, LaxRef_Conferences b where b.ID=a.conference_ID and a.active and a.year={};".format(game_date.year, game_date.year)
                    cursor.execute(query)
                    conference_dates = cursor.fetchall()



                    conf_tournament = is_conference_tournament(confirmed_away_team, confirmed_home_team, game_date, team_conferences, conference_dates)
                    if conf_tournament or ('no_home' in settings and not settings['no_home']):
                        pass
                    else:
                        if not isinstance(home_elo, str):
                            print_stuff("Increase the win odds because it is not the conf tournament...")
                            home_elo += 46
            else:
                home_elo = 0
                away_elo = 0
                ending_home_elo = 0
                ending_away_elo = 0

                home_starting_elo_rank = 0
                home_ending_elo_rank = 0
                away_starting_elo_rank = 0
                away_ending_elo_rank = 0

        in_game_log = False; game_log_IDs = None; next_game_summary_ID = None
        steps.append({'step': 'Calc pre-game odds', 'time': time.time()})

        if cursor is not None:
            query = 'SELECT ID, data_type, team_ID, opp_team_ID, filter, filter_val from LaxRef_Team_Game_Summaries where active and game_ID=%s'; param = [game_ID]
            cursor.execute(query, param)
            tmp_res = zc.dict_query_results(cursor)
            if len(tmp_res) > 0:
                in_game_log = True
                game_log_IDs = tmp_res
                next_game_summary_ID = None
            else:
                query = "SELECT IFNULL(max(ID), 0)+1 'cnt' from LaxRef_Team_Game_Summaries"
                cursor.execute(query, [])
                next_game_summary_ID = zc.dict_query_results(cursor)[0]['cnt']

        if 'db' in settings:
            cursor.close()
        steps.append({'step': 'Query next game summary ID', 'time': time.time()})

        timestamps['ELO Lookups done'] = time.time()


        if "???" in [home_elo, away_elo]:
            
            msg = "In laxref.create_game_dict, Elo information is missing for %s vs %s on %s" % (confirmed_home_team, confirmed_away_team, game_date.strftime("%Y-%m-%d"))
            print (msg)
            if EXPORT_ERRORS:
                errors.append({'type': 'Elo information missing', 'code': 3, 'text': msg})
                return {'success': 0, 'errors': errors}
            else:
                zc.send_crash(msg, bot_token)
                return None 

        #home_win_odds = 1.0/(1.0+math.pow(10.0, float(away_elo - home_elo)/400.0))
        away_win_odds = 1-home_win_odds

        # Parse the teams from the play by play
        alt_team1 = None; alt_team2 = None;
        total_swaps = 0
        for i in range(len(res)-1):
            if res[i]['time_elapsed'] == res[i+1]['time_elapsed'] and i > 2:
                if res[i]['event_type'] == "Faceoff Win" and res[i+1]['event_type'].endswith("Goal"):
                    log(to_screen, f, "Play #%d\tSwitch %s and %s" % (i, str(res[i]), str(res[i+1])))
                    tmp_keys = res[i].keys()
                    tmp = {}
                    
                    for zx in tmp_keys:
                        tmp[zx] = res[i][zx]
                    for zx in tmp_keys:
                        res[i][zx] = res[i+1][zx]
                    
                    for zx in tmp_keys:
                        res[i+1][zx] = tmp[zx]
                    
                    total_swaps += 1

            if alt_team1 is None:
                alt_team1 = res[i]['team']
            elif alt_team2 is None and res[i]['team'] != alt_team1:
                alt_team2 = res[i]['team']



        for i in range(len(res)-1):
            if res[i]['time_elapsed'] == res[i+1]['time_elapsed'] and i > 2:
                if res[i+1]['event_type'] == "Good Clear" and res[i]['event_type'].endswith("Goal"):
                    log(to_screen, f, "Play #%d\tSwitch %s and %s" % (i, str(res[i]), str(res[i+1])))

                    tmp_keys = res[i].keys()
                    tmp = {}
                    for zx in tmp_keys:
                        tmp[zx] = res[i][zx]
                    for zx in tmp_keys:
                        res[i][zx] = res[i+1][zx]
                    
                    for zx in tmp_keys:
                        res[i+1][zx] = tmp[zx]
                    

                    total_swaps += 1





        first_play_not_faceoff = False
        for i in range(len(res)-1):
            if res[i]['time_elapsed'] == res[i+1]['time_elapsed'] and i > 2:
                if res[i]['event_type'] == "Faceoff Win" and res[i+1]['event_type'].endswith("Goal"):
                    log(to_screen, f, "FAIL: Play #%d\tSwitch %s and %s" % (i, str(res[i]), str(res[i+1])))
                    #zc.exit("laxref0050")
                    first_play_not_faceoff = True
        timestamps['Switched play ordering as needed'] = time.time()

        print ("{:<60}{:<60}".format("home_team_name: %s" % home_team_name, "away_team_name: %s" % away_team_name))
        if home_team_name is None or away_team_name is None:
            alt_home_team, alt_away_team = translate_alt_teams(home_team_name, away_team_name, alt_team1, alt_team2, league, False)

            #print ("{:<30}{:<30}".format(alt_home_team, alt_away_team))
            timestamps['Set alternate team names'] = time.time()

            steps.append({'step': 'ID teams', 'time': time.time()})
        else:
            alt_home_team = home_team_name
            alt_away_team = away_team_name
        game_state = {'state': 0, 'home_score': 0, 'away_score': 0}


        plays_to_ignore = ['Goalie Change', 'Timeout', 'Substitution']
        offensive_plays_w_possession = ['Faceoff Win', 'Good Clear', 'Ground Ball', 'Pipe Shot', 'Missed Shot', 'Blocked Shot', 'Free Position Attempt']
        offensive_plays_lost_possession = ['Unforced Turnover', 'Forced Turnover', 'Saved Shot', 'Shot Clock Violation', 'Failed Clear']
        non_offensive_plays = ['Penalty - 30 sec', 'Penalty - 1 min', 'Yellow Card', 'Card']
        in_possession_team = None
        in_possession_team_ID = None
        next_team = None
        next_play = None
        next_next_team = None
        next_next_play = None
        confusing_plays = []
        total_possessions = 0
        attribution_class_cnts = [0]*100
        error = False
        away_possessions = 0; home_possessions = 0

        total_shots_variance = 0
        total_groundballs_variance = 0
        tregex = re.compile(r'Penalty.*?([0-9]+?) (min|sec)', re.IGNORECASE)

        w_one = 0
        w_two = 0
        w_none = 0
        non_faceoff_w_none = 0
        missed_plays = []
        details_w_none = []

        last_play = None
        last_team = None
        last_plays = []
        possessions = []
        man_up_opportunities = []
        cur_pos = None
        max_quarter = 0
        bad_plays = 0
        weirdness = [0]*4

        play_buffer = []

        team1_last_goalie = None
        team2_last_goalie = None
        
        team1_players = []
        team2_players = []
        team3_players = []
        team1_counts= []
        team2_counts = []
        team3_counts = []
        team3_opps = []
        team1_counts_dict = []
        team2_counts_dict = []
        team3_counts_dict = []
        team1 = confirmed_home_team
        team2 = confirmed_away_team

        # Parse play by play data
        adj_home = None
        adj_away = None

        plays_list = []

        snippets = []
        snippets.append(" (FIRST GOAL)")
        snippets.append(" (Shot Timer)")
        snippets.append(" (SECOND GOAL)")
        snippets.append(" (THIRD GOAL)")
        #snippets.append("(free position shot)")
        #snippets.append("{free position shot}")
        #snippets.append("(free position attempt)")
        snippets.append(" shot from close right wing")
        snippets.append(" shot from far left wing")
        snippets.append(" shot from far right wing")
        snippets.append("(shot from close right wing)")
        snippets.append("(shot from close left wing)")
        snippets.append(" shot from close left wing")
        snippets.append("(SHOT FROM TOP OF CIRCLE)")
        snippets.append(" SHOT FROM TOP OF CIRCLE")
        snippets.append("(SHOT FROM FAR RIGHT WING)")
        snippets.append("(SHOT FROM FAR LEFT WING)")
        snippets.append("(SHOT FROM IN THE CIRCLE)")
        snippets.append("{SHOT FROM IN THE CIRCLE}")
        snippets.append("{shot from in the circle}")
        snippets.append("(shot from in the circle)")
        snippets.append(" shot from in the circle")
        snippets.append("(30-Second Timer)")

        goalies = {}
        man_up = {'penalties': []}

        shot_clock = {'shot_clock_start': 0., 'shot_clock_remaining': None}
        last_time_elapsed = None
    
        if 'sections' not in settings:
            settings['sections'] = 180
        if 'league_db_win_odds' not in settings:
            settings['league_db_win_odds'] = None
        
        game_data = {}
        wp_specs = {'sections': settings['sections'], 'game_date': game_obj['game_date'], 'league_desc': game_obj['league']}
        game_data['home_win_odds'] = pregame_home_wp
        game_data['win_odds_ID'] = win_odds_ID
        game_data['win_odds_data'] = win_odds_data
        game_data['window_length'] = window_length
        game_data['home_abbreviations'] = [settings['home_team']]
        game_data['home_team'] = settings['home_team']
        game_data['away_abbreviations'] = [settings['away_team']]
        game_data['away_team'] = settings['away_team']
        game_data['sections'] = settings['sections']
        game_data['league_db_win_odds'] = settings['league_db_win_odds']
        #game_data['plays'] = [z.upper() for z in plays]
        game_data['plays'] = [str(z) for z in plays]
        game_data['play_values_for'] = play_values_for
        game_data['play_values_against'] = play_values_against

        
        if '--debug-test-play-values' in sys.argv:
            if 'plays' in settings and 'use_one_time_play_values' in settings and settings['use_one_time_play_values']:
                print ("Use the pre-created values")
            else:
                print ("Look up the values")
            print ("There are %d play records" % (len(game_data['plays']))    )
            print (sorted(game_data['plays']))
            #sys.exit()

        #print("     {:<95}{:<15}".format("Begin parsing plays...", datetime.now().strftime("%H:%M:%S")));
          
        # If necessary, apply replacement text logic
        if replacement_text is not None:
            for i, r in enumerate(res):
                #print ("{:<10}{}".format(r['ID'], r['details']))
                for rt in replacement_text:
                    if i == 0 and '--show-replacements' in sys.argv:
                        print ("\nReplace %s with %s" % (rt['from'], rt['to']))
                    
                    
                    if rt['from'] in r['details']:  
                        if '--show-replacements' in sys.argv:
                            print ("\n%s becomes %s" % (r['details'], r['details'].replace(rt['from'], rt['to'])))
                            
                        r['details'] = r['details'].replace(rt['from'], rt['to'])
        
        for i, r in enumerate(res):
            r['game_elapsed'] = r['time_elapsed']
            r['odds'] = None
            
        if '--add-odds-to-plays' in sys.argv or ('league_db_win_odds' in game_data and game_data['league_db_win_odds'] is not None):
  
            res, error = add_odds_to_plays_list(res, game_data, wp_specs)
            
        for i, r in enumerate(res):
        


            shot_clock_reset = False

            #for ix, zx in enumerate(r):
            #    if isinstance(zx, str):
            #        r[ix] = zx
            play_obj = {'ID': r['ID'], 'seq': r['seq']
            , 'poss_start': (r['game_elapsed_minutes']*60 + r['game_elapsed_seconds']) if cur_pos is None else cur_pos['start_time']
            , 'poss_ID': len(possessions)}
            r['details'] = r['details'].replace("---", "")
            r['details'] = r['details'].replace("BRY(1)", "BRY")
            r['details'] = r['details'].replace("{", "(").replace("}", ")")
            while "\r\n" in r['details']: r['details'] = r['details'].replace("\r\n", " ")
            while "  " in r['details']: r['details'] = r['details'].replace("  ", " ")

            play_obj['gem'] = r['game_elapsed_minutes']
            play_obj['ges'] = r['game_elapsed_seconds']
            line_out = ""

            orig_name = r['details']
            for s in snippets:
                #print ("is %s in %s" % (s, r['details']))
                if s in r['details']:
                    r['details'] = r['details'].replace(s, "")
                if s.upper() in r['details']:
                    r['details'] = r['details'].replace(s.upper(), "")
                if s.lower() in r['details']:
                    r['details'] = r['details'].replace(s.lower(), "")
                if s.title() in r['details']:
                    r['details'] = r['details'].replace(s.title(), "")
                    
            #if '--test-team-save' in sys.argv:
            #    if "TEAM SAVE" in r['details'].upper():
            #        input(r['details'])
            r['details'] = r['details'].replace(", TEAM SAVE ", " BLOCKED ")
            r['details'] = r['details'].replace(" TEAM SAVE ", " BLOCKED ")
            if r['details'].strip().endswith("TEAM SAVE"):
                r['details'] = r['details'].strip()[0:-9] + "BLOCKED"

            r['details'] = r['details'].replace("(FPGOAL) free position shot", "(FPGOAL)")
            r['details'] = r['details'].replace(" (30-second count)", "")

            random_time_match = re.compile(r'(\[[0-9:]+\])').search(r['details'])
            if random_time_match is not None:
                r['details'] = r['details'].replace(random_time_match.group(1), "")
            while "\n" in r['details']: r['details'] = r['details'].replace("\n", " ")
            while "\r" in r['details']: r['details'] = r['details'].replace("\r", " ")
            while ",," in r['details']: r['details'] = r['details'].replace(",,", ",")
            while " ," in r['details']: r['details'] = r['details'].replace(" ,", ",")
            while "  " in r['details']: r['details'] = r['details'].replace("  ", " ")
            if not r['details'].endswith("."):
                r['details'] += "."
            if r['details'].endswith(" ."):
                r['details'] = r['details'][0:-2] + "."
            if r['details'].endswith(".."):
                r['details'] = r['details'][0:-2] + "."
            while ",." in r['details']: r['details'] = r['details'].replace(",.", ".")


            r['details'] = r['details'].replace(", goal.", ".")
            r['details'] = r['details'].replace(" (on faceoff.", ".")


            play_obj['details'] = r['details']


            pct_complete = float(r['time_elapsed']) / float(60*60)
            time_str = ""
            quarter = 0
            if r['time_elapsed'] < 900:
                quarter = 0
            elif r['time_elapsed'] < 1800:
                quarter = 1
            elif r['time_elapsed'] < 2700:
                quarter = 2
            elif r['time_elapsed'] < 3600 or (r['time_elapsed'] == 3600 and max([z['time_elapsed'] for z in res]) == 3600):
                quarter = 3
            elif r['time_elapsed'] < 3600 + 4*60 or (r['time_elapsed'] == 3600 and max([z['time_elapsed'] for z in res]) == 3600 + 4*60):
                quarter = 4
            elif r['time_elapsed'] < 3600 + 8*60 or (r['time_elapsed'] == 3600 and max([z['time_elapsed'] for z in res]) == 3600 + 8*60):
                quarter = 5
            elif r['time_elapsed'] < 3600 + 12*60 or (r['time_elapsed'] == 3600 and max([z['time_elapsed'] for z in res]) == 3600 + 12*60):
                quarter = 6
            elif r['time_elapsed'] < 3600 + 16*60 or (r['time_elapsed'] == 3600 and max([z['time_elapsed'] for z in res]) == 3600 + 16*60):
                quarter = 7
            elif r['time_elapsed'] < 3600 + 20*60 or (r['time_elapsed'] == 3600 and max([z['time_elapsed'] for z in res]) == 3600 + 20*60):
                quarter = 8
            elif r['time_elapsed'] < 3600 + 24*60 or (r['time_elapsed'] == 3600 and max([z['time_elapsed'] for z in res]) == 3600 + 24*60):
                quarter = 9

            play_obj['quarter'] = quarter

            play_obj['pct_complete'] = pct_complete
            play_obj['time_str'] = convert_pct_complete_to_time_str(pct_complete, game_obj['game_date'].year, game_obj['league'])
            play_obj['time_elapsed'] = r['time_elapsed']
            uncertainty_value = 0.
            line_out += "%f," % pct_complete
            section = int(pct_complete * sections)
            play_obj['section'] = section




            play = r['event_type']
            if i == 0:
                home_team = "" if home_team_name is None else home_team_name
                away_team = "" if away_team_name is None else away_team_name
            
            team = r['team']

            play_obj['team'] = "" if team is None else team
            
            if team is None:
                msg = "Game ID: %s tried to process the team for a specific play but team was None\n\n%s\n\n%s" % (game_ID, zc.print_dict(r), zc.print_dict(play_obj))
                print (msg)
                
                if EXPORT_ERRORS:
                    errors.append({'type': "Could not parse team from play detail", 'code': 8, 'text': msg})
                    return {'success': 0, 'errors': errors}
                else:
                    zc.send_crash(msg, bot_token)
                    return None


                
            if None not in [home_team_name, team] and home_team_name.lower().strip() == team.lower().strip():
                adj_home = team
            elif None not in [away_team_name, team] and away_team_name.lower().strip() == team.lower().strip():
                adj_away = team
            else:
                if adj_away in [None, ""]:
                    adj_away = team
                elif adj_home in [None, ""] and team != adj_away:
                    adj_home = team
            
            play_obj['confirmed_team'] = confirmed_home_team if alt_home_team == r['team'] else confirmed_away_team
            
            team_ID = home_ID if alt_home_team == r['team'] else away_ID






            #play_obj['team_ID'] = home_ID if alt_home_team == r['team'].replace("(M~1", "M") else away_ID
            play_obj['team_ID'] = home_ID if alt_home_team == r['team'] else away_ID
            if play_obj['details'] is not None and " goalie" in play_obj['details'].lower() and " save the goalie" not in play_obj['details'].lower():

                goalies[play_obj['team_ID']], play_obj, game_obj = get_goalie(game_obj, play_obj)
                if ('first_%d' % play_obj['team_ID']) not in goalies:
                    goalies[('first_%d' % play_obj['team_ID'])] = goalies[play_obj['team_ID']]
                    
                if '--debug-goalie-assignments' in sys.argv:
                    print ("\n\nGoalie Change")
                    zc.print_dict(play_obj);
                    zc.print_dict(goalies);
            play_obj['goalie'] = None
            if play_obj['team_ID'] == home_ID:
                if away_ID in goalies:
                    play_obj['goalie'] = goalies[away_ID]
            elif play_obj['team_ID'] == away_ID:
                if home_ID in goalies:
                    play_obj['goalie'] = goalies[home_ID]


            #print_stuff(r)
            play_obj['play'] = play
            if play not in plays_to_ignore and not play.startswith("For "):
                team = r['team']
                quarter = r['quarter']

                if max_quarter < quarter:

                    max_quarter = quarter

                possession_change = False
                if in_possession_team is None:
                    if play == "Faceoff Win" or play == "Ground Ball":
                        in_possession_team = confirmed_home_team if alt_home_team == team else confirmed_away_team
                        possession_change = True
                    else:
                        log(to_screen, f, "Game ID: %s - the first play was not a face-off win..." % (game_ID))
                        first_play_not_faceoff = True



                if section >= 120:
                    ot = True
                else:
                    ot = False
                section = min(section, sections-1)





                quarter_loc = quarter - 1
                short_team = team
                team_ID = None
                if alt_home_team is None:
                    if alt_away_team is not None:
                        team_ID = away_ID if alt_away_team.strip() == team.strip() else home_ID
                else:
                    team_ID = home_ID if alt_home_team.strip() == team.strip() else away_ID
                if team_ID is None:
                    msg = "Game ID: %s short codes (%s, %s) didn't match given team (%s)...\n\n%s" % (game_ID, alt_away_team, alt_home_team, team, "" if log_url is None else log_url)
                    if EXPORT_ERRORS:
                        
                        errors.append({'type': "Could not set team ID; alt away/home didn't match", 'code': 13, 'text': msg})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(msg, bot_token)
                        return None
                team = confirmed_home_team if alt_home_team == team else confirmed_away_team
                #print("%s w/ %s and %s (not %s) and %s and %s" % (team, confirmed_home_team, alt_home_team, alt_away_team, team, confirmed_away_team))
                elapsed_seconds = int(r['time_elapsed'])
                tmp = play.replace("Penalty - 0 sec", "Penalty - 30 sec")
                if tmp == "Penalty - 90 sec" and tmp not in plays:
                    tmp = "Penalty - 1 min"
                play_loc = plays.index(tmp)
                #team_loc = teams.index(team)

                #log(to_screen, f, "\nPlay #%d (%02d:%02d - %d%% complete)\n---------------------------" % (i+1, r[5], r[7], 100*pct_complete))
                log(to_screen, f, "\t%s did %s @ %s (DB ID: %s)" % (team, play, convert_pct_complete_to_time_str(float(r['time_elapsed']) / 3600., game_obj['game_date'].year, game_obj['league'] ), r['ID']))

                after_in_possession = ""
                show_tags = True
                if len(res) > 500 and '--ignore-too-many-plays-error' not in sys.argv:
                    cmd = "python C:\\Users\\zcapo\\Documents\\workspace\\LacrosseReference\\get_official_ncaa_game_data.py --game-ID %d -league \"%s\" -u %s --replace-plays -manual"
                    try:
                        cmd = "python C:\\Users\\zcapo\\Documents\\workspace\\LacrosseReference\\get_official_ncaa_game_data.py --game-ID %d -league \"%s\" -u %s --replace-plays -manual" % (game_ID, game_obj['league'], game_obj['log_url'])
                    except Exception:
                        print (traceback.format_exc())
                        
                    msg = "Game ID: %s has %d plays in the DB (500 is the clue that something is wrong)...\n\n%s\n\n%s" % (game_ID, len(res), "" if log_url is None else log_url, cmd)
                    msg += "\n\nIf the number of plays is accurate, run the following command:\n\npython view_game_details.py -g %s --refresh-game-dict --ignore-too-many-plays-error" % game_ID
                    print (msg)
                    
                    if EXPORT_ERRORS:
                        errors.append({'type': "Possible duplicate LaxRef_Events records", 'code': 4, 'text': msg})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(msg, bot_token)
                        return None



                if i + 2 < len(res):
                    next_next_team = confirmed_home_team if alt_home_team == res[i+2]['team'] else confirmed_away_team
                    next_next_team_ID = home_ID if alt_home_team == res[i+2]['team'] else away_ID
                    next_next_play = res[i+2]['event_type']
                    next_next_quarter = res[i+2]['quarter']
                    next_next_pct_complete = float(res[i+2]['time_elapsed']) / float(60*60)
                else:
                    next_next_team = None
                    next_next_team_ID = None
                    next_next_play = None
                    next_next_quarter = None
                    next_next_pct_complete = None

                if i + 1 < len(res):
                    next_team = confirmed_home_team if alt_home_team == res[i+1]['team'] else confirmed_away_team
                    next_team_ID = home_ID if alt_home_team == res[i+1]['team'] else away_ID
                    next_play = res[i+1]['event_type']
                    next_quarter = res[i+1]['quarter']
                    next_pct_complete = float(res[i+1]['time_elapsed']) / float(60*60)

                else:
                    next_team = None
                    next_team_ID = None
                    next_play = None
                    next_quarter = None
                    next_pct_complete = None


                log(to_screen, f, "\t\tlast play: %s did %s" % (last_team, last_play))
                log(to_screen, f, "\t\tnext play: %s did %s" % (next_team, next_play))
                if (10000 if next_pct_complete is None else next_pct_complete) - pct_complete < .0007 and play.startswith("Penalty") and team == next_team and not next_play.startswith("Penalty") and not next_play.startswith("Card") and not next_play.startswith("Timeout") and not next_play.startswith("Goalie Change"):
                    log(to_screen, f, "Game ID: %s Play #%d - Weirdness, exiting..." % (game_ID, i))
                    log(to_screen, f, "\t%.4f vs %.4f" % (pct_complete, next_pct_complete))
                    if not (
                    (game_ID==997 and i==25)
                    or (game_ID==998 and i==161)
                    or (game_ID==999 and i==43)
                    or (game_ID==1001 and i==170)
                    or (game_ID==1025 and i==189)
                    or (game_ID==1004 and i==152)
                    or (game_ID==1027 and i==36)
                    or (game_ID==1041 and i==153)
                    or (game_ID==1042 and i==110)
                    or (game_ID==1045 and i==56)
                    or (game_ID==1045 and i==172)
                    or (game_ID==1047 and i==131)
                    or (game_ID==1051 and i==40)
                    or (game_ID==1052 and i==98)
                    ) and False:
                        error = True;

                    penalty_out_of_order += 1
                else:
                    if play_obj['gem']*60 + r['game_elapsed_seconds'] == last_elapsed:
                        consec += 1
                    else:
                        consec = 0
                    last_elapsed = play_obj['gem']*60 + r['game_elapsed_seconds']

                    play_ID = None
                    if cur_pos is not None and play == "Failed Clear":
                        cur_pos['failed_clear'] = True

                    if cur_pos is not None and cur_pos['failed_clear'] and (cur_pos['goal_scored'] or play is not None and play.endswith("Goal")):
                        #zc.send_telegram(msg, bot_token)
                        cur_pos['failed_clear'] = False
                        cur_pos['weird'][3] = 1

                    if play == "Faceoff Win" and next_play is not None and (next_play.startswith("Penalty") or next_play.startswith("Card")):
                        play_ID = 19; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)
                        
                        if cur_pos is None:
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "a0");

                        after_in_possession = team; after_in_possession_ID = team_ID
                        attribution_class_cnts[play_ID] += 1


                        possession_change = True
                    elif last_play == "Faceoff Win" and last_team != team and (play in offensive_plays_w_possession or play in offensive_plays_lost_possession):
                        play_ID = 24; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = team; after_in_possession_ID = team_ID
                        attribution_class_cnts[play_ID] += 1
                        possession_change = True

                    elif play == "Faceoff Win":

                        play_ID = 16; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if cur_pos is None:
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "b0");

                        after_in_possession = team; after_in_possession_ID = team_ID
                        attribution_class_cnts[play_ID] += 1
                        possession_change = True

                    elif cur_pos is None and play == "Ground Ball":

                        play_ID = 16; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)


                        cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "c0");

                        after_in_possession = team; after_in_possession_ID = team_ID
                        attribution_class_cnts[play_ID] += 1
                        possession_change = True

                    elif team != in_possession_team and (play.endswith("Goal") or play in offensive_plays_w_possession or play in offensive_plays_lost_possession):
                        play_ID = 17; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if cur_pos is None:
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                        else:
                            cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                            
                            if not last_play.endswith("Goal"):
                                cur_pos = set_ended_with(last_play, last_plays, cur_pos, play_obj, play, play_ID)
                            else:
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "d0");
                        after_in_possession = team; after_in_possession_ID = team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif None not in [next_play, next_quarter] and next_play == "Faceoff Win" and quarter != next_quarter:
                        play_ID = 15; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "e0");
                        after_in_possession = team; after_in_possession_ID = team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif "Turnover" in play and next_team is not None and next_team != team:
                        play_ID = 0; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play == "Ground Ball" and last_play == "Faceoff Win" and next_team is not None and next_team == team and last_team == team:
                        play_ID = 31; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if cur_pos is not None:
                            if cur_pos['team'] != team:
                                cur_pos['end_time'] =play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)


                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play in offensive_plays_w_possession and next_team is not None and next_team == team:
                        play_ID = 1; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if cur_pos is not None:
                            if cur_pos['team'] != team:
                                cur_pos['end_time'] =play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)


                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play in offensive_plays_lost_possession and next_team not in [None, team] and next_play == "Good Clear":
                        play_ID = 21; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "s0")
                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play in offensive_plays_lost_possession and None not in [next_team, next_play] and next_team != team and (next_play.startswith("Penalty") or next_play.startswith("Card")):
                        play_ID = 22; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play in offensive_plays_lost_possession and next_team not in [None, team]:
                        play_ID = 2; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "f0")
                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play in offensive_plays_lost_possession and next_team == team and quarter == next_quarter:
                        play_ID = 3; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif False and next_team != team and quarter == next_quarter:
                        play_ID = 4; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play == "Missed Shot" and next_quarter != quarter:
                        play_ID = 5; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "t0")
                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play.endswith("Goal") and next_play == "Faceoff Win":
                        play_ID = 6; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if cur_pos['team'] != team:
                            log(to_screen, f, "\t\t\t\tBecause the scoring team wasn't in possession, we'll add a new possession now.")

                            cur_pos['end_time'] =play_obj['gem']*60 + r['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                            log(to_screen, f, "Possession is now with %s and the possession started at %02d:%02d" % (team, play_obj['gem'], r['game_elapsed_seconds']))
                        else:
                            cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "g0")
                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1




                    elif play == "Missed Shot" and next_play == "Timeout" and quarter == next_quarter:
                        play_ID = 20; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif (play == "Missed Shot" or play == "Blocked Shot" or play == "Pipe Shot" or play == "Saved Shot") and team == next_team and quarter == next_quarter:
                        play_ID = 7; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif (play == "Missed Shot" or play == "Blocked Shot" or play == "Pipe Shot" or play == "Saved Shot") and team != next_team and quarter == next_quarter and next_play is not None and not next_play.startswith("Penalty") and not next_play.startswith("Card"):
                        play_ID = 8; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "h0")
                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play == "Shot Clock On" and quarter == next_quarter:
                        play_ID = 9; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play in offensive_plays_w_possession and next_team != team and quarter == next_quarter and next_play is not None and not next_play.startswith("Penalty") and not next_play.startswith("Card"):
                        play_ID = 10; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if last_play is None:
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "i0")
                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play in offensive_plays_w_possession and next_team != team and quarter == next_quarter and next_play is not None and (next_play.startswith("Penalty") or next_play.startswith("Card")):
                        play_ID = 29; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if cur_pos['team'] != team:
                            cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "j0")
                        after_in_possession = team; after_in_possession_ID = team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif play.endswith("Goal") and ((next_play is not None and (next_play.startswith("Penalty") or next_play.startswith("Card"))) or next_play == "Unforced Turnover"):
                        play_ID = 26; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)


                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "k0")

                        if (next_play.startswith("Penalty") or next_play.startswith("Card")) and next_team != team or next_next_play:
                            if next_next_team is not None and (next_next_team != next_team or next_next_play != "Faceoff Win"):
                                # If it was a penalty called on a goal being scored, but still requiring a faceoff afterwards, we wouldn't assign the extra possession here because the scoring team would need to win the faceoff and the extra possession would be added there.
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: 
                                    #zc.exit("A) Adding a play ID 26 possession; play=%s; team=%s; next_play=%s; next_team=%s; next_next_play=%s; next_next_team=%s" % (play, team, next_play, next_team, next_next_play, next_next_team))
                                    possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, play, next_play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                                possession_change = False
                        else:
                            possession_change = True
                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1


                    elif play.endswith("Goal") and (next_play == "Goalie Change" or next_play == "Timeout"):
                        play_ID = 11; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        if cur_pos['team'] != team:
                            cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)

                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif quarter != next_quarter and next_play == "Goalie Change":
                        play_ID = 18; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "l0")
                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif (play.startswith("Penalty") or play.startswith("Card")) and next_team == team and (next_play not in [None, "Goalie Change"] and not next_play.startswith("Penalty") and not next_play.startswith("Card") and not next_play.startswith("Timeout")):
                        play_ID = 30; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1
                        possession_change = True

                    elif (play.startswith("Penalty") or play.startswith("Card")) and next_team == in_possession_team:
                        play_ID = 13; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif (play.startswith("Penalty") or play.startswith("Card")) and next_team != in_possession_team and quarter==next_quarter:
                        play_ID = 14; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif (play.startswith("Penalty") or play.startswith("Card")) and next_team == team and quarter!=next_quarter:
                        play_ID = 27; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif (play.startswith("Penalty") or play.startswith("Card")) and next_team != in_possession_team and quarter!=next_quarter:
                        play_ID = 25; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    elif quarter!=next_quarter:
                        play_ID = 28; log(to_screen, f, "\t\tPlay ID: %d" % play_ID)

                        cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "m0")
                        after_in_possession = next_team; after_in_possession_ID = next_team_ID
                        attribution_class_cnts[play_ID] += 1

                    else:
                        after_in_possession = in_possession_team; after_in_possession_ID = in_possession_team_ID
                        bad_plays += 1
                        log(to_screen, f, "\n\n\t\tGame ID: %s - Attribution failed!!!!!!!!!!!\n\n" % game_ID)



                    # Assign possession to one of the teams
                    if in_possession_team != after_in_possession or possession_change:
                        if confirmed_away_team == after_in_possession:
                            away_possessions += 1
                        elif confirmed_home_team == after_in_possession:
                            home_possessions += 1
                        elif after_in_possession is None:
                            pass
                        else:
                            log(True, f, "\n\n\t\t%s does not match '%s' or '%s'" % (after_in_possession, confirmed_away_team, confirmed_home_team));

                            msg = "In laxref.create_game_dict, %s does not match '%s' or '%s'" % (after_in_possession, confirmed_away_team, confirmed_home_team)
                            
                            

                            if EXPORT_ERRORS:
                                print ("\n\n\t\t%s" % msg)
                                errors.append({'type': 'Possession attribution error', 'code': 5, 'text': msg})
                                return {'success': 0, 'errors': errors}
                            else:
                                zc.send_crash(msg, bot_token)
                                return None
                    actual_change = False
                    if after_in_possession == "":
                        log(to_screen, f, "\n\n\t\tGame ID: %s - Possession assignment failed!!!!!!!!!!!\n\n" % game_ID)
                    elif after_in_possession != in_possession_team:
                        log(to_screen, f, "\t\tPossession changed a new team picked up the ball (%d vs %d)..." % (away_possessions, home_possessions))
                        actual_change = True
                        total_possessions += 1
                        shot_clock_reset = True
                    elif next_quarter != quarter:
                        log(to_screen, f, "\t\tPossession ended because of the end of the quarter (%d vs %d)..." % (away_possessions, home_possessions))
                        total_possessions += 1
                        actual_change = True
                        shot_clock_reset = True
                    elif possession_change:
                        log(to_screen, f, "\t\tPossession changed because I said so (%d vs %d)..." % (away_possessions, home_possessions))
                        total_possessions += 1
                        actual_change = True
                        shot_clock_reset = True


                    if play in ['Pipe Shot', 'Saved Shot'] or (play is not None and (play.startswith("Penalty") or play.startswith("Card"))) or (play is not None and play.endswith("Goal")):

                        shot_clock_reset = True

                    shot_clock['shot_clock_remaining'] = shot_clock_duration - (play_obj['time_elapsed'] - shot_clock['shot_clock_start'])

                    #print "{:<10}{:<10}{:<10}{:<10}{:>20}{:>100}".format(play_obj['time_elapsed'], play_obj['team'], shot_clock['shot_clock_start'], shot_clock['shot_clock_remaining'], play, play_obj['details'][0:95])
                    play_obj['shot_clock_remaining'] = shot_clock['shot_clock_remaining']

                    play_obj['is_man_up'] = 0
                    if man_up['penalties'] != []:
                        if play_obj['team'] == man_up['advantage']:
                            play_obj['is_man_up'] = 1


                    if not shot_clock_reset:
                        if play == "Ground Ball" and last_play == "Faceoff Win":
                            if team == last_team and abs(play_obj['time_elapsed']- last_time_elapsed) < 12:
                                shot_clock['shot_clock_remaining'] = shot_clock_duration - (play_obj['time_elapsed']- last_time_elapsed)/2
                                shot_clock['shot_clock_start'] = play_obj['time_elapsed'] - (play_obj['time_elapsed']- last_time_elapsed)/2


                                #print "Set shot clock to %d - (%d-%d)/2 = %d" % (play_obj['time_elapsed'], last_time_elapsed, %d - (play_obj['time_elapsed']-last_time_elapsed)/2)




                    if shot_clock_reset:
                        shot_clock['shot_clock_remaining'] = reset_duration; shot_clock['shot_clock_start'] = play_obj['time_elapsed']


                    if actual_change:
                        # Check the start time of the new possession
                        if play_ID in [31, 17, 27, 18, 5, 28, 22]:
                            pass
                        elif play_ID in [29, 13]:
                            if cur_pos['team'] != after_in_possession:
                                log(to_screen, f, "\t\t* Possession change to team that didn't commit the next penalty %02d:%02d" % (play_obj['gem'], r['game_elapsed_seconds']))
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                #log(to_screen, f, "\t\tPenalty committed by %s, means %s, not %s, should have next possession without a faceoff" % (next_team, poss_team, next_team))
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, after_in_possession, after_in_possession_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)

                            #else:
                            #    log(to_screen, f, "\t\tPenalty committed by %s, means %s, not %s, should keep possession with no new possession" % (next_team, poss_team, next_team))

                        elif play_ID == 11:
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "n0");

                        elif play_ID == 30:
                            
                            #print "No longer adding an extra possession at play 30..."
                            pass


                        elif play_ID == 24:
                            log(to_screen, f, "\t\tFinish w/ possession %d" % cur_pos['ID'])


                            log(to_screen, f, "\t\t* Possession is now with %s and the possession started at %02d:%02d" % (after_in_possession, play_obj['gem'], r['game_elapsed_seconds']))
                            log(to_screen, f, "\t\t\t Consider that last team was %s and last time was %02d:%02d" % (last_team, last_min, last_sec))
                            current_elapsed = play_obj['gem'] * 60 + r['game_elapsed_seconds']
                            last_elapsed = last_min * 60 + last_sec
                            if last_elapsed < 3600:
                                last_quarter = int(last_elapsed / 900) + 1
                            else:
                                if max_quarter == 4:
                                    last_quarter = 3 + 1
                                else:
                                    last_quarter = int((last_elapsed-3600) / 300) + 4 + 1
                            
                            #print "Last q", last_quarter, "Q", quarter, "Next q", next_quarter
                            if last_quarter != quarter:
                                poss_min = int(current_elapsed / 60)
                                poss_sec = int(current_elapsed) % 60
                            else:
                                midpoint = (current_elapsed + last_elapsed) / 2
                                poss_min = int(midpoint / 60)
                                poss_sec = int(midpoint) % 60
                            #print play_obj['time_str'], poss_min, poss_sec; zc.exit('fa0932')
                            cur_pos['end_time'] = poss_min*60 + poss_sec
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, poss_min*60 + poss_sec, game_state, confirmed_away_team, f, to_screen)
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "o0");
                            log(to_screen, f, "\t\t So we really want possession to start at %02d:%02d" % (poss_min, poss_sec))

                        elif play_ID==25:

                            log(to_screen, f, "\t\t* Possession change to team that didn't commit the next penalty %02d:%02d" % (play_obj['gem'], r['game_elapsed_seconds']))
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "u0");
                            if cur_pos is not None:
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            poss_team = confirmed_away_team if team == confirmed_home_team else confirmed_home_team
                            poss_team_ID = away_ID if team == confirmed_home_team else home_ID
                            log(to_screen, f, "\t\t\tPenalty committed by %s, means %s, not %s, should have next possession without a faceoff" % (team, poss_team, next_team))
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, poss_team, poss_team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)



                        elif play_ID==26:

                            poss_team = confirmed_away_team if next_team == confirmed_home_team else confirmed_home_team
                            poss_team_ID = away_ID if next_team == confirmed_home_team else home_ID
                            if cur_pos['team'] != poss_team:
                                log(to_screen, f, "\t\t* Possession change to team that didn't commit the next penalty %02d:%02d" % (play_obj['gem'], r['game_elapsed_seconds']))
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: 
                                    #zc.exit("B) Adding a play ID 26 possession; next play=%s" % next_play)
                                    possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                log(to_screen, f, "\t\tPenalty committed by %s, means %s, not %s, should have next possession without a faceoff" % (next_team, poss_team, next_team))
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, poss_team, poss_team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                                cur_pos['penalties'] = 1
                            else:
                                log(to_screen, f, "\t\tPenalty committed by %s, means %s, not %s, should keep possession with no new possession" % (next_team, poss_team, next_team))
                                cur_pos['penalties'] += 1

                        elif play_ID == 1:
                            if cur_pos is None:
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "p0")

                        elif play_ID==14:

                            if total_possessions > 1 and cur_pos is None:
                            
                                try:
                                    query = "UPDATE LaxRef_Events set game_elapsed_seconds=1 where game_elapsed_seconds=0 and event_type like 'Penalty%%' and active and game_ID=%d" % game_ID
                                except Exception:
                                    query = "UPDATE LaxRef_Events set game_elapsed_seconds=1 where game_elapsed_seconds=0 and event_type like 'Penalty%' and active and game_ID=[]"
                                    
                                msg = "In laxref.create_game_dict, Error (A): possession count is not 1 in play_ID=14 (code=kdw9s0a)!!!\n\nIn at least one case, a foul was recorded after 0 seconds had elapsed in the game (i.e. the same time as the initial DC win; setting the game_elapsed_seconds for that play in LaxRef_Events to 1 solved the issue. We could also put in a more permanent fix and automatically set the pct_complete to 1 second for any penalty.\n\nIf this was the issue, use this query to resolve it:\n\n%s" % query
                                print ("\t\t\t\t\t%s" % msg)
                                

                                if EXPORT_ERRORS:
                                    errors.append({'type': 'Possession attribution issue', 'code': 5, 'text': msg})
                                    return {'success': 0, 'errors': errors}
                                else:
                                    return None
                            if cur_pos is not None:
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, next_team, next_team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                            log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, play_obj['gem'], r['game_elapsed_seconds']))

                        elif play_ID==16:

                            if total_possessions > 1 and cur_pos is None:
                                log(True, f, "\t\t\t\t\tError (B): possession count is not 1!!!"); zc.exit("laxref0054")
                            if cur_pos is not None and last_play is not None:
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(last_play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play);
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "q0");

                            log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, play_obj['gem'], r['game_elapsed_seconds']))

                        elif play_ID==21:

                            if total_possessions > 1 and cur_pos is None:
                                log(True, f, "\t\t\t\t\tError (C): possession count is not 1!!!"); zc.exit("laxref0055")
                            if cur_pos is not None and last_play is not None:
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, after_in_possession, after_in_possession_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)

                            log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, play_obj['gem'], r['game_elapsed_seconds']))

                        elif play_ID in [7]:

                            if total_possessions > 1 and cur_pos is None:
                                log(True, f, "\t\t\t\t\tError (D): possession count is not 1!!!"); zc.exit("laxref0056")
                            if cur_pos is not None and last_play is not None:
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)

                            log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, play_obj['gem'], r['game_elapsed_seconds']))

                        elif play_ID in [19]:

                            if total_possessions > 1 and cur_pos is None:
                                msg = "In the LR game dict process (error e), cur_pos was None but the play was {} in game ID {} @ {} pct complete; full details: {}\n\n{}".format(play, game_ID, play_obj['pct_complete'], play_obj['details'], zc.print_dict(play_obj))
                                zc.send_telegram(msg, bot_token)
                                print (msg)
                                zc.exit("laxref0057")
                                log(True, f, "\t\t\t\t\tError (E): possession count is not 1!!!"); zc.exit("laxref0058")
                                
                            if cur_pos is not None and last_play is not None:
                                cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                                cur_pos = set_ended_with(last_play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, play_obj['gem']*60 + r['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)

                            log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, play_obj['gem'], r['game_elapsed_seconds']))

                        elif play_ID == 0:
                            #log(to_screen, f, "\t\tFinish w/ possession %d" % cur_pos['ID'])
                            if i+1 < len(res):
                                cur_pos['end_time'] = res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, next_team, next_team_ID, play_ID, last_play, play, res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                                log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, res[i+1]['game_elapsed_minutes'], res[i+1]['game_elapsed_seconds']))
                            else:
                                cur_pos['end_time'] = res[i]['game_elapsed_minutes']*60 + res[i]['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, next_team, next_team_ID, play_ID, last_play, play, res[i]['game_elapsed_minutes']*60 + res[i]['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                                log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, res[i]['game_elapsed_minutes'], res[i]['game_elapsed_seconds']))

                        elif play_ID==2:
                            log(to_screen, f, "\t\tFinish w/ possession %d" % cur_pos['ID'])
                            cur_pos['end_time'] = play_obj['gem']*60 + r['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            if i+1 < len(res):
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, next_team, next_team_ID, play_ID, last_play, play, res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                                log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, res[i+1]['game_elapsed_minutes'], res[i+1]['game_elapsed_seconds']))
                            else:
                                cur_pos = new_possession(play_obj, len(plays_list), total_possessions, next_team, next_team_ID, play_ID, last_play, play, res[i]['game_elapsed_minutes']*60 + res[i]['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                                log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, res[i]['game_elapsed_minutes'], res[i]['game_elapsed_seconds']))

                        elif play_ID in [8,10]:
                            log(to_screen, f, "\t\tFinish w/ possession %d" % cur_pos['ID'])
                            cur_pos['end_time'] = res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)

                            current_elapsed = play_obj['gem'] * 60 + r['game_elapsed_seconds']
                            next_elapsed = res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds']
                            midpoint = (next_elapsed + current_elapsed) / 2
                            poss_min = int(midpoint / 60)
                            poss_sec = int(midpoint) % 60

                            if '-debug' in sys.argv:
                                print ("{:<30}{:<30}{:<30}{:<30}{:<30}{:<30}".format(
                                    "next_elapsed: %s" % (next_elapsed)
                                    , "current_elapsed: %s" % (current_elapsed)
                                    , "midpoint: %s" % (next_elapsed)
                                    , "poss_min: %s" % (poss_min)
                                    , "poss_sec: %s" % (poss_sec)
                                    , "next_start: %s" % (poss_min*60 + poss_sec)))
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, next_team, next_team_ID, play_ID, last_play, play, poss_min*60 + poss_sec, game_state, confirmed_away_team, f, to_screen)

                            log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, res[i+1]['game_elapsed_minutes'], res[i+1]['game_elapsed_seconds']))

                        elif play_ID in [15]:
                            if cur_pos is not None:
                                
                                cur_pos['end_time'] = res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds']
                                cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)
                                if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                                #cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, play_ID, last_play, play, res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                                log(to_screen, f, "\t\tQuarter ends; possession was with %s and the possession started at %02d:%02d -- we are not creating a new possession" % (after_in_possession, res[i+1]['game_elapsed_minutes'], res[i+1]['game_elapsed_seconds']))
                            else:
                                try:
                                    msg = "\n\nIn laxref.create_game_dict (game_ID=%d), there was a faceoff win (play ID=15) and we were expecting cur_pos to be populated, but it was None. Code 20dl29d\n\n" % game_ID
                                except Exception:
                                    msg = "\n\nIn laxref.create_game_dict, there was a faceoff win (play ID=15) and we were expecting cur_pos to be populated, but it was None. Code 20dl29d\n\n"
                                print (msg)
                                
                            

                        elif play_ID in [6, 9, 20]:
                            #log(to_screen, f, "\t\tFinish w/ possession %d" % cur_pos['ID'])
                            cur_pos['end_time'] = res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds']
                            cur_pos = set_ended_with(play, last_plays, cur_pos, play_obj, play, play_ID)

                            if cur_pos is not None and cur_pos not in possessions: possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)
                            cur_pos = new_possession(play_obj, len(plays_list), total_possessions, team, team_ID, play_ID, last_play, play, res[i+1]['game_elapsed_minutes']*60 + res[i+1]['game_elapsed_seconds'], game_state, confirmed_away_team, f, to_screen)
                            log(to_screen, f, "\t\tPossession is now with %s and the possession started at %02d:%02d" % (after_in_possession, res[i+1]['game_elapsed_minutes'], res[i+1]['game_elapsed_seconds']))

                        elif play_ID is not None:
                            msg = "Error with play ID: %d (game_ID = %s)" % (play_ID, game_ID)
                            log(True, f, msg)
                            
                            if EXPORT_ERRORS:
                                print (msg)
                                errors.append({'type': 'Play could not be identified (play ID set, but play logic not processed)', 'code': 6, 'text': msg})
                                return {'success': 0, 'errors': errors}
                            else:
                                zc.send_crash(msg, bot_token)
                                return None

                        else:
                            msg = "In laxref.create_game_dict, error in game_ID=%s, identifying a play ID: %s" % (game_ID, play_obj['details'])
                            log(True, f, msg)
                            
                            if EXPORT_ERRORS:
                                print (msg)
                                errors.append({'type': 'Play could not be identified (no play ID set)', 'code': 6, 'text': msg})
                                return {'success': 0, 'errors': errors}
                            else:
                                zc.send_crash(msg, bot_token)
                                return None
                    else:
                        # Total up the stats that happened during the possession
                        if play_ID != 6 and play_ID != 17 and play_ID != 29 and play_ID != 31 and play_ID != 21 and play_ID != 26:
                            cur_pos, consec = assign_play(cur_pos, consec, quarter_loc, play, team, elapsed_seconds, play_ID, game_ID, play_obj, "r0")

                    in_possession_team = after_in_possession
                    in_possession_team_ID = after_in_possession_ID

                    log(to_screen, f, "\t\tIn possession: %s" % in_possession_team)

                    if quarter != next_quarter:
                        log(to_screen, f, "=======================================================\nQuarter\n =======================================================")



                if "Goal" in r['event_type'] and "Goalie Change" not in r['event_type']:
                    #print "\n\nStarting game state: %d (%s scored)" % (game_state, short_team)

                    #print_stuff("Home is %s %s %s %s" % (home_team, home_1, home_2, adj_home));
                    #print_stuff("Away is %s %s %s %s" % (away_team, away_1, away_2, adj_away));

                    if (short_team.lower() == home_team.lower() or (adj_home is not None and short_team.lower() == adj_home.lower()) or short_team.lower() == alt_home_team.lower()):
                        game_state['state'] += 1
                        game_state['home_score'] += 1
                    elif  (short_team.lower() == away_team.lower() or (adj_away is not None and short_team.lower() == adj_away.lower()) or short_team.lower() == alt_away_team.lower()):
                        game_state['state'] -= 1
                        game_state['away_score'] += 1
                    else:
                        msg = ("Team is %s" % (short_team));
                        msg += ("\nHome is %s %s %s %s (%s)" % (home_team, home_team_name.lower(), alt_home_team, adj_home, r));
                        msg += ("\nAway is %s %s %s %s (%s)" % (away_team, away_team_name.lower(), alt_away_team, adj_away, r));
                        msg += ("\n9204g: Error!!!!!!!!!!!!!!!!!!!!")
                        print (msg)
                        zc.send_telegram(msg, bot_token)
                        zc.exit("laxref0061")
                    #print "Ending game state: %d\n\n" % game_state['state']



                #print_pos(cur_pos, f, possessions, to_screen)
                last_play = play
                if len(last_plays) < 5:
                    last_plays.append(play)
                else:
                    last_plays = last_plays[1:] + [play]
                last_team = team#
                last_team_ID = team_ID
                last_min = play_obj['gem']
                last_time_elapsed = play_obj['time_elapsed']
                last_sec = r['game_elapsed_seconds']


            if "Timeout" in play:
                if play_obj['confirmed_team'] != in_possession_team:
                    shot_clock['shot_clock_start'] = play_obj['time_elapsed']
                    shot_clock['shot_clock_remaining'] = shot_clock_duration
                    shot_clock_reset = True

            team = r['team']#
            play_obj['play_type'] = r['event_type']
            #print r

            if r['event_type'] == "Penalty - 90 sec" and r['event_type'] not in plays:
                r['event_type'] = "Penalty - 1 min"
            r['ignore_play'] = 0
            if r['event_type'] != "Substitution" and r['details'] not in ['empty net, foul by keeper.', 'empty net, foul by keeper ', 'penalty by targeting.', 'Timeout by Media.', 'Timeout by media.', 'Timeout by Injury.', 'Unsportsmanlike by the bench.'] and play_obj['details'] not in ['penalty by targeting', 'Unsportsmanlike by the bench.'] and 'asst coach' not in r['details'] and "called off after stick check" not in r['details']:
                tmp_clean_team = team

                if tmp_clean_team == away_team_name or tmp_clean_team == alt_away_team:
                    team = confirmed_away_team
                    play_obj['opp'] = alt_home_team
                elif tmp_clean_team == home_team_name or tmp_clean_team == alt_home_team:
                    team = confirmed_home_team
                    play_obj['opp'] = alt_away_team
                elif tmp_clean_team.upper() == away_team_name or tmp_clean_team == alt_away_team:
                    team = confirmed_away_team
                    play_obj['opp'] = alt_home_team
                elif tmp_clean_team.upper() == home_team_name or tmp_clean_team == alt_home_team:
                    team = confirmed_home_team
                    play_obj['opp'] = alt_away_team
                else:
                    msg = "Fatal 0 in game %s" % ("unknown" if game_ID is None else game_ID)
                    msg += "\n%s\t%s\t%s\t%s\t%s" % (tmp_clean_team, away_team_name, alt_away_team, home_team_name, alt_home_team)
                    msg += "\n\tDetail: %s\n" % (str(r))
                    
                    query = "Select home_ID, away_ID, game_date, laxdotcom_ID, log_url, zgame_year year from LaxRef_Games where ID=%s"
                    param = [game_ID]
                   
                    game_obj = None
                    cursor = zc.zcursor("LR")
                    tmp_games = cursor.dqr(query, param)
                    if len(tmp_games) > 0:
                        game_obj = tmp_games[0]
                    cursor.close()
                        
                    
                    if 'ID' in r:
                        msg += "\n\nhttp://192.168.1.240:5000/laxref_query?table=LaxRef_Events&ID=%s" % r['ID']
                        msg += "\n\nhttp://192.168.1.240:5000/laxref_query?table=LaxRef_Events&game_ID=%s" % game_ID
                        msg += "\n\nhttp://192.168.1.240:5000/laxref_query?table=LaxRef_Games&ID=%s" % game_ID
                        if game_obj is not None:
                            msg += "\n\nhttps://pro.lacrossereference.com/admin_cockpit?game_ID=%s&dt=%s" % (game_ID, game_obj['game_date'].strftime("%Y%m%d"))
                    

                    if EXPORT_ERRORS:
                        print (msg)
                        errors.append({'type': 'Play classification error', 'code': 7, 'text': msg})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(msg, bot_token)
                        return None


                player = None
                player1 = None
                player2 = None
                player3 = None
                player_play = None
                player1_play = None
                player2_play = None
                player3_play = None
                player2_is_save = False

                debug_classification = 0 #1 if 'GOAL by CHA Phallon Kilduff' in play_obj['details'] else 0
                if debug_classification:
                    print ("Details: %s (ID=%s)" % (play_obj['details'], play_obj['ID']))   
                    
                # This is where the raw details from the play by play is converted into the players involved and the plays to be assigned to them
                tmp_result = classify_details(play_obj, game_ID, classifiers, settings)
                
                if debug_classification:
                    print (tmp_result)   
                    zc.exit("DEBUG Details Classification")
                if tmp_result[0] is None: 
                    classification_error = tmp_result[1]
                    if classification_error is None:
                        classification_error = "???"
                    
                    
                    if EXPORT_ERRORS:
                        print (classification_error)
                        errors.append({'type': 'Play classification error', 'code': 8, 'text': classification_error})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(classification_error, bot_token)
                        return None
                    
                else:
                    player, player1, player2, player3, player_play, player1_play, player2_play, player3_play, player_team, player1_team, player2_team, player3_team, res_regex, successful_classification, classification_error = tmp_result
                    penalty_added = False



                    if not successful_classification:
                        
                        if EXPORT_ERRORS:
                            print (classification_error)
                            errors.append({'type': 'Play classification error', 'code': 8, 'text': classification_error})
                            return {'success': 0, 'errors': errors}
                        else:
                            zc.send_crash(classification_error, bot_token)
                            return None

                    player = player.strip() if player is not None else None
                    player1 = player1.strip() if player1 is not None else None
                    player2 = player2.strip() if player2 is not None else None
                    player3 = player3.strip() if player3 is not None else None
                    play_obj['regex'] = res_regex
                    play_obj['player'] = player
                    play_obj['player1'] = player1
                    play_obj['player2'] = player2
                    play_obj['player2_is_save'] = player2_is_save
                    play_obj['player3'] = player3
                    play_obj['player_play'] = player_play
                    play_obj['player1_play'] = player1_play
                    play_obj['player2_play'] = player2_play
                    play_obj['player3_play'] = player3_play
                    play_obj['player_team'] = player_team
                    play_obj['player1_team'] = player1_team
                    play_obj['player2_team'] = player2_team
                    play_obj['player3_team'] = player3_team
                    
                    if '--print-plays' in sys.argv:
                        if 1 or 'Alex Daly' in [player, player1, player2, player3]:
                            print ("{:<8.3f}{:<30}{:<20}{:<30}{:<20}{:<20}{:<20}{:<20}{:<20}{:<20}{}".format(play_obj['pct_complete']
                            , "" if player is None else player
                            , "" if player_team is None else player_team
                            , "" if player1 is None else player1
                            , "" if player1_team is None else player1_team
                            , "" if player2 is None else player2
                            , "" if player2_team is None else player2_team
                            , "" if player3 is None else player3
                            , "" if player3_team is None else player3_team
                            , play_obj['play_type']
                            , play_obj['details']))
                    

                    
                    if play_obj['play_type'] == "Goalie Change":
                        
                        if team1 == team:
                            team1_last_goalie = play_obj['player']
                            if play_obj['player'] not in team1_players:
                                team1_players.append(play_obj['player'])
                                team1_counts.append(0)
                                team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            
                        elif team2 == team:
                            team2_last_goalie = play_obj['player']
                            if play_obj['player'] not in team2_players:
                                team2_players.append(play_obj['player'])
                                team2_counts.append(0)
                                team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                    elif "Faceoff" in play_obj['details'] or "Draw control" in play_obj['details']:

                        # Only one player is referenced, so we don't need to do the whole investigative thing
                        if player1 not in [None, ''] and player2 in [None, ''] and player3 in [None, '']:
                            
                            if team1 == team:
                                if player1 not in team1_players:
                                    team1_players.append(player1)
                                    team1_counts.append(0)
                                    team1_counts_dict.append({'saves': 0, 'ct': 0, 'total': 0, 'goals_allowed': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})


                                team1_counts_dict[team1_players.index(player1)]['play_log'].append(scan_play("M", "Team 1", player1, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'opp': player2, 'play_type': "Faceoff Win", 'team': play_obj['confirmed_team'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                #print "{:<30}{:<30}".format("Winner: %s" % player1, "Opp: %s" % player2)

                            else:
                                if player1 not in team2_players:
                                    team2_players.append(player1)
                                    team2_counts.append(0)
                                    team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})


                                team2_counts_dict[team2_players.index(player1)]['play_log'].append(scan_play("M", "Team 1", player1, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'opp': player2, 'play_type': "Faceoff Win", 'team': play_obj['confirmed_team'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                #print "{:<30}{:<30}".format("Winner: %s" % player1, "Opp: %s" % player2)
                        else:
                      
                            #print "\n{:<100}{:<30}{:<30}{:<30}{:<30}".format(play_obj['details'], "%s: %s" % (player, player_play), "%s: %s" % (player1, player1_play), "%s: %s" % (player2, player2_play), "%s: %s" % (player3, player3_play))
                            # There are multiples players involved, so we do need to determine which team they are associated with
                            if player1 not in team3_players:
                                team3_players.append(player1)
                                team3_counts.append(0)
                                team3_opps.append(player2)
                                team3_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})


                            team3_counts_dict[team3_players.index(player1)]['play_log'].append(scan_play("M", "Team 1", player1, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'opp': player2, 'play_type': "Faceoff Win", 'team': play_obj['confirmed_team'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                   
                            #if 'Alex Daly' in [player, player1, player2, player3]:
                            #    print ("A) {:<30}{:<30}".format("Winner: %s" % player1, "Opp: %s" % player2))

                            if player2 not in [None, '', home_team, away_team]:
                                if player2 not in team3_players:
                                    team3_players.append(player2)
                                    team3_counts.append(0)
                                    team3_opps.append(player1)
                                    team3_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})

                                team3_counts_dict[team3_players.index(player2)]['play_log'].append(scan_play("M", "Team 1", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'opp': player1, 'play_type': "Faceoff Win", 'team': play_obj['confirmed_team'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                               
                               #if 'Alex Daly' in [player, player1, player2, player3]:
                                #    print ("B) {:<30}{:<30}".format("Winner: %s" % player2, "Opp: %s" % player1))


                            if player3 not in [None, '', home_team, away_team] :
                                if "groundball" in play_obj['details'].lower().replace(" ", ""):
                                    if play_obj['player3_team'] != play_obj['team']:
                                        pass

                                    else:
                                        if team1 == team:

                                            if player3 not in team1_players:
                                                team1_players.append(player3)
                                                team1_counts.append(0)
                                                team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})

                                            team1_counts[team1_players.index(player3)] += 1
                                            team1_counts_dict[team1_players.index(player3)]['total'] += 1
                                            team1_counts_dict[team1_players.index(player3)]['gbs'] += 1


                                            team1_counts_dict[team1_players.index(player3)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player3)]['plays']].index("Ground Ball")]['cnt'] += 1.
                                            team1_counts_dict[team1_players.index(player3)]['play_log'].append(scan_play("A", "Team 1", player3, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'FOGO': True, 'play_type': "Ground Ball", 'team': play_obj['confirmed_team'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                            team1_counts_dict[team1_players.index(player3)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player3)]['plays_by_quarter'][play_obj['quarter']]].index("Ground Ball")]['cnt'] += 1.
                                        else:
                                            if player3 not in team2_players:
                                                team2_players.append(player3)
                                                team2_counts.append(0)
                                                team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})

                                            team2_counts[team2_players.index(player3)] += 1
                                            team2_counts_dict[team2_players.index(player3)]['total'] += 1
                                            team2_counts_dict[team2_players.index(player3)]['gbs'] += 1


                                            team2_counts_dict[team2_players.index(player3)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player3)]['plays']].index("Ground Ball")]['cnt'] += 1.
                                            team2_counts_dict[team2_players.index(player3)]['play_log'].append(scan_play("A", "Team 1", player3, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'FOGO': True, 'play_type': "Ground Ball", 'team': play_obj['confirmed_team'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                            team2_counts_dict[team2_players.index(player3)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player3)]['plays_by_quarter'][play_obj['quarter']]].index("Ground Ball")]['cnt'] += 1.


                                        pass
                            else:
                                pass

                    elif player1 not in [None, ''] and player2 not in [None, '']:

                        if team1 == team:
                            if player1 not in team1_players:
                                team1_players.append(player1)
                                team1_counts.append(0)
                                team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            team1_counts[team1_players.index(player1)] += 1
                            team1_counts_dict[team1_players.index(player1)]['total'] += 1
                            team1_counts_dict[team1_players.index(player1)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            if r['event_type'].endswith("Goal") and team2_last_goalie is not None:
                                team2_counts_dict[team2_players.index(team2_last_goalie)]['goals_allowed'] += 1
                            team1_counts_dict[team1_players.index(player1)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team1_counts_dict[team1_players.index(player1)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team1_counts_dict[team1_players.index(player1)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team1_counts_dict[team1_players.index(player1)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team1_counts_dict[team1_players.index(player1)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team1_counts_dict[team1_players.index(player1)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player1)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team1_counts_dict[team1_players.index(player1)]['play_log'].append(scan_play("A", "Team 1", player1, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                            team1_counts_dict[team1_players.index(player1)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player1)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.

                            if r['event_type'] in ["Saved Shot"]:
                                if player2 not in team2_players:
                                    team2_players.append(player2)
                                    team2_counts.append(0)
                                    team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                                team2_counts[team2_players.index(player2)] += 1

                                team2_counts_dict[team2_players.index(player2)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays']].index("Save")]['cnt'] += 1.
                                team2_last_goalie = player2
                                team2_counts_dict[team2_players.index(player2)]['play_log'].append(scan_play("F", "Team 1", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': "Save", 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index("Save")]['cnt'] += 1.
                            elif r['event_type'] in ["Forced Turnover"]:
                                if player2 not in team2_players:
                                    team2_players.append(player2)
                                    team2_counts.append(0)
                                    team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                                team2_counts[team2_players.index(player2)] += 1

                                team2_counts_dict[team2_players.index(player2)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays']].index("Caused Turnover")]['cnt'] += 1.
                                team2_counts_dict[team2_players.index(player2)]['play_log'].append(scan_play("F", "Team 1", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': "Caused Turnover", 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.
                            else:

                                if player2 not in team1_players:
                                    team1_players.append(player2)
                                    team1_counts.append(0)
                                    team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                                team1_counts[team1_players.index(player2)] += 1
                                team1_counts_dict[team1_players.index(player2)]['total'] += 1
                                team1_counts_dict[team1_players.index(player2)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                                team1_counts_dict[team1_players.index(player2)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                                team1_counts_dict[team1_players.index(player2)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                                team1_counts_dict[team1_players.index(player2)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                                team1_counts_dict[team1_players.index(player2)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                                team1_counts_dict[team1_players.index(player2)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                                if r['event_type'].endswith("Goal"):
                                    team1_counts_dict[team1_players.index(player2)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays']].index("Assist")]['cnt'] += 1.
                                    team1_counts_dict[team1_players.index(player2)]['play_log'].append(scan_play("C", "Team 1", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': "Assist", 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                    team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index("Assist")]['cnt'] += 1.
                                else:
                                    team1_counts_dict[team1_players.index(player2)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays']].index(r['event_type'])]['cnt'] += 1.
                                    team1_counts_dict[team1_players.index(player2)]['play_log'].append(scan_play("D", "Team 1", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                    team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.


                        else:
                            if player1 not in team2_players:
                                team2_players.append(player1)
                                team2_counts.append(0)
                                team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            team2_counts[team2_players.index(player1)] += 1
                            team2_counts_dict[team2_players.index(player1)]['total'] += 1
                            team2_counts_dict[team2_players.index(player1)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            if r['event_type'].endswith("Goal") and team1_last_goalie is not None:
                                team1_counts_dict[team1_players.index(team1_last_goalie)]['goals_allowed'] += 1
                            team2_counts_dict[team2_players.index(player1)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team2_counts_dict[team2_players.index(player1)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team2_counts_dict[team2_players.index(player1)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team2_counts_dict[team2_players.index(player1)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team2_counts_dict[team2_players.index(player1)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team2_counts_dict[team2_players.index(player1)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player1)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team2_counts_dict[team2_players.index(player1)]['play_log'].append(scan_play("E", "Team 2", player1, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))

                            team2_counts_dict[team2_players.index(player1)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player1)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.



                            if r['event_type'] in ["Saved Shot"]:
                                if player2 not in team1_players:
                                    team1_players.append(player2)
                                    team1_counts.append(0)
                                    team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                                team1_counts[team1_players.index(player2)] += 1

                                team1_counts_dict[team1_players.index(player2)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays']].index("Save")]['cnt'] += 1.
                                team1_last_goalie = player2
                                team1_counts_dict[team1_players.index(player2)]['play_log'].append(scan_play("F", "Team 1", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': "Save", 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index("Save")]['cnt'] += 1.
                            elif r['event_type'] in ["Forced Turnover"]:
                                if player2 not in team1_players:
                                    team1_players.append(player2)
                                    team1_counts.append(0)
                                    team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                                team1_counts[team1_players.index(player2)] += 1

                                team1_counts_dict[team1_players.index(player2)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays']].index("Caused Turnover")]['cnt'] += 1.
                                team1_counts_dict[team1_players.index(player2)]['play_log'].append(scan_play("F", "Team 1", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': "Caused Turnover", 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.
                            else:
                                if player2 not in team2_players:
                                    team2_players.append(player2)
                                    team2_counts.append(0)
                                    team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                                team2_counts[team2_players.index(player2)] += 1
                                team2_counts_dict[team2_players.index(player2)]['total'] += 1
                                team2_counts_dict[team2_players.index(player2)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                                team2_counts_dict[team2_players.index(player2)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                                team2_counts_dict[team2_players.index(player2)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                                team2_counts_dict[team2_players.index(player2)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                                team2_counts_dict[team2_players.index(player2)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                                team2_counts_dict[team2_players.index(player2)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0



                                if r['event_type'].endswith("Goal"):
                                    team2_counts_dict[team2_players.index(player2)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays']].index("Assist")]['cnt'] += 1.
                                    team2_counts_dict[team2_players.index(player2)]['play_log'].append(scan_play("G", "Team 2", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': "Assist", 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                    team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index("Assist")]['cnt'] += 1.
                                else:
                                    team2_counts_dict[team2_players.index(player2)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays']].index(r['event_type'])]['cnt'] += 1.
                                    team2_counts_dict[team2_players.index(player2)]['play_log'].append(scan_play("H", "Team 2", player2, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                                    team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player2)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.

                    elif player1 not in [None, ''] and player3 not in [None, '']:
                        if team1 == team:
                            if player1 not in team1_players:
                                team1_players.append(player1)
                                team1_counts.append(0)
                                team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            team1_counts[team1_players.index(player1)] += 1
                            team1_counts_dict[team1_players.index(player1)]['total'] += 1
                            team1_counts_dict[team1_players.index(player1)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            if r['event_type'].endswith("Goal") and team2_last_goalie is not None:
                                team2_counts_dict[team2_players.index(team2_last_goalie)]['goals_allowed'] += 1
                            team1_counts_dict[team1_players.index(player1)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team1_counts_dict[team1_players.index(player1)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team1_counts_dict[team1_players.index(player1)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team1_counts_dict[team1_players.index(player1)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team1_counts_dict[team1_players.index(player1)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team1_counts_dict[team1_players.index(player1)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player1)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team1_counts_dict[team1_players.index(player1)]['play_log'].append(scan_play("I", "Team 1", player1, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                            team1_counts_dict[team1_players.index(player1)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player1)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.

                            if player3 not in team1_players:
                                team1_players.append(player3)
                                team1_counts.append(0)
                                team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            team1_counts[team1_players.index(player3)] += 1
                            team1_counts_dict[team1_players.index(player3)]['total'] += 1
                            team1_counts_dict[team1_players.index(player3)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            team1_counts_dict[team1_players.index(player3)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team1_counts_dict[team1_players.index(player3)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team1_counts_dict[team1_players.index(player3)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team1_counts_dict[team1_players.index(player3)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team1_counts_dict[team1_players.index(player3)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team1_counts_dict[team1_players.index(player3)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player3)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team1_counts_dict[team1_players.index(player3)]['play_log'].append(scan_play("J", "Team 1", player3, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                            team1_counts_dict[team1_players.index(player3)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player3)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.

                        else:
                            if player1 not in team2_players:
                                team2_players.append(player1)
                                team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                                team2_counts.append(0)
                            team2_counts[team2_players.index(player1)] += 1
                            team2_counts_dict[team2_players.index(player1)]['total'] += 1
                            team2_counts_dict[team2_players.index(player1)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            if r['event_type'].endswith("Goal") and team1_last_goalie is not None:
                                team1_counts_dict[team1_players.index(team1_last_goalie)]['goals_allowed'] += 1
                            team2_counts_dict[team2_players.index(player1)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team2_counts_dict[team2_players.index(player1)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team2_counts_dict[team2_players.index(player1)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team2_counts_dict[team2_players.index(player1)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team2_counts_dict[team2_players.index(player1)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team2_counts_dict[team2_players.index(player1)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player1)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team2_counts_dict[team2_players.index(player1)]['play_log'].append(scan_play("K", "Team 2", player1, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                            team2_counts_dict[team2_players.index(player1)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player1)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.

                            if player3 not in team2_players:
                                team2_players.append(player3)
                                team2_counts.append(0)
                                team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            team2_counts[team2_players.index(player3)] += 1
                            team2_counts_dict[team2_players.index(player3)]['total'] += 1
                            team2_counts_dict[team2_players.index(player3)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            team2_counts_dict[team2_players.index(player3)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team2_counts_dict[team2_players.index(player3)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team2_counts_dict[team2_players.index(player3)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team2_counts_dict[team2_players.index(player3)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team2_counts_dict[team2_players.index(player3)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team2_counts_dict[team2_players.index(player3)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player3)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team2_counts_dict[team2_players.index(player3)]['play_log'].append(scan_play("L", "Team 2", player3, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                            team2_counts_dict[team2_players.index(player3)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player3)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.

                    elif player in [None, ''] and player1 in [None, '']:
                        #print("Play: %s" % str(r))
                        #print("\tPlayer: %s\tPlayer1: %s\tPlayer2: %s\tPlayer 3: %s\n" % (player, player1, player2, player3))

                        if r['event_type'] not in ignore:
                            w_none += 1
                            if not r['event_type'].startswith("Faceoff"):
                                non_faceoff_w_none += 1
                        if r['event_type'] not in missed_plays and r['event_type'] not in ignore:
                            missed_plays.append(r['ID'])
                        if r['event_type'] not in ignore:
                            details_w_none.append({'play': r['event_type'],'team': r['team'],'details': play_obj['details']})
                    else:
                        if team1 == team:
                            if player not in team1_players:
                                team1_players.append(player)
                                team1_counts.append(0)
                                team1_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            team1_counts[team1_players.index(player)] += 1
                            team1_counts_dict[team1_players.index(player)]['total'] += 1
                            team1_counts_dict[team1_players.index(player)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            if r['event_type'].endswith("Goal") and team2_last_goalie is not None:
                                team2_counts_dict[team2_players.index(team2_last_goalie)]['goals_allowed'] += 1
                            team1_counts_dict[team1_players.index(player)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team1_counts_dict[team1_players.index(player)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team1_counts_dict[team1_players.index(player)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team1_counts_dict[team1_players.index(player)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team1_counts_dict[team1_players.index(player)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team1_counts_dict[team1_players.index(player)]['plays'][[z['play_type'] for z in team1_counts_dict[team1_players.index(player)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team1_counts_dict[team1_players.index(player)]['play_log'].append(scan_play("M", "Team 1", player, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                            team1_counts_dict[team1_players.index(player)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team1_counts_dict[team1_players.index(player)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.

                        else:
                            if player not in team2_players:
                                team2_players.append(player)
                                team2_counts.append(0)
                                team2_counts_dict.append({'saves': 0, 'goals_allowed': 0, 'ct': 0, 'total': 0, 'goals': 0, 'gbs': 0, 'shots': 0, 'penalties': 0, 'assists': 0, 'turnovers': 0, 'play_log': [], 'plays': [{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]], 'plays_by_quarter': [[{'play_type': z, 'cnt': 0.} for z in plays + ["Assist", "Caused Turnover", "Save"]] for y in range(10)]})
                            team2_counts[team2_players.index(player)] += 1
                            team2_counts_dict[team2_players.index(player)]['total'] += 1
                            team2_counts_dict[team2_players.index(player)]['goals'] += 1 if r['event_type'].endswith("Goal") else 0
                            if r['event_type'].endswith("Goal") and team1_last_goalie is not None:
                                team1_counts_dict[team1_players.index(team1_last_goalie)]['goals_allowed'] += 1
                            team2_counts_dict[team2_players.index(player)]['gbs'] += 1 if r['event_type'].startswith("Ground Ball") else 0
                            team2_counts_dict[team2_players.index(player)]['shots'] += 1 if r['event_type'].endswith("Shot") else 0
                            team2_counts_dict[team2_players.index(player)]['penalties'] += 1 if r['event_type'].startswith("Penalty") else 0
                            team2_counts_dict[team2_players.index(player)]['assists'] += 1 if r['event_type'] == "Assist" else 0
                            team2_counts_dict[team2_players.index(player)]['turnovers'] += 1 if "orced Turnover" in r['event_type'] else 0

                            team2_counts_dict[team2_players.index(player)]['plays'][[z['play_type'] for z in team2_counts_dict[team2_players.index(player)]['plays']].index(r['event_type'])]['cnt'] += 1.
                            team2_counts_dict[team2_players.index(player)]['play_log'].append(scan_play("N", "Team 2", player, {'quarter': play_obj['quarter'], 'regex': play_obj['regex'], 'play_type': r['event_type'], 'pct_complete': play_obj['pct_complete'], 'details': play_obj['details']}, play_obj))
                            team2_counts_dict[team2_players.index(player)]['plays_by_quarter'][play_obj['quarter']][[z['play_type'] for z in team2_counts_dict[team2_players.index(player)]['plays_by_quarter'][play_obj['quarter']]].index(r['event_type'])]['cnt'] += 1.
            
                    #print (team1_players)
            else:
                r['ignore_play'] = 1
            # Adjust based on the starting win odds based on ELO
            if pct_complete < 0:
                msg = "Error in game ID %s, a play had a negative pct_complete value\n\n%s" % (game_ID, str(r))
                
                
                if EXPORT_ERRORS:
                    print (msg)
                    errors.append({'type': 'Negative Pct Complete', 'code': 9, 'text': msg})
                    return {'success': 0, 'errors': errors}
                else:
                    msg += laxref.get_game_crash_info(game_ID)
                    zc.send_crash(msg, bot_token)
                    return None
                
            
            play_obj['game_state'] = game_state['state']
            play_obj['home_odds'] = r['odds']
            play_obj['away_odds'] = None if r['odds'] is None else (1-play_obj['home_odds'])
            play_obj['team_odds'] = play_obj['home_odds'] if play_obj['team_ID'] == home_ID else play_obj['away_odds']
            #print ("{:<30}{:<30}{:<30}{:<30}{:<30}{:<30}{:<30.3f}".format(home_ID, away_ID, play_obj['team'], play_obj['team_ID'], "HOME" if play_obj['team_ID'] == home_ID else "AWAY", game_state['state'], play_obj['team_odds']))
            
            play_obj['team_game_state'] = game_state['state'] if play_obj['team_ID'] == home_ID else -game_state['state']

            if "Penalty" in play_obj['details']:
                #zc.print_dict(play_obj)

                match = tregex.search(play_obj['play_type'])

                duration = 0
                if match:
                    if match.group(2) == "min":
                        duration = int(match.group(1))*60
                    else:
                        duration = int(match.group(1))

                    if '--extra-penalty-duration' in sys.argv:
                        duration += int(sys.argv[ sys.argv.index('--extra-penalty-duration') + 1])
                    else:
                        # 5 seconds seems to get us to a pretty good agreement between the derived and reported stats
                        duration += 5
                    penalty = {'hash': '%s%s' % (play_obj['opp'], play_obj['time_elapsed']), 'penalty_team': play_obj['team'], 'man_up_team': play_obj['opp'], 'releasable': None, 'time': convert_pct_complete_to_time_str(float(play_obj['time_elapsed'])/3600., game_obj['game_date'].year, game_obj['league']), 'start_time': play_obj['time_elapsed'], 'end_time': play_obj['time_elapsed'] + duration, 'remaining': duration}
                    #print man_up['hash'] if 'hash' in man_up else "", penalty['hash'], man_up['penalties'] == [], ('advantage' in man_up and man_up['advantage'] == play_obj['team'])
                    if man_up['penalties'] == [] or ('advantage' in man_up and man_up['advantage'] == play_obj['team']):
                        man_up['hash'] = penalty['hash']
                    man_up['penalties'].append(penalty)

                    #zc.print_dict(man_up)
                    #if '-pause' in sys.argv: raw_input("Added a penalty, click to continue...")
                    penalty_added = True




            play_obj['man_up'] = None; play_obj['penalty_remaining'] = None; man_up['advantage'] = None
            if man_up['penalties'] not in [[], None]:
                start_cnt = len(man_up['penalties'])
                lost_p = [z for z in man_up['penalties'] if z['end_time'] <= play_obj['time_elapsed']]

                man_up['penalties'] = [z for z in man_up['penalties'] if z['end_time'] > play_obj['time_elapsed']]
                end_cnt = len(man_up['penalties'])
                #if start_cnt != end_cnt:
                    #print "%d penalties fell out..." % (start_cnt - end_cnt)
                    #if '-pause' in sys.argv: zc.print_dict(lost_p)

                for pen in man_up['penalties']:
                    pen['remaining'] = pen['end_time'] - play_obj['time_elapsed']

                for tmp in [alt_home_team, alt_away_team]:
                    adv = len([1 for z in man_up['penalties'] if z['man_up_team'] == tmp]) - len([1 for z in man_up['penalties'] if z['man_up_team'] != tmp])
                    man_up["%s_advantage" % tmp] = adv
                    if adv > 0:
                        play_obj['man_up'] = tmp
                        man_up['advantage'] = tmp
                if man_up['penalties'] != []:
                    play_obj['penalty_remaining'] = min([z['remaining'] for z in man_up['penalties'] if z])
                else:
                    man_up['hash'] = None

                #zc.print_dict(man_up)
                #if '-pause' in sys.argv: raw_input("Processed man-up, click to continue...")

                if penalty_added and 'hash' in man_up and man_up['hash'] is not None and man_up['hash'] not in [z['hash'] for z in man_up_opportunities]:


                    if man_up['advantage'] is None: # This means that no team has an actual advantage, so an muo may have been lost
                        #print "EVAL MUOs B)"
                        if len(man_up_opportunities) > 0:
                            cur_muo = man_up_opportunities[-1]
                            last_penalty = man_up['penalties'][-1]
                            #zc.print_dict(cur_muo)
                            #zc.print_dict(last_penalty)

                            if cur_muo['advantage'] != last_penalty['man_up_team']:
                                if cur_muo['start_time'] < last_penalty['start_time'] < cur_muo['end_time']:
                                    #Penalties were not offsetting
                                    #print "Terminated the previous MUO early because advantage was lost."
                                    man_up_opportunities[-1]['end_time'] = last_penalty['start_time']
                                elif cur_muo['start_time'] == last_penalty['start_time']:
                                    #Penalties were offsetting, so remove the muo we added previously
                                    #print "Popped off the previous MUO because it was offsetting penalties."
                                    man_up_opportunities = man_up_opportunities[0:-1]
                                    for p in man_up['penalties']:
                                        if p['start_time'] == last_penalty['start_time']:
                                            #print "Set penalty with hash %s to 0 sec remaining." % p['hash']
                                            p['remaining'] = 0
                                            p['end_time'] = last_penalty['start_time']

                                #if '-pause' in sys.argv: raw_input("Dealt with a lost advantage...")


                    else:
                        #print "EVAL MUOs A)"
                        conf_team = confirmed_away_team if play_obj['team'] == alt_home_team else confirmed_home_team
                        team_ID = away_ID if play_obj['team'] == alt_home_team else home_ID
                        opp_ID = away_ID if play_obj['team'] != alt_home_team else home_ID
                        team_type = "home" if play_obj['team'] == alt_home_team else "away"
                        muo = {'ID': len(man_up_opportunities) + 1, 'team_odds': play_obj['%s_odds' % team_type], 'time': convert_pct_complete_to_time_str(float(play_obj['time_elapsed'])/3600., game_obj['game_date'].year, game_obj['league']), 'start_time': play_obj['time_elapsed'], 'end_time': play_obj['time_elapsed']+duration, 'team': conf_team, 'opp_ID': opp_ID, 'team_ID': team_ID, 'hash': man_up['hash'], 'advantage': man_up['advantage']}
                        man_up_opportunities.append(muo)



            play_obj['play_ID'] = play_ID
            if play_obj['details'] not in ['Timeout by Media.', 'penalty by targeting.', 'empty net, foul by keeper.', 'empty net, foul by keeper ', 'Unsportsmanlike by the bench.'] and 'asst coach' not in play_obj['details']:
                if play_obj['play_type'] not in plays_to_ignore and 'player' not in play_obj:
                    
                    msg = "Could not identify the player from this play:\n\n%s" % zc.print_dict(play_obj)

                    if EXPORT_ERRORS:
                        print (msg)
                        errors.append({'type': 'Player could not be identified from details', 'code': 12, 'text': msg})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(msg, bot_token)
                        return None
                play_obj['seq'] = len(plays_list)+1
                if 'ignore_play' in r:
                    play_obj['ignore_play'] = r['ignore_play']
                    
                # Shooting EGA is used downstream, so it's easier to simply add it to the play object here (will use a sum flag in the play_quals accumulator)
                play_obj['shooting_EGA'] = 0.
                if play_obj['play_type'] == "Assisted Goal":
                    play_obj['shooting_EGA'] = 1.0 + (play_values_for[plays.index("Assisted Goal")] - play_values_against[plays.index("Assisted Goal")])
                elif play_obj['play_type'] == "Unassisted Goal":
                    play_obj['shooting_EGA'] = 1.0 + (play_values_for[plays.index("Unassisted Goal")] - play_values_against[plays.index("Unassisted Goal")])
                elif play_obj['play_type'].endswith(" Goal") or play_obj['play_type'].endswith(" Shot"):
                    play_obj['shooting_EGA'] = (play_values_for[plays.index(play_obj['play_type'])] - play_values_against[plays.index(play_obj['play_type'])])
                
                plays_list.append(play_obj)

            if play_obj['play_type'].endswith("Goal"):
                # Check if any current penalties need to be released
                if man_up['penalties'] not in [[], None]:
                    goal_team = play_obj['team']
                    for z in man_up['penalties']:
                        if z['penalty_team'] != goal_team and z['releasable'] in [1, None]:
                            z['end_time'] = play_obj['time_elapsed']
                            z['remaining'] = 0


                    man_up['penalties'] = [z for z in man_up['penalties'] if not (z['penalty_team'] != goal_team and z['releasable'] in [1, None])]
        
        if show_cgd_timedstamps:
            print("     {:<95}{:<15}".format("Begin player stat summaries...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
        
        # Remove any plays that were meant to be ignored (i.e. unsportsmanlike conduct play entries)
        plays_list = [z for z in plays_list if 'ignore_play' not in z or not z['ignore_play']]
        
        timestamps['Process individual play records'] = time.time()
        steps.append({'step': 'Create plays list', 'time': time.time()})

       
            
        if '--kill-after-creating-possessions' in sys.argv: zc.exit("laxref0068")
        suffixes = ['', '1', '2', '3']

        if '-debug' in sys.argv: print ("Team 1\n--------------------------------------------------")
        for a, b, c in zip(team1_players, team1_counts_dict, team1_counts):
            if '-debug' in sys.argv: print ("{:<30}{:<20}{:>10}".format(a, "", c))

        if '-debug' in sys.argv: print ("Team 2\n--------------------------------------------------")
        for a, b, c in zip(team2_players, team2_counts_dict, team2_counts):
            if '-debug' in sys.argv: print ("{:<30}{:<20}{:>10}".format(a, "", c))

        if '-debug' in sys.argv: print ("Team 3\n--------------------------------------------------")

        go_on = True; go_on_loops = 1
        
        """
        zc.print_dict(game_obj)
        print ("Team1: %s" % team1)
        print ("Team2: %s" % team2)
        print ("Away: %s" % away_team)
        print ("Home: %s" % home_team)
        print ("Confirmed Away: %s" % confirmed_away_team)
        print ("Confirmed Home: %s" % confirmed_home_team)
        print ("Alt Away: %s" % alt_away_team)
        print ("Alt Home: %s" % alt_home_team)
        print ("Away ID: %s" % away_ID)
        print ("Home ID: %s" % home_ID)
        team1_ID = None
        team2_ID = None
        print ("team1_ID: %s" % team1_ID)
        print ("team2_ID: %s" % team2_ID)
        zc.exit("Team Codes")
        """
        while go_on:
            go_on = 0
            #print "Looping Team 3 #%d..." % go_on_loops
            for i, (a, b, c, d) in enumerate(zip(team3_players, team3_opps, team3_counts, team3_counts_dict)):
                if a != "Resolved":

                    acct = "no"
                    team = ""

                    if (game_date.year, a.lower(), team1.lower()) in [(z['year'], z['player'].lower(), z['confirmed_team'].lower()) for z in manual_player_teams if'confirmed_team' in z]:
                        acct = "yes"
                        team = "1"

                    elif (game_date.year, a.lower(), team2.lower()) in [(z['year'], z['player'].lower(), z['confirmed_team'].lower()) for z in manual_player_teams if'confirmed_team' in z]:
                        acct = "yes"
                        team = "2"

                    elif b is None and (a in team1_players and a not in team2_players):
                        acct = "yes"
                        team = "1"
                    elif b is None and (a in team2_players and a not in team1_players):
                        acct = "yes"
                        team = "2"
                    elif b is not None and (a in team1_players and a not in team2_players):
                        acct = "yes"
                        team = "1"
                    elif b is not None and (a in team2_players and a not in team1_players):
                        acct = "yes"
                        team = "2"
                    elif b is not None and (b in team1_players and b not in team2_players):
                        acct = "yes"
                        team = "2"
                    elif b is not None and (b in team2_players and b not in team1_players):
                        acct = "yes"
                        team = "1"
                    elif is_player_on_team(a, team1, game_date.year):
                        acct = "yes"; team = "1"
                    elif is_player_on_team(a, team2, game_date.year):
                        acct = "yes"; team = "2"
                    elif is_player_on_team_from_json(a, home_ID, game_obj['league'], game_date.year):
                        acct = "yes"; team = "1"
                    elif is_player_on_team_from_json(a, away_ID, game_obj['league'], game_date.year):
                        acct = "yes"; team = "2"
                    else:
                        unique_plays = list(set([z['play_type'] for z in d['play_log'] if 'team' in z]))
                        unique_teams = list(set([z['team'] for z in d['play_log'] if 'team' in z]))
                        if len(unique_plays) == 1 and unique_plays[0] == "Ground Ball":
                            if len(unique_teams) == 1:
                                if unique_teams[0] == team1:
                                    team = "1"
                                    acct = "yes"
                                else:
                                    team = "2"
                                    acct = "yes"

                    #print ("{:<30}{:<30}{:>10}{:>10}{:>10}".format(a, b, c, acct, team))


                    if team == "1":
                        if a in team1_players:
                            team1_counts[team1_players.index(a)] += c
                            team1_counts_dict[team1_players.index(a)]['play_log'] += d['play_log']

                        else:
                            team1_counts.append(c)
                            team1_players.append(a)
                            team1_counts_dict.append(d)
                        team3_players[i] = "Resolved"
                        go_on = 1
                    elif team == "2":
                        if a in team2_players:
                            team2_counts[team2_players.index(a)] += c
                            team2_counts_dict[team2_players.index(a)]['play_log'] += d['play_log']

                        else:
                            team2_counts.append(c)
                            team2_players.append(a)
                            team2_counts_dict.append(d)
                        team3_players[i] = "Resolved"
                        go_on = 1

            go_on_loops += 1
        
        has_unresolved_players = 0
        for i, (a, b, c, d) in enumerate(zip(team3_players, team3_opps, team3_counts, team3_counts_dict)):
            if a != "Resolved":
                has_unresolved_players = 1
                print ("Unresolved: %s vs %s" % (a, b))
                
            
        if '-debug' in sys.argv: print ("Team 1 (Final)\n--------------------------------------------------")


        for a, b, c in zip(team1_players, team1_counts_dict, team1_counts):
            if '-debug' in sys.argv: print ("{:<30}{:<20}{:>10}".format(a, "", c))
            if len([1 for z in b['play_log'] if 'team' in z]) > 0:
                b['play_log'] = [z for z in b['play_log'] if 'team' not in z or z['team'] == team1]


        if '-debug' in sys.argv: print ("Team 2 (Final)\n--------------------------------------------------")
        for a, b, c in zip(team2_players, team2_counts_dict, team2_counts):
            if '-debug' in sys.argv: print ("{:<30}{:<20}{:>10}".format(a, "", c))
            if len([1 for z in b['play_log'] if 'team' in z]) > 0:
                b['play_log'] = [z for z in b['play_log'] if 'team' not in z or z['team'] == team2]


        if len([1 for z in team3_players if z not in ["", None, "Resolved"]]) > 0 and "C:" not in piFolder:
            msg = "Error, there were players assigned to team3 (Faceoff scenarios) that we could not assign to a team...\n"
            for i, (a, b, c, d) in enumerate(zip(team3_players, team3_opps, team3_counts, team3_counts_dict)):
                if a not in ["", None, "Resolved"]:

                    msg += "{:<30}{:<30}{:>10}\n".format(a, b, c)
                    if 'python' not in msg:
                        msg += ("\n\n\t\tpython identify_clutch_statistics.py -update -game %s -debug --refresh-game-dict --player-of-interest '%s'" % (game_ID, a))



            if EXPORT_ERRORS:
                print (msg)
                errors.append({'type': 'Faceoff players could not be tagged to either team', 'code': 10, 'text': msg})
                return {'success': 0, 'errors': errors}
            else:
                zc.send_crash(msg, bot_token)
                return None


        steps.append({'step': 'Add players to team dicts', 'time': time.time()})

        for p in plays_list:


            for suffix in suffixes:
                if 'player%s' % suffix in p and p['player%s_team' % suffix] in ['', None, "???"] and p['player%s' % suffix] not in ['', None, "???"]:
                    #print("Is %s/%s or %s/%s in the manual_players list?" % (p['player%s' % suffix], adj_home, p['player%s' % suffix], adj_away))
                    tup1 = (p['player%s' % suffix].lower().strip(), adj_home, game_date.year)
                    tup2 = (p['player%s' % suffix].lower().strip(), adj_away, game_date.year)
                    tup3 = (p['player%s' % suffix].lower().strip(), alt_home_team, game_date.year)
                    tup4 = (p['player%s' % suffix].lower().strip(), alt_away_team, game_date.year)
                    if tup1 in [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams]:
                        p['player%s_team' % suffix] = manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup1) ]['team']
                        #print("a. Set %s's team to %s" % (p['player%s' % suffix], manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup1) ]['team']))
                    elif tup2 in [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams]:
                        p['player%s_team' % suffix] = manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup2) ]['team']
                        #print("b. Set %s's team to %s" % (p['player%s' % suffix], manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup2) ]['team']))
                    elif tup3 in [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams]:
                        p['player%s_team' % suffix] = manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup3) ]['team']
                        #print("c. Set %s's team to %s" % (p['player%s' % suffix], manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup3) ]['team']))
                    elif tup4 in [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams]:
                        p['player%s_team' % suffix] = manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup4) ]['team']
                        #print("d. Set %s's team to %s" % (p['player%s' % suffix], manual_player_teams[ [(z['player'].lower().strip(), z['team'], z['year']) for z in manual_player_teams].index(tup4) ]['team']))

        timestamps['Set manual player team assignments'] = time.time()
        steps.append({'step': 'Set manual player team assignments', 'time': time.time()})


        # Confirm team assignments

        # Loop through 5 times

        for zx in range(5):
            idx = 1
            updates_made = 0
            non_ignored_plays = [z for z in plays_list if z['play_type'] not in plays_to_ignore]
            faceoff_win_plays = [z for z in plays_list if z['play_type'] == "Faceoff Win"]

            updates = []

            for p in faceoff_win_plays:
                    # For each faceoff, check on some standard scenarios

                    # 1st 2: If one of the FOGOs is unknown, assign teams based on who won the faceoff (i.e. p['team'])
                    # 2nd 2: If the FOGO player team is unknown but it they picked up the GB, assign their team based on who won the faceoff (i.e. p['team'])

                    if p['player1_team'] == "???" and p['player2_team'] != "???":
                        u = {'player': p['player1'], 'team': p['opp'] if p['player2_team'] == p['team'] else p['team']}
                        if u not in updates: updates.append(u)
                    elif p['player1_team'] != "???" and p['player2_team'] == "???":
                        u = {'player': p['player2'], 'team': p['opp'] if p['player1_team'] == p['team'] else p['team']}
                        if u not in updates: updates.append(u)

                    elif p['player2_team'] == "???" and p['player3_team'] != "???" and p['player2'] == p['player3']:
                        u = {'player': p['player2'], 'team': p['player3_team']}
                        if u not in updates: updates.append(u)
                    elif p['player1_team'] == "???" and p['player3_team'] != "???" and p['player1'] == p['player3']:
                        u = {'player': p['player1'], 'team': p['player3_team']}
                        if u not in updates: updates.append(u)

            if updates != []:
                for p in non_ignored_plays:
                        for suffix in suffixes:
                            if 'player%s_team' % suffix in p and p['player%s_team' % suffix] == "???":

                                if p['player%s' % suffix] in [z['player'] for z in updates]:
                                    plays_list[ [y['seq'] for y in plays_list].index(p['seq']) ]['player%s_team' % suffix] = updates[ [z['player'] for z in updates].index(p['player%s' % suffix]) ]['team']
                                    updates_made += 1

            for p in faceoff_win_plays:



                    for suffix in suffixes:
                        if p['player%s' % suffix] not in ['', None, home_team_name, away_team_name]:
                            team_options = list(set(
                              [z['player_team'] for z in non_ignored_plays if z['player'] not in [None, ''] and 'player%s' % suffix in p and p['player%s' % suffix] == z['player']]
                            + [z['player1_team'] for z in non_ignored_plays if z['player1'] not in [None, ''] and 'player%s' % suffix in p and p['player%s' % suffix] == z['player1']]
                            + [z['player2_team'] for z in non_ignored_plays if z['player2'] not in [None, ''] and 'player%s' % suffix in p and p['player%s' % suffix] == z['player2']]
                            + [z['player3_team'] for z in non_ignored_plays if z['player3'] not in [None, ''] and 'player%s' % suffix in p and p['player%s' % suffix] == z['player3']]

                            ))
                            team_options = [z for z in team_options if z not in ['', '???']]
                            if len(team_options) == 1:
                                if p['player%s' % suffix] not in [z['player'] for z in updates]:
                                    u = {'player': p['player%s' % suffix], 'team': team_options[0]}
                                    if u not in updates: updates.append(u)
            if updates != []:
                for p in non_ignored_plays:
                    for suffix in suffixes:
                        if p['player%s_team' % suffix] == "???":

                            if p['player%s' % suffix] in [z['player'] for z in updates]:
                                plays_list[ [y['seq'] for y in plays_list].index(p['seq']) ]['player%s_team' % suffix] = updates[ [z['player'] for z in updates].index(p['player%s' % suffix]) ]['team']
                                updates_made += 1

            for p in faceoff_win_plays:

                    if p['player1_team'] == "???" and p['player2_team'] != "???":
                        u = {'player': p['player1'], 'team': p['opp'] if p['player2_team'] == p['team'] else p['team']}
                        if u not in updates: updates.append(u)
                    elif p['player1_team'] != "???" and p['player2_team'] == "???":
                        u = {'player': p['player2'], 'team': p['opp'] if p['player1_team'] == p['team'] else p['team']}
                        if u not in updates: updates.append(u)
            

            if updates != []:
                for p in non_ignored_plays:
                    for suffix in suffixes:
                        if p['player%s_team' % suffix] == "???":

                            if p['player%s' % suffix] in [z['player'] for z in updates]:
                                plays_list[ [y['seq'] for y in plays_list].index(p['seq']) ]['player%s_team' % suffix] = updates[ [z['player'] for z in updates].index(p['player%s' % suffix]) ]['team']
                                updates_made += 1
            
            for p in faceoff_win_plays:
                    for suffix in suffixes:

                        if p['player%s' % suffix] not in ['', None, home_team_name, away_team_name]:
                            tmp = [z for z in plays_list if 'player' not in z]
                            if len(tmp) > 0:
                                zc.print_dict(tmp)
                                zc.exit("Player Key error")
                            #Search all the other plays where this player is identified to see if there is a match
                            
                            team_options = list(set(
                              [z['player_team'] for z in plays_list if z['player'] not in [None, ''] and z['play_type'] not in plays_to_ignore and p['player%s' % suffix] == z['player']]
                            + [z['player1_team'] for z in plays_list if z['player1'] not in [None, ''] and z['play_type'] not in plays_to_ignore and p['player%s' % suffix] == z['player1']]
                            + [z['player2_team'] for z in plays_list if z['player2'] not in [None, ''] and z['play_type'] not in plays_to_ignore and p['player%s' % suffix] == z['player2']]
                            + [z['player3_team'] for z in plays_list if z['player3'] not in [None, ''] and z['play_type'] not in plays_to_ignore and p['player%s' % suffix] == z['player3']]

                            ))
                            team_options = [z for z in team_options if z not in ['', '???']]

                            if len(team_options) == 1:
                                if p['player%s' % suffix] not in [z['player'] for z in updates]:
                                    u = {'player': p['player%s' % suffix], 'team': team_options[0]}
                                    if u not in updates: updates.append(u)

            if updates != []:
                
                for p in non_ignored_plays:
                    for suffix in suffixes:
                        if p['player%s_team' % suffix] == "???":

                            if p['player%s' % suffix] in [z['player'] for z in updates]:
                            
                                plays_list[ [y['seq'] for y in plays_list].index(p['seq']) ]['player%s_team' % suffix] = updates[ [z['player'] for z in updates].index(p['player%s' % suffix]) ]['team']
                                updates_made += 1
                            

            # If there were no more updates being made, exit because we've taken it as far as possible using play data
            if updates_made == 0: break
        steps.append({'step': 'Confirm FOGO team assignments', 'time': time.time()})
        
        kill = False
        plays_list = [z for z in plays_list if z['play_type'] not in plays_to_ignore]
        err_sent = False
        err_written = []
        manual_entries = {}
        clarification_link_sent = []
        for p in plays_list:
         
            for suffix in suffixes:

                if (game_ID is not None and  p['player%s_team' % suffix] in [None, "", "???"]
                and p['player%s' % suffix].strip() not in ["Resolved", home_team, away_team, alt_home_team, alt_away_team, '']):
                    
                    
                    if p['player%s' % suffix] in manual_entries:

                        p['player%s_team' % suffix] = manual_entries[p['player%s' % suffix]]

                    else:
                        print("\n\n\tHaven't yet found the team for %s (date: %s)" % (p['player%s' % suffix], game_date))
                        print("\t\tTeams: %s" % (";".join([home_team, away_team, alt_home_team, alt_away_team])))
                        zc.print_dict(p)
                        search_url = "https://search.yahoo.com/search?p={}&fr=yfp-t&ei=UTF-8&fp=1".format(("%s lacrosse roster %d " % (p['player%s' % suffix], game_date.year)).replace(" ", "+"))
                        print("\t\tpython identify_clutch_statistics.py -update -game %s -debug --refresh-game-dict --player-of-interest '%s'" % (game_ID, p['player%s' % suffix]))
                        msg = "In %d, who did %s play for?\n\n%s: respond HOME\n%s: respond AWAY\n\nOR respond -1 to kill: %s" % (game_date.year, p['player%s' % suffix], home_team, away_team, search_url)
                        print (msg)
                        
                        tmp_cursor = zc.zcursor("LR")
                        tmp_teams = tmp_cursor.dqr("SELECT b.team_ID from LaxRef_Players a, LaxRef_Player_Seasons b where b.player_ID=a.ID and b.year=%s and lower(trim(a.player))=%s", [game_date.year, p['player%s' % suffix].lower().strip()])
                        tmp_cursor.close()
                        
                        is_home = None
                        if len(tmp_teams) == 1:
                            print ("Home ID: %d" % home_ID)
                            print ("Away ID: %d" % away_ID)
                            if home_ID == tmp_teams[0]['team_ID']:
                                is_home = 1
                            elif away_ID == tmp_teams[0]['team_ID']:
                                is_home = 0
                                
                            
                            
                        if is_home is not None:
                            p['player%s_team' % suffix] = home_team if is_home else away_team
                            manual_entries[p['player%s' % suffix]] = p['player%s_team' % suffix]
                            if datetime.now().year > 2024:
                                zc.send_telegram("It was unclear who %s played for, but the DB showed one player season record matching that name, so they've been assigned to %s" % (p['player%s' % suffix], p['player%s_team' % suffix]),bot_token)
                            
                        else:
                            if p['player%s' % suffix] not in clarification_link_sent:
                                request_msg = "Use the link below to specify which team %s plays for (from game ID %s)\n\n" % (p['player%s' % suffix], game_ID)
                                request_msg += "https://pro.lacrossereference.com/admin_add_player_season?year={}&team1_ID={}&team2_ID={}&player={}".format(game_date.year, home_ID, away_ID, p['player%s' % suffix].replace(" ", "%20"))
                                request_msg += "\n\nLocal Version: localhost:8080/admin_add_player_season?year={}&team1_ID={}&team2_ID={}&player={}".format(game_date.year, home_ID, away_ID, p['player%s' % suffix].replace(" ", "%20"))
                                print (request_msg)
                                zc.send_telegram(request_msg, bot_token)#, {'subject': "Need LR Player Clarification: %s" % p['player%s' % suffix]})
                                clarification_link_sent.append(p['player%s' % suffix])
                            """break
                            
                            zc.exit('request-msg2312321')
                            
                            is_home = ask_for_player_team_clarification(msg).upper().strip()
                            if is_home in ["HOME", 'AWAY']:
                                p['player%s_team' % suffix] = home_team if is_home == "HOME" else away_team
                                manual_entries[p['player%s' % suffix]] = p['player%s_team' % suffix]
                                zc.send_telegram("Ok, %s has been assigned to %s" % (p['player%s' % suffix], p['player%s_team' % suffix]),bot_token)
                            else:
                                kill = True; break
                            """
            if kill: break
        

        if kill: zc.send_telegram("Ok, processing has stopped.", bot_token); zc.exit("laxref0070")


        # Add FO Losses to the play log for the loser
        for player_name, player_object in zip(team1_players, team1_counts_dict):

            fos = [z for z in player_object['play_log'] if z['play_type'] == ("Faceoff Win")]
            if len(fos) > 0:
                #print ("A) Player: %s won %d faceoffs" % (player_name, len(fos)))

                for fo in fos:
                    for alt_player_name, alt_player_object in zip(team2_players, team2_counts_dict):
                        if 'opp' not in fo:
                            msg = 'FO Opponent not identified: %s' % (str(fo))
                            errors.append({'type': 'FO Opponent not identified', 'code': 1092, 'text': msg})
                            return {'success': 0, 'errors': errors}
                        if alt_player_name != player_name and alt_player_name == fo['opp']:
                            d = {'fp_shot': 0, 'play_type': "Faceoff Loss", 'FOGO': 1}
                            for k in ['pct_complete', 'quarter', 'regex']:
                                d[k] = fo[k]
                            alt_player_object['play_log'].append(d)
                            
                            #print ("\n%s\nA) %s won a faceoff against %s" % (fo['details'], player_name, fo['opp']))
                            break
        
        for player_name, player_object in zip(team2_players, team2_counts_dict):

            fos = [z for z in player_object['play_log'] if z['play_type'] == ("Faceoff Win")]
            if len(fos) > 0:
                #print ("B) Player: %s won %d faceoffs" % (player_name, len(fos)))

                for fo in fos:
                    for alt_player_name, alt_player_object in zip(team1_players, team1_counts_dict):
                        if alt_player_name != player_name and alt_player_name == fo['opp']:
                            d = {'fp_shot': 0, 'play_type': "Faceoff Loss", 'FOGO': 1}
                            for k in ['pct_complete', 'quarter', 'regex']:
                                d[k] = fo[k]
                            alt_player_object['play_log'].append(d)
                            #print ("\n%s\nB) %s won a faceoff against %s" % (fo['details'], player_name, fo['opp']))
                            break



        timestamps['Set unassigned player teams'] = time.time()
        steps.append({'step': 'Check for missing FOGO teams', 'time': time.time()})

        
        #print("Success!!!!")
        #zc.exit("laxref0071")
        split = None
        stretch = None
        if show_cgd_timedstamps:
            print("     {:<95}{:<15}".format("Begin team stat summaries...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
        
        stat_summaries_keys = []
        stat_summaries_keys.append({'key':  'total_shots_variance', 'fmt': ''})
        stat_summaries_keys.append({'key':  'unforced_turnovers', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Unforced Turnover"))})
        stat_summaries_keys.append({'key':  'faceoff_conversions', 'fmt': '', 'faceoff_quals': lambda x:'converted_to_possession' in x and x['converted_to_possession']})
        stat_summaries_keys.append({'key':  'fo_conv_fails', 'fmt': '', 'faceoff_quals': lambda x: not 'converted_to_possession' in x or not x['converted_to_possession']})
            
        stat_summaries_keys.append({'key':  'multiple_shot_possession_rate', 'fmt': '', 'formula': {'op': 'divide', 'num': 'multiple_shot_possessions', 'denom': 'possessions'}})
        stat_summaries_keys.append({'key':  'assist_rate', 'fmt': '', 'formula': {'op': 'divide', 'num': 'assists', 'denom': 'goals'}})
        stat_summaries_keys.append({'key':  'assist_to_turnover_ratio', 'fmt': '', 'formula': {'op': 'divide', 'num': 'assists', 'denom': 'turnovers'}})
        #stat_summaries_keys.append({'key':  'modified_possession_margin', 'fmt': '', 'formula': {'op': 'margin', 'var': 'possessions'}})
        stat_summaries_keys.append({'key':  'possession_margin', 'fmt': '', 'formula': {'op': 'margin', 'var': 'possessions'}})
        stat_summaries_keys.append({'opp': True, 'key':  'saves', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Saved Shot"))})
        stat_summaries_keys.append({'key':  'shooting_EGA', 'fmt': '', 'sum': 'shooting_EGA', 'play_quals': lambda x:(x['play_type'].endswith(" Shot") or x['play_type'].endswith(" Goal"))})
        stat_summaries_keys.append({'key':  'weirdness', 'fmt': ''})
        stat_summaries_keys.append({'key':  'shots_per_possession', 'fmt': '', 'formula': {'op': 'divide', 'num': 'shots', 'denom': 'possessions'}})
        stat_summaries_keys.append({'key':  'gb_win_rate', 'fmt': '', 'formula': {'op': 'share', 'var': 'gbs'}})
        stat_summaries_keys.append({'key':  'time_per_possession', 'fmt': '', 'formula': {'op': 'divide', 'num': 'total_top', 'denom': 'possessions'}})
        stat_summaries_keys.append({'key':  'total_possessions','fmt': '', 'poss_quals': lambda x:(not x['removed'] and not x['failed_clear'])})
        stat_summaries_keys.append({'key':  'failed_clears', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Failed Clear"))})
        stat_summaries_keys.append({'key':  'good_clears', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Good Clear"))})
        stat_summaries_keys.append({'opp': True, 'key':  'fc_forced', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Failed Clear"))})
        stat_summaries_keys.append({'key':  'poss_plus_clears', 'fmt': '', 'poss_quals': lambda x:(not x['removed'])})
        stat_summaries_keys.append({'key':  'total_groundballs_variance', 'fmt': ''})
        stat_summaries_keys.append({'key':  'fo_pct', 'fmt': '', 'formula': {'op': 'share', 'var': 'faceoffs'}})
        stat_summaries_keys.append({'key':  'sog', 'fmt': '', 'play_quals': lambda x:(x['play_type'] in ["Pipe Shot", "Saved Shot"] or x['play_type'].endswith("Goal"))})
        stat_summaries_keys.append({'key':  'on_keeper_shots', 'fmt': '', 'play_quals': lambda x:(x['play_type'] in ["Saved Shot"] or x['play_type'].endswith("Goal"))})
        stat_summaries_keys.append({'key':  'saved_shots', 'fmt': '', 'play_quals': lambda x:(x['play_type'] in ["Saved Shot"])})
        stat_summaries_keys.append({'key':  'possessions', 'fmt': '', 'poss_quals': lambda x:(not x['removed'] and not x['failed_clear'])})
        stat_summaries_keys.append({'key':  'attribution_class_cnts', 'fmt': ''})
        stat_summaries_keys.append({'key':  'turnover_rate', 'fmt': '', 'formula': {'op': 'divide', 'num': 'turnovers', 'denom': 'possessions'}})
        stat_summaries_keys.append({'key':  'turnovers', 'fmt': '', 'poss_quals': lambda x:(x['turnover'] and not x['removed'] and not x['failed_clear'])})
        
        if '--print-possessions' in sys.argv:
            fmt = "z{:<10}{:<10.0f}{:<7}{:<12}{:<12}{:<12}".replace(".0f", "")
            print (fmt.format("Start", "Duration", "teamID", 'Goal', 'Turnover', 'Failed Clear'))
            print ("-" * 150)
            print (sorted(possessions[0].keys()))
            for i, p in enumerate(possessions):
                
                if '--print-possessions' in sys.argv:
                    if '--team-ID' in sys.argv and int(sys.argv[sys.argv.index('--team-ID') + 1]) == p['team_ID']:
                        print (fmt.format(convert_pct_complete_to_time_str(p['start_time']/3600., datetime.now().year, "NCAA D1 Men"), "", p['team_ID'], "YES" if p['goal_scored'] else "", "YES" if p['turnover'] else "", "YES" if p['failed_clear'] else "")    )
                    elif '--team-ID' not in sys.argv:
                        print (fmt.format(convert_pct_complete_to_time_str(p['start_time']/3600., datetime.now().year, "NCAA D1 Men"), "", p['team_ID'], "YES" if p['goal_scored'] else "", "YES" if p['turnover'] else "", "YES" if p['failed_clear'] else "")    )
                
        stat_summaries_keys.append({'key':  'total_top', 'fmt': '', 'poss_quals': lambda x:(not x['removed'] and sum(x['weird'])==0), 'poss_agg': {'op': 'sum', 'var': 'duration'}})
        stat_summaries_keys.append({'key':  'top', 'fmt': '', 'formula': {'op': 'share', 'var': 'total_top'}})
        stat_summaries_keys.append({'opp': True, 'key':  'def_efficiency', 'fmt': '', 'formula': {'op': 'divide', 'num': 'goals', 'denom': 'possessions'}})
        stat_summaries_keys.append({'key':  'faceoffs', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Faceoff Win"))})
        stat_summaries_keys.append({'key':  'sum_fo', 'fmt': ''})
        stat_summaries_keys.append({'opp': True, 'key':  'save_pct', 'fmt': '', 'formula': {'op': 'divide', 'num': 'saved_shots', 'denom': 'sog'}})
        stat_summaries_keys.append({'opp': False, 'key':  'saved_shot_pct', 'fmt': '', 'formula': {'op': 'divide', 'num': 'saved_shots', 'denom': 'sog'}})
        stat_summaries_keys.append({'key':  'avg_time_to_shot', 'fmt': '', 'formula': {'op': 'divide', 'num': 'total_time_to_shot', 'denom': 'poss_w_shot'}})
        stat_summaries_keys.append({'key':  'total_time_to_shot', 'fmt': '', 'poss_quals': lambda x:(not x['removed'] and x['before_shot'] is not None and x['before_shot'] > 0), 'poss_agg': {'op': 'sum', 'var': 'before_shot'}})
        stat_summaries_keys.append({'key':  'second_chance_possessions', 'fmt': '', 'poss_quals': lambda x:(not x['removed'] and 'is_2nd_chance' in x and x['is_2nd_chance'])})
        stat_summaries_keys.append({'key':  'second_chance_goals', 'fmt': '', 'poss_quals': lambda x:(not x['removed'] and x['goal'] and 'is_2nd_chance' in x and x['is_2nd_chance'])})
        stat_summaries_keys.append({'key':  'poss_w_shot', 'fmt': '', 'poss_quals': lambda x:(not x['removed'] and x['before_shot'] is not None and x['before_shot'] > 0)})
        stat_summaries_keys.append({'key':  'multiple_shot_possessions', 'fmt': '', 'poss_quals': lambda x:(not x['removed'] and x['total_shots'] > 1)})
        stat_summaries_keys.append({'key':  'forced_turnovers', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Forced Turnover"))})
        stat_summaries_keys.append({'key':  'goals', 'fmt': '', 'play_quals': lambda x:(x['play_type'].endswith("Goal"))})
        stat_summaries_keys.append({'key':  'man_up_goals', 'fmt': '', 'play_quals': lambda x:(x['play_type'].endswith("Goal") and x['man_up'] == x['team'])})
        stat_summaries_keys.append({'key':  'man_down_goals', 'fmt': '', 'play_quals': lambda x:(x['play_type'].endswith("Goal") and x['man_up'] not in [None, x['team']])})
        stat_summaries_keys.append({'key':  'man_up_chances', 'fmt': '', 'man_up_quals': lambda x:(1)})
        if 1 or '--test-TGS-FP' in sys.argv:
            stat_summaries_keys.append({'key':  'fp_attempts', 'fmt': '', 'free_position_quals': lambda x:(1)})
            stat_summaries_keys.append({'key':  'fp_goals', 'fmt': '', 'free_position_quals': lambda x:x['fp_goal']})
            stat_summaries_keys.append({'key':  'fp_shots', 'fmt': '', 'free_position_quals': lambda x:x['fp_shot']})
            stat_summaries_keys.append({'key':  'fp_shots_off_one_pass', 'fmt': '', 'free_position_quals': lambda x:not x['fp_shot'] and x['shots_taken']})
            stat_summaries_keys.append({'key':  'free_position_shot_taken', 'fmt': '', 'free_position_quals': lambda x: x['fp_shot'] or x['fp_shot_taken']})
            
            # fp_efficiency			
            stat_summaries_keys.append({'key':  'fp_efficiency', 'fmt': '', 'formula': {'op': 'divide', 'num': 'fp_goals', 'denom': 'fp_attempts'}})
            stat_summaries_keys.append({'key':  'fp_utilization', 'fmt': '',  'formula': {'op': 'divide', 'num': 'free_position_shot_taken', 'denom': 'fp_attempts'}})
            stat_summaries_keys.append({'key':  'fp_shooting_pct', 'fmt': '', 'formula': {'op': 'divide', 'num': 'fp_goals', 'denom': 'free_position_shot_taken'}})
            stat_summaries_keys.append({'key':  'fp_shooter_pct', 'fmt': '', 'formula': {'op': 'divide', 'num': 'fp_shots', 'denom': 'free_position_shot_taken'}})
            
            
        stat_summaries_keys.append({'key':  'bad_plays', 'fmt': ''})
        stat_summaries_keys.append({'key':  'shooting_pct', 'fmt': '', 'formula': {'op': 'divide', 'num': 'goals', 'denom': 'shots'}})
        stat_summaries_keys.append({'key':  'on_goal_shooting_pct', 'fmt': '', 'formula': {'op': 'divide', 'num': 'goals', 'denom': 'on_keeper_shots'}})
        stat_summaries_keys.append({'key':  'clear_rate', 'fmt': '', 'formula': {'op': 'divide', 'num': 'total_possessions', 'denom': 'poss_plus_clears'}})
        stat_summaries_keys.append({'key':  'sog_rate', 'fmt': '', 'formula': {'op': 'divide', 'num': 'sog', 'denom': 'shots'}})
        stat_summaries_keys.append({'key':  'gbs', 'fmt': '', 'play_quals': lambda x:(x['play_type'] in ["Ground Ball"])})
        stat_summaries_keys.append({'key':  'shots', 'fmt': '', 'play_quals': lambda x:(x['play_type'].endswith("Shot") or x['play_type'].endswith("Goal"))})
        stat_summaries_keys.append({'key':  'player_cnt', 'fmt': ''})
        stat_summaries_keys.append({'key':  'off_efficiency', 'fmt': '', 'formula': {'op': 'divide', 'num': 'goals', 'denom': 'possessions'}})
        stat_summaries_keys.append({'key':  'assists', 'fmt': '', 'play_quals': lambda x:(x['play_type'] == ("Assisted Goal"))})
        stat_summaries_keys.append({'key':  'sum_gbs', 'fmt': ''})

        stat_summaries_keys.append({'key': 'possessions_by_length', 'fmt': ''})


        periods = ["", "_by_half", "_by_quarter", "_by_split", "_by_stretch"]
        tn = ["home", "away"]

        qual_period = lambda x,y:(x==y)

        if '-split' in sys.argv or game_obj['split_pct'] is not None:
            if '-split' in sys.argv:
                split = float( sys.argv[sys.argv.index("-split") + 1] )
            else:
                split = game_obj['split_pct']


        if '-stretch' in sys.argv:

            stretch_str = sys.argv[sys.argv.index("-stretch") + 1]
            if '|' in stretch_str: stretch = {'start': float(stretch_str.split("|")[0]), 'end': float(stretch_str.split("|")[1])}
            elif ',' in stretch_str: stretch = {'start': float(stretch_str.split(",")[0]), 'end': float(stretch_str.split(",")[1])}
            elif ';' in stretch_str: stretch = {'start': float(stretch_str.split(";")[0]), 'end': float(stretch_str.split(";")[1])}
            elif ':' in stretch_str: stretch = {'start': float(stretch_str.split(":")[0]), 'end': float(stretch_str.split(":")[1])}
            elif '-' in stretch_str: stretch = {'start': float(stretch_str.split("-")[0]), 'end': float(stretch_str.split("-")[1])}



        for p in plays_list:
            p['split'] = 0 if split is None or p['pct_complete'] < split else 1
            p['stretch'] = 0 if stretch is None or stretch['start'] <= p['pct_complete'] <= stretch['end'] else 1
            p['quarter'] = p['quarter']
            p['half'] = min(p['quarter'],3)/2
            p['team_type'] = "away" if p['confirmed_team'] == confirmed_away_team else "home"

        for p in man_up_opportunities:

            p['goals'] = len([1 for z in plays_list if z['play_type'].endswith("Goal") and z['team_ID'] == p['team_ID'] and p['end_time'] >= z['time_elapsed'] > p['start_time']])
            p['team_type'] = "away" if p['team'] == confirmed_away_team else "home"
            p['split'] = 0 if split is None or float(p['start_time'])/3600. < split else 1
            p['stretch'] = 0 if stretch is None or stretch['start'] <= float(p['start_time'])/3600. <= stretch['end'] else 1
            if p['start_time'] < 3600:
                p['quarter'] = int(p['start_time'] / 900)
            else:
                if max_quarter == 4:
                    p['quarter'] = 3
                else:
                    p['quarter'] = int((p['start_time']-3600) / 300) + 4
            p['half'] = min(p['quarter'],3)/2
            p['duration'] = p['end_time'] - p['start_time']
            

        if cur_pos is not None:
            cur_pos['end_time'] = last_min*60 + last_sec
            cur_pos = set_ended_with("EOG", last_plays, cur_pos, play_obj, play, play_ID)

            if 3600 > last_min*60 + last_sec > 3520 and game_state['state'] != 0 and plays_list[-1]['time_elapsed'] == cur_pos['end_time']:
                cur_pos['end_time'] = 3600.



            if cur_pos not in possessions:
                possessions = possessions_append(possessions, cur_pos, play_obj, play_ID, play)

        #print "\n\nFrom Plays List\n----------------------------------"
        #print ("\n").join(["{:<10}{:<10}{:<15}{:<30}{:<5}{}".format(int(z['pct_complete']*3600.), z['poss_ID'], "PlayID: %s" % z['play_ID'], z['play_type'], 1 if z['play_type'].endswith("Turnover") else "", z['details']) for z in plays_list if z['play_type'].endswith("Turnover") and z['team_ID'] == 29])
        #print "{:<50}{:<5}".format("", sum([1 for z in plays_list if z['team_ID'] == 29 and z['play_type'].endswith("Turnover")]))
        
        
        for ip, p in enumerate(possessions):
            p['team_type'] = "away" if p['team'] == confirmed_away_team else "home"
            p['opp_ID'] = away_ID if p['team_ID'] == home_ID else home_ID
            start_play = sorted([z for z in plays_list if z['time_elapsed'] <= p['start_time']], key=lambda x:x['time_elapsed'])[-1]
            
            if p['team_type'] == "away":
                p['team_odds'] = start_play["away_odds"]
            else:
                p['team_odds'] = start_play["home_odds"]

            p['split'] = 0 if split is None or float(p['start_time'])/3600. < split else 1
            p['stretch'] = 0 if stretch is None or stretch['start'] <= float(p['start_time'])/3600. <= stretch['end'] else 1
            if p['start_time'] < 3600:
                p['quarter'] = int(p['start_time'] / 900)
            else:
                if max_quarter == 4:
                    p['quarter'] = 3
                else:
                    p['quarter'] = int((p['start_time']-3600) / 300) + 4
            p['half'] = min(p['quarter'],3)/2

            p['duration'] = None
            if 'end_time' in p and 'start_time' in p:
                p['duration'] = p['end_time'] - p['start_time']
            if p['first_shot_time'] is not None:
                p['before_shot'] = p['first_shot_time'] - p['start_time']

                if p['started_with'] == "Faceoff Win" and p['before_shot'] < 2:
                    p['weird'][2] = 1
            else:
                p['before_shot'] = None

            p['length_class'] = "sub_30"
            if p['duration'] >= 30 and p['duration'] < 60:
                p['length_class'] = "30_60"
            elif p['duration'] >= 60:
                p['length_class'] = "60_plus"


            next_pos = None
            if ip < len(possessions) - 1:
                next_pos = possessions[ip+1]
                p['last_play_seq'] = next_pos['first_play_seq']
            else:
                p['last_play_seq'] = max([z['seq'] for z in plays_list])
            p['zero_duration_penalty_possession'] = 0
            p['removed'] = 0
            
            
        steps.append({'step': 'Set up stat summaries', 'time': time.time()})
        filters = []
        filters.append({'ID': len(filters), 'filter': None, 'filter_val': None, 'qual': lambda x:(1)})
        filters.append({'ID': len(filters), 'filter': 'WinProb', 'filter_val': 'Competitive', 'qual': lambda x:(.05 <= x['team_odds'] <= .95)})
        filters.append({'ID': len(filters), 'filter': 'WinProb', 'filter_val': 'NonCompetitive', 'qual': lambda x:not (.05 <= x['team_odds'] <= .95)})
        stat_summaries_with_filters = []

        for i, f in enumerate(filters):
            pass
        for ftr in filters:
            stat_summaries_dict = {}
            for k in stat_summaries_keys:
                    
                if 'opp' not in k: k['opp'] = False
                for p in periods:
                    for t in tn:
                        val = 0.
                        if k['key'] in []:
                            pass
                        else:
                            if p == "_by_quarter":
                                val = [0.] * 10
                            elif p in ["_by_half", "_by_split", "_by_stretch"]:
                                val = [0.] * 2
                        k_str = "%s_%s%s" % (t, k['key'], p)
                        if 'rate' in k['key'] or 'pct' in k['key']:
                            stat_summaries_dict[k_str] = {'val': val, 'fmt': k['fmt']}
                        else:
                            stat_summaries_dict[k_str] = {'val': val, 'fmt': k['fmt']}

            for k in [{'key': 'total_possessions', 'fmt': ''}]:
                for p in periods:
                    val = 0.
                    if k['key'] in []:
                            pass
                    else:
                        if p == "_by_quarter":
                            val = [0.] * 10
                        elif p in ["_by_half", "_by_split", "_by_stretch"]:
                            val = [0.] * 2
                    k_str = "%s%s" % (k['key'], p)
                    if 'rate' in k['key'] or 'pct' in k['key']:
                        stat_summaries_dict[k_str] = {'val': val, 'fmt': k['fmt']}
                    else:
                        stat_summaries_dict[k_str] = {'val': val, 'fmt': k['fmt']}

            for t in tn:
                k_str = "%s_%s" % (t, "possessions_by_length")
                stat_summaries_dict[k_str] = {'val':  {'sub_30': 0., '30_60': 0., '60_plus': 0.}, 'fmt': ''}
                k_str = "%s_%s" % (t, "goals_by_poss_length")
                stat_summaries_dict[k_str] = {'val':  {'sub_30': 0., '30_60': 0., '60_plus': 0.}, 'fmt': ''}
                k_str = "%s_%s" % (t, "goals_by_shot_sequence")
                stat_summaries_dict[k_str] = {'val':  [0.]*10, 'fmt': ''}


            stat_summaries_dict['split'] = None
            if '-split' in sys.argv or game_obj['split_pct'] is not None:
                if '-split' in sys.argv:
                    stat_summaries_dict['split'] = split
                else:
                    stat_summaries_dict['split'] = split




            for t in tn:

                for k in stat_summaries_keys:
                    if 'play_quals' in k:
                        plays_list_with_no_wp = [z for z in plays_list if 'team_odds' not in z or z['team_odds'] is None]
                        if len(plays_list_with_no_wp) > 0: # There are plays for which no win probability was assigned, this should throw an error
                            msg = "23wpxla_noTeamOdds: {:.0f} plays were found with no team odds assigned to them...\n\nHere is a subset of the offending objects\n\n{}".format(len(plays_list_with_no_wp), json.dumps(plays_list_with_no_wp[0:5], default=zc.json_handler, indent=1))
                    
                            if EXPORT_ERRORS:
                                print (msg)
                                errors.append({'type': 'Play not not assigned team Odds', 'code': 13, 'text': msg})
                                return {'success': 0, 'errors': errors}
                            else:
                                zc.send_crash(msg, bot_token)
                                return None
                        if 'sum' in k:
                            stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([z[k['sum']] for z in plays_list if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['play_quals'](z)])
                        else:
                            stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([1. for z in plays_list if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['play_quals'](z)])
                        for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                            if 'sum' in k:
                                stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([z[k['sum']] for z in plays_list if k['opp'] != (z['team_type'] == t) and k['play_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]
                            else:
                                stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([1. for z in plays_list if k['opp'] != (z['team_type'] == t) and k['play_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]
                    if 'formula' not in k and 'poss_quals' in k:

                        stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([1. for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)])
                        if '--test-turnover-counts' in sys.argv and k['key'] == "turnovers":
                            print ("{:<40} out of {} poss - 1) {}".format(t, sum([1. for z in possessions if k['opp'] != (z['team_type'] == t)]), sum([1. for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)])))
                            print ("{:<40} out of {} poss - 2) {}".format(t, sum([1. for z in possessions if k['opp'] != (z['team_type'] == t)]), sum([1. for z in possessions if k['opp'] != (z['team_type'] == t) and k['poss_quals'](z)])))
                            tmp_poss = [z for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)]
                            print ("\n".join([convert_pct_complete_to_time_str(p['start_time']/3600., datetime.now().year, "NCAA D1 Men") for p in tmp_poss]))
                            
                        for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                            stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([1. for z in possessions if k['opp'] != (z['team_type'] == t) and k['poss_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]
                       
                    if 'man_up_quals' in k:

                        stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([1. for z in man_up_opportunities if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['man_up_quals'](z)])
                        for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                            stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([1. for z in man_up_opportunities if k['opp'] != (z['team_type'] == t) and k['man_up_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]
                    if 'poss_agg' in k:
                        stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = None

                        if k['poss_agg']['op'] == "sum":
                            stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([z[k['poss_agg']['var']] for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)])

                            for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([z[k['poss_agg']['var']] for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]


                
            for tname in tn:
                t_opp = 'away' if tname == "home" else "home"

                for k in stat_summaries_keys:
                    if k['opp']:
                        t = t_opp
                    else:
                        t = tname

                    if 'formula' in k:
                        stat_summaries_dict['%s_%s'% (tname, k['key'])]['val'] = None

                        if k['formula']['op'] == "divide":
                            if 'poss_quals' in k:
                                cnt = sum([1. for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)])
                                if k['formula']['denom'] == "count" and cnt > 0:
                                
                                
                                    stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([k['formula']['num'] for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)]) / cnt
                                    zc.exit("%d / %d = %.3f" % (sum([k['formula']['num'] for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)]), cnt, sum([k['formula']['num'] for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)]) / cnt))
                                    for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                        stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([k['formula']['num'] for z in possessions if k['opp'] != (z['team_type'] == t) and k['poss_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]
                                        stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([k['formula']['num'] for z in possessions if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['poss_quals'](z)]) / cnt
                                else:
                                    msg = "[FATAL - 3das] Not implemented error:\n\n%s" % zc.print_dict(k)
                                    print (msg)
                                    zc.send_crash(msg, bot_token)
                                    zc.exit("NOT IMPLEMENTED")
                            else:
                                if stat_summaries_dict['%s_%s'% (t, k['formula']['denom'])]['val'] != 0:
                                    stat_summaries_dict['%s_%s'% (tname, k['key'])]['val'] = stat_summaries_dict['%s_%s'% (t, k['formula']['num'])]['val']/stat_summaries_dict['%s_%s'% (t, k['formula']['denom'])]['val']

                                    stat_summaries_dict['%s_%s'% (tname, k['key'])]['log'] = "{:<40}{:>30}{:>10.2f}{:>15}{:>30}{:>10.2f}\n".format('%s_%s'% (tname, k['key']), '%s_%s'% (t, k['formula']['num']), stat_summaries_dict['%s_%s'% (t, k['formula']['num'])]['val'], "divide", '%s_%s'% (t, k['formula']['denom']), stat_summaries_dict['%s_%s'% (t, k['formula']['denom'])]['val'])
                            for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                    num_list = stat_summaries_dict['%s_%s_by_%s'% (t, k['formula']['num'], tmp[0])]['val']
                                    denom_list = stat_summaries_dict['%s_%s_by_%s'% (t, k['formula']['denom'], tmp[0])]['val']
                                    for i, (num, denom) in enumerate(zip(num_list, denom_list)):
                                        stat_summaries_dict['%s_%s_by_%s'% (tname, k['key'], tmp[0])]['val'][i] = 0.
                                        if denom != 0:
                                            stat_summaries_dict['%s_%s_by_%s'% (tname, k['key'], tmp[0])]['val'][i] = num/denom

                        if k['formula']['op'] == "share":
                            tmp_sum = stat_summaries_dict['%s_%s'% (tname, k['formula']['var'])]['val'] + stat_summaries_dict['%s_%s'% (t_opp, k['formula']['var'])]['val']
                            stat_summaries_dict['%s_%s'% (tname, k['key'])]['val'] = 0.
                            if tmp_sum != 0:
                                stat_summaries_dict['%s_%s'% (tname, k['key'])]['val'] = float(stat_summaries_dict['%s_%s'% (tname, k['formula']['var'])]['val'])/tmp_sum

                           

                            for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                list1 = stat_summaries_dict['%s_%s_by_%s'% (tname, k['formula']['var'], tmp[0])]['val']
                                list2 = stat_summaries_dict['%s_%s_by_%s'% (t_opp, k['formula']['var'], tmp[0])]['val']
                                for i, (val1, val2) in enumerate(zip(list1, list2)):
                                    val1 = float(val1); val2 = float(val2)
                                    stat_summaries_dict['%s_%s_by_%s'% (tname, k['key'], tmp[0])]['val'][i] = 0.
                                    tmp_sum = val1 + val2
                                    if tmp_sum != 0:
                                        stat_summaries_dict['%s_%s_by_%s'% (tname, k['key'], tmp[0])]['val'][i] = val1/tmp_sum

                        if k['formula']['op'] == "margin":

                            stat_summaries_dict['%s_%s'% (tname, k['key'])]['val'] = stat_summaries_dict['%s_%s'% (tname, k['formula']['var'])]['val'] - stat_summaries_dict['%s_%s'% (t_opp, k['formula']['var'])]['val']


                            for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                list1 = stat_summaries_dict['%s_%s_by_%s'% (tname, k['formula']['var'], tmp[0])]['val']
                                list2 = stat_summaries_dict['%s_%s_by_%s'% (t_opp, k['formula']['var'], tmp[0])]['val']
                                for i, (val1, val2) in enumerate(zip(list1, list2)):
                                    val1 = float(val1); val2 = float(val2)
                                    stat_summaries_dict['%s_%s_by_%s'% (tname, k['key'], tmp[0])]['val'][i] = val1-val2

            # Calc miscellaneous stuff
            for t in tn:
                t_opp = 'away' if t == "home" else "home"
                for tmp in range(10):
                    stat_summaries_dict['%s_goals_by_shot_sequence'% (t)]['val'][tmp] =  sum([1. for z in possessions if (z['team_type'] == t) and z['goal_scored'] and min(9,  z['total_shots']) == tmp])
                for tag in stat_summaries_dict['%s_goals_by_poss_length'% (t)]['val']:
                    stat_summaries_dict['%s_goals_by_poss_length'% (t)]['val'][tag] =  sum([1. for z in possessions if (z['team_type'] == t) and z['goal_scored'] and z['length_class'] == tag and sum(z['weird'])==0])
                for tag in stat_summaries_dict['%s_possessions_by_length'% (t)]['val']:
                    stat_summaries_dict['%s_possessions_by_length'% (t)]['val'][tag] =  sum([1. for z in possessions if (z['team_type'] == t) and z['length_class'] == tag and sum(z['weird'])==0])
            # Calc miscellaneous stuff
            for t in tn:
                
                #input(t)
                #input(stat_summaries_dict['%s_possessions'% (t)])
                #input(stat_summaries_dict['%s_failed_clears'% (t)])
                t_opp = 'away' if t == "home" else "home"
                stat_summaries_dict['%s_possessions_plus_failed_clears'% (t)] = {'val': stat_summaries_dict['%s_possessions'% (t)]['val'] + stat_summaries_dict['%s_failed_clears'% (t)]['val']}
                #zc.exit(stat_summaries_dict['%s_possessions_plus_failed_clears'% (t)])

            stat_summaries_with_filters.append({'filter_ID': ftr['ID'], 'filter':ftr['filter'], 'filter_val': ftr['filter_val'], 'stat_summaries': stat_summaries_dict})


        stat_summaries_dict = stat_summaries_with_filters[ [z['filter_ID'] for z in stat_summaries_with_filters].index(0)]['stat_summaries']

        ss = [{'team_tag': 'away'}]

        if cur_pos is None:
            if len(possessions) > 0:
                zc.send_telegram("Error: Current possession is None (probably no plays uploaded)\n%s" % (("Game ID: %s"  % game_ID) if game_ID is not None else "Game unknown"), bot_token)
        else:

                # Write possessions to the possessions file for the team
                for ip, p in enumerate(possessions):


                    if p['end_time'] is None:
                        print_stuff("In game %s, end time was none on play %d" % (g_rec['ID'], p['ID']))
                        zc.exit("laxref0072")
                    elif p['end_time'] is None:
                        print_stuff("In game %s, end time was none on play %d" % (g_rec['ID'], p['ID']))
                        zc.exit("laxref0073")

                    if sum(p['weird']) == 0:
                        weirdness[0] += 1
                    elif p['weird'][0] == 1:
                        weirdness[1] += 1
                    elif p['weird'][1] == 1:
                        weirdness[2] += 1
                    elif p['weird'][2] == 1:
                        weirdness[3] += 1


                for p in possessions:


                    p['length_class'] = "sub_30"
                    if p['duration'] >= 30 and p['duration'] < 60:
                        p['length_class'] = "30_60"
                    elif p['duration'] >= 60:
                        p['length_class'] = "60_plus"

                    p['split'] = 0 if split is None or float(p['start_time'])/3600. < split else 1
                    p['stretch'] = 0 if stretch is None or stretch['start'] <= float(p['start_time'])/3600. <= stretch['end'] else 1
                    if p['start_time'] < 3600:
                        quarter = int(p['start_time'] / 900)
                    else:
                        if max_quarter == 4:
                            quarter = 3
                        else:
                            quarter = int((p['start_time']-3600) / 300) + 4


                n = get_stats(game_ID)
                sum_gbs = get_stat_summaries(game_ID, 11, confirmed_home_team, confirmed_away_team, game_date) # groundballs = 11 , 28
                sum_fo = get_stat_summaries(game_ID, 14, confirmed_home_team, confirmed_away_team, game_date) # faceoffs = 14, 31
                if sum_gbs is not None:
                    stat_away_gbs, stat_home_gbs = sum_gbs
                    total_groundballs_variance += abs(home_gbs - stat_home_gbs) + abs(away_gbs - stat_away_gbs)

        steps.append({'step': 'Created stat summaries', 'time': time.time()})
        timestamps['Calculated summary stats'] = time.time()
        if os.path.isfile(os.path.join(lr_fldr, 'Logs')):
            f = open(os.path.join(lr_fldr, 'Logs', 'creategamedicttimestamps'), 'w')
            ts = sorted([{'event': k, 'timestamp': v} for k, v in zip(timestamps.keys(), timestamps.values())], key=lambda x:x['timestamp'])
            for i, t in enumerate(ts):
                diff = 0 if i == 0 else 1000*(t['timestamp'] - ts[i-1]['timestamp'])
                f.write("%s%f\t%d\n" % ("{:<50}".format(t['event']), t['timestamp'], diff))
            f.close()
        #zc.exit("laxref0074")



        if team1 == home_team_name or team1 == alt_home_team or team1 == confirmed_home_team:

            home_team_players = team1_players
            home_team_counts = team1_counts
            home_team_counts_dict = team1_counts_dict
            away_team_players = team2_players
            away_team_counts = team2_counts
            away_team_counts_dict = team2_counts_dict
        else:

            home_team_players = team2_players
            home_team_counts = team2_counts
            home_team_counts_dict = team2_counts_dict
            away_team_players = team1_players
            away_team_counts = team1_counts
            away_team_counts_dict = team1_counts_dict

        
        home_players = []
        away_players = []

        for p, c, d in zip(home_team_players, home_team_counts, home_team_counts_dict):
            for play in d['plays']:


                if play['play_type'] == "Assist":
                    play['EGA'] = play['cnt'] * .5
                else:
                    play['EGA'] = play['cnt'] * (play_values_for[plays.index(play['play_type'])] - play_values_against[plays.index(play['play_type'])])
                    if play['play_type'] == "Assisted Goal":
                        play['EGA'] += play['cnt'] * .5
                    elif play['play_type'] == "Unassisted Goal":
                        play['EGA'] += play['cnt'] * 1.

            for play in d['play_log']:


                play['class'] = None
                
                play['is_shot'] = 0
                if play['play_type'].endswith(" Shot") or play['play_type'].endswith(" Goal"):
                    play['is_shot'] = 1

                if 'FOGO' not in play and play['play_type'].strip() in ['Assist', 'Forced Turnover', 'Unforced Turnover', 'Blocked Shot', 'Missed Shot', 'Saved Shot', 'Pipe Shot', 'Unassisted Goal', 'Assisted Goal', 'Free Position', 'Free Position Attempt']:
                    play['class'] = 1
                elif 'FOGO' not in play and play['play_type'] in ['Card', 'Failed Clear', 'Good Clear', 'Save', 'Ground Ball', 'Caused Turnover'] or play['play_type'].startswith("Penalty"):

                    play['class'] = 2
                elif 'FOGO' in play or play['play_type'] in ['Draw Control', 'Faceoff Win', 'Faceoff Loss']:
                    play['class'] = 3

                if play['class'] is None and play['play_type'] not in ['Substitution', 'Shot Clock Violation', 'Shot Clock On', 'Timeout', 'Goalie Change']:
                    msg = "23sdfjk2304u: Play assignment failed...\n\n%s" % zc.print_dict(play)
                    
                    if EXPORT_ERRORS:
                        print (msg)
                        errors.append({'type': 'Play not identified as type Offense/defense/FOGO', 'code': 11, 'text': msg})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(msg, bot_token)
                        return None


                if play['play_type'] == "Assist":
                    play['EGA'] = .5
                else:
                    play['EGA'] = (play_values_for[plays.index(play['play_type'])] - play_values_against[plays.index(play['play_type'])])
                    if play['play_type'] == "Assisted Goal":
                        play['EGA'] += .5
                    elif play['play_type'] == "Unassisted Goal":
                        play['EGA'] += 1.
                
            for quarter_plays in d['plays_by_quarter']:
                for play in quarter_plays:
                    if play['play_type'] == "Assist":
                        play['EGA'] = play['cnt'] * .5
                    else:
                        play['EGA'] = play['cnt'] * (play_values_for[plays.index(play['play_type'])] - play_values_against[plays.index(play['play_type'])])
                        if play['play_type'] == "Assisted Goal":
                            play['EGA'] += play['cnt'] * .5
                        elif play['play_type'] == "Unassisted Goal":
                            play['EGA'] += play['cnt'] * 1.

            home_players.append({'play_log': d['play_log'], 'player': p, 'play_count': c
            , 'EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] in [1, 2, 3]])
            , 'goals_allowed': d['goals_allowed']
            , 'shooting_EGA': sum([z['EGA'] if z['play_type'] != "Assisted Goal" else (z['EGA'] + .5) for z in d['play_log'] if z['is_shot']])
            , 'defensive_EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] == 2])
            , 'offensive_EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] == 1])
            , 'faceoff_EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] == 3])
            , 'EGA_by_quarter': [sum([z['EGA'] for z in y]) for y in d['plays_by_quarter']]
            #, 'play_count_dict': d
            })

            #print ("Add %s to the home list." % p)
        
        #zc.print_dict (home_players); zc.exit("T1Players")
        #print ("\n").join(["{:<40}{:>10.2f}".format(z['player'], z['faceoff_EGA']) for z in home_players]); zc.exit("laxref0076")
        for p, c, d in zip(away_team_players, away_team_counts, away_team_counts_dict):
            for play in d['plays']:
                if play['play_type'] == "Assist":
                    play['EGA'] = play['cnt'] * .5
                else:
                    play['EGA'] = play['cnt'] * (play_values_for[plays.index(play['play_type'])] - play_values_against[plays.index(play['play_type'])])
                    if play['play_type'] == "Assisted Goal":
                        play['EGA'] += play['cnt'] * .5
                    elif play['play_type'] == "Unassisted Goal":
                        play['EGA'] += play['cnt'] * 1.

            for play in d['play_log']:
                play['class'] = None
                
                play['is_shot'] = 0
                if play['play_type'].endswith(" Shot") or play['play_type'].endswith(" Goal"):
                    play['is_shot'] = 1
                    


                if 'FOGO' not in play and play['play_type'] in ['Assist', 'Forced Turnover', 'Unforced Turnover', 'Blocked Shot', 'Missed Shot', 'Saved Shot', 'Pipe Shot', 'Unassisted Goal', 'Assisted Goal', 'Free Position Attempt', 'Free Position']:
                    play['class'] = 1
                elif 'FOGO' not in play and play['play_type'] in ['Card', 'Failed Clear', 'Good Clear', 'Save', 'Ground Ball', 'Caused Turnover'] or play['play_type'].startswith("Penalty"):
                    play['class'] = 2
                elif 'FOGO' in play or play['play_type'] in ['Draw Control', 'Faceoff Win', 'Faceoff Loss']:
                    play['class'] = 3
                    
                if play['class'] is None and play['play_type'] not in ['Substitution', 'Shot Clock Violation', 'Shot Clock On', 'Timeout', 'Goalie Change']:
                    msg = "23sdfjk2404u: Play assignment failed...\n\n%s" % zc.print_dict(play)
                    
                    if EXPORT_ERRORS:
                        print (msg)
                        errors.append({'type': 'Play not identified as type Offense/defense/FOGO', 'code': 11, 'text': msg})
                        return {'success': 0, 'errors': errors}
                    else:
                        zc.send_crash(msg, bot_token)
                        return None


                if play['play_type'] == "Assist":
                    play['EGA'] = .5
                else:
                    play['EGA'] = (play_values_for[plays.index(play['play_type'])] - play_values_against[plays.index(play['play_type'])])
                    if play['play_type'] == "Assisted Goal":
                        play['EGA'] += .5
                    elif play['play_type'] == "Unassisted Goal":
                        play['EGA'] += 1.
            for quarter_plays in d['plays_by_quarter']:
                for play in quarter_plays:
                    if play['play_type'] == "Assist":
                        play['EGA'] = play['cnt'] * .5
                    else:
                        play['EGA'] = play['cnt'] * (play_values_for[plays.index(play['play_type'])] - play_values_against[plays.index(play['play_type'])])
                        if play['play_type'] == "Assisted Goal":
                            play['EGA'] += play['cnt'] * .5
                        elif play['play_type'] == "Unassisted Goal":
                            play['EGA'] += play['cnt'] * 1.
            away_players.append({'play_log': d['play_log'], 'player': p, 'play_count': c
            , 'EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] in [1, 2, 3]])
            , 'goals_allowed': d['goals_allowed']
            , 'shooting_EGA': sum([z['EGA'] if z['play_type'] != "Assisted Goal" else (z['EGA'] + .5) for z in d['play_log'] if z['is_shot']])
            , 'defensive_EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] == 2])
            , 'offensive_EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] == 1])
            , 'faceoff_EGA': sum([z['EGA'] for z in d['play_log'] if z['class'] == 3])
            , 'EGA_by_quarter': [sum([z['EGA'] for z in y]) for y in d['plays_by_quarter']]
            #, 'play_count_dict': d
            })
            
            
            #print ("Add %s to the away list." % p)
        ignore_keys = ['details', 'class', 'regex']
        for l in [away_players, home_players]:
            for player in l:
                for i, play in enumerate(player['play_log']):
                    d = {}

                    for k, v in zip(play.keys(), play.values()):
                        if k not in ignore_keys:
                            d[k] = v
                    player['play_log'][i] = d

        steps.append({'step': 'Calculate player EGA information', 'time': time.time()})
        elo = {'home_odds': home_win_odds, 'away_odds': away_win_odds, 'starting_home': home_elo, 'starting_away': away_elo, 'ending_home': ending_home_elo, 'ending_away': ending_away_elo, 'home_starting_elo_rank': home_starting_elo_rank, 'away_starting_elo_rank': away_starting_elo_rank, 'home_ending_elo_rank': home_ending_elo_rank, 'away_ending_elo_rank': away_ending_elo_rank}

        home_team = {'score': stat_summaries_dict['home_goals']['val'], 'confirmed_team': confirmed_home_team, 'ID': home_ID, 'alt_team': alt_home_team, 'team': home_team_name, 'total_possessions': stat_summaries_dict['home_possessions']['val'], 'players': home_players }
        away_team = {'score': stat_summaries_dict['away_goals']['val'], 'confirmed_team': confirmed_away_team, 'ID': away_ID, 'alt_team': alt_away_team, 'team': away_team_name, 'total_possessions': stat_summaries_dict['away_possessions']['val'], 'players': away_players }

        ignore_keys = ['ges', 'time_str', 'gem']
        for i, p in enumerate(plays_list):
            d = {}
            for k, v in zip(p.keys(), p.values()):
                if k not in ignore_keys:
                    if k == "player2_is_save":
                        d[k] = 1 if v else 0
                    elif k.endswith("odds"):
                        d[k] = round(v, 3)
                    else:
                        d[k] = v
            plays_list[i] = d
        ignore_keys = ['timestamps', 'groundballs', 'shots']
        for i, p in enumerate(possessions):
            d = {}
            for k, v in zip(p.keys(), p.values()):
                if k not in ignore_keys:
                    if k == "goal_scored":
                        d[k] = 1 if v else 0
                    elif k.endswith("odds"):
                        d[k] = round(v, 3)
                    else:
                        d[k] = v
            possessions[i] = d

        for t in [home_players, away_players]:
            for p in t:
                p['points'] = len([1 for z in p['play_log'] if z['play_type'] == "Assist" or z['play_type'].endswith("Goal")])

                p['saves'] = len([1 for z in p['play_log'] if z['play_type'] == "Save"])
                if p['saves'] > 1:
                    p['stat_line'] = "%d SAVES" % (p['saves'])
                else:
                    p['stat_line'] = "%dG" % len([1 for z in p['play_log'] if z['play_type'].endswith("Goal")])
                    if len([1 for z in p['play_log'] if z['play_type'] == "Assist"]) > 0:
                        p['stat_line'] += (", %dA" % (len([1 for z in p['play_log'] if z['play_type'] == "Assist"])))

            
        steps.append({'step': 'Create player stat lines', 'time': time.time()})
        # Calculate the phil's law for possessions and faceoffs
        phils_law = None
        total_goals = float(stat_summaries_dict['home_goals']['val'] + stat_summaries_dict['away_goals']['val'])
        total_faceoffs = float(stat_summaries_dict['home_faceoffs']['val'] + stat_summaries_dict['away_faceoffs']['val'])
        faceoffs_per_goal = 0 if total_goals == 0 else total_faceoffs/total_goals

        if stat_summaries_dict['away_possessions']['val'] > 0 and  stat_summaries_dict['home_possessions']['val'] > 0:
            phils_law = {}
            phils_law['home_fp_adv'] = float(stat_summaries_dict['home_goals']['val'])/float(stat_summaries_dict['home_possessions']['val']) - float(stat_summaries_dict['away_goals']['val'])/float(stat_summaries_dict['away_possessions']['val'])
            phils_law['away_fp_adv'] = float(stat_summaries_dict['away_goals']['val'])/float(stat_summaries_dict['away_possessions']['val']) - float(stat_summaries_dict['home_goals']['val'])/float(stat_summaries_dict['home_possessions']['val'])

            phils_law['home_fo_adv'] = 0 if total_faceoffs*faceoffs_per_goal == 0 else float(stat_summaries_dict['home_faceoffs']['val'] - stat_summaries_dict['away_faceoffs']['val'])/total_faceoffs*faceoffs_per_goal
            phils_law['away_fo_adv'] = 0 if total_faceoffs*faceoffs_per_goal == 0 else float(stat_summaries_dict['away_faceoffs']['val'] - stat_summaries_dict['home_faceoffs']['val'])/total_faceoffs*faceoffs_per_goal

            phils_law['home_game_adv'] = phils_law['home_fo_adv'] + phils_law['home_fp_adv']
            phils_law['away_game_adv'] = phils_law['away_fo_adv'] + phils_law['away_fp_adv']

        team_names = [y.upper() for y in [home_team['confirmed_team'], away_team['confirmed_team'], home_team['team'], away_team['team'], home_team['alt_team'], away_team['alt_team']] if y is not None]

        stat_summaries_dict['away_player_cnt'] = {'val': len([1 for z in away_players if z['player'].upper() not in team_names]),'fmt': ''}
        stat_summaries_dict['home_player_cnt'] = {'val': len([1 for z in home_players if z['player'].upper() not in team_names]),'fmt': ''}
        stat_summaries_dict['away_player_cnt'] = {'val': sum([1. for z in away_players if z['player'].upper() not in team_names]),'fmt': ''}
        stat_summaries_dict['home_player_cnt'] = {'val': sum([1. for z in home_players if z['player'].upper() not in team_names]),'fmt': ''}
        stat_summaries_dict['total_possessions'] = {'val': sum([1. for z in possessions]),'fmt': ''}


        steps.append({'step': 'Phils laws', 'time': time.time()})

        logs = {'non_faceoff_w_none': non_faceoff_w_none }
        game_details = {'date': game_date, 'year': game_date.year, 'month': game_date.month, 'day': game_date.day, 'weekday': game_date.weekday(), 'penalty_out_of_order': penalty_out_of_order, 'first_play_not_faceoff': first_play_not_faceoff}
        game_details_save = {'date': game_date, 'year': game_date.year, 'month': game_date.month, 'day': game_date.day, 'weekday': game_date.weekday(), 'penalty_out_of_order': penalty_out_of_order, 'first_play_not_faceoff': first_play_not_faceoff}
        g = {'success': 0, 'shots': None, 'pregame_home_wp': pregame_home_wp, 'log_url': game_obj['log_url'], 'league': league, 'phils_law': phils_law, 'from_file': False, 'both_teams': "%s|%s" % (confirmed_home_team, confirmed_away_team), 'max_quarter': None if plays_list == [] else max([z['quarter'] for z in plays_list])+1 , 'plays': plays_list, 'elo_odds': elo, 'logs': logs, 'cur_pos': cur_pos, 'possessions': possessions, 'man_up_opportunities': man_up_opportunities, 'ID': game_ID, 'home_team_name': home_team_name, 'away_team_name': away_team_name, 'alt_home_team': alt_home_team, 'alt_away_team': alt_away_team, 'home_team': home_team, 'away_team': away_team, 'detail': game_details, 'stat_summaries': stat_summaries_dict}

        #zc.print_dict(g['possessions'][0])
        g['pct_weird_possessions'] = None; g['weird_time_as_pct'] = None
        if float(len(g['possessions'])) > 0:
            g['pct_weird_possessions'] = sum([1. for z in g['possessions'] if sum(z['weird']) > 0])/float(len(g['possessions']))
        if sum([float(z['duration']) for z in g['possessions']]) > 0:
            g['weird_time_as_pct'] = sum([float(z['duration']) for z in g['possessions'] if sum(z['weird']) > 0])/sum([float(z['duration']) for z in g['possessions']])


        #print (home_team['players']); zc.exit("T1Players")
            
        
        if game_ID is not None and '--skip-db-processing' not in sys.argv:
            if show_cgd_timedstamps:
                print("     {:<95}{:<15}".format("Begin database table update...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
        
            # Only process this DB update logic if we are post-processing a completed game (as opposed to processing a live win odds game)
            conn, cursor = zc.mysql_connect("LR")
            
            
            print("          {:<90}{:<15}".format("Process player lists...", datetime.now().strftime("%H:%M:%S")));
            db_existing_players_list, db_existing_player_seasons_list, relevant_players, plays_list = process_player_lists([home_team, away_team], game_ID, db_existing_players_list, db_existing_player_seasons_list, db_alternate_player_names, plays_list, game_date, conn, cursor)
            
            steps.append({'step': 'Process player list', 'time': time.time()})

            faceoffs = []
            print("          {:<90}{:<15}".format("Process faceoffs/draws...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
            if "Men" in league:
                tmp = process_faceoffs(plays_list, possessions, relevant_players, g, db_existing_faceoffs, confirmed_away_team, confirmed_home_team, away_ID, home_ID, game_date, league, home_team, away_team, next_faceoff_ID, conn, cursor)
                faceoffs = tmp[0]
                next_faceoff_ID = tmp[1]
                steps.append({'step': 'Process faceoffs', 'time': time.time()})
            elif 'Women' in league:
                tmp = process_faceoffs(plays_list, possessions, relevant_players, g, db_existing_faceoffs, confirmed_away_team, confirmed_home_team, away_ID, home_ID, game_date, league, home_team, away_team, next_faceoff_ID, conn, cursor)
                faceoffs = tmp[0]
                next_faceoff_ID = tmp[1]
                steps.append({'step': 'Process faceoffs', 'time': time.time()})
                
            print("          {:<90}{:<15}".format("Process shots...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
            process_game_shots(plays_list, game_ID, confirmed_away_team, confirmed_home_team, away_ID, home_ID, game_date)
            steps.append({'step': 'Process shots', 'time': time.time()})
            
            tmp_game_shots = [z for z in plays_list if z['play_type'].endswith("Goal") or z['play_type'].endswith("Shot")]
            
            for i, s in enumerate(tmp_game_shots):
                s['free_position'] = 0
                s['one_pass_free_position'] = 0
                s['seq'] = i+1
            
            print("          {:<90}{:<15}".format("Process free positions...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
            if 1 or '--process-free-positions' in sys.argv:
                try:
                    tmp = process_free_positions(plays_list, tmp_game_shots, next_man_up_ID, db_existing_man_up, db_players, fp_type_counts, g, conn, cursor)
                    shots = tmp[0]
                    next_man_up_ID = tmp[1]
                    fp_type_counts = tmp[2]
                    fp_events = tmp[3]
                except Exception:
                    msg = "Process Free Positions failed in game ID %d:\n\n%s" % (game_ID, traceback.format_exc())
                    print (msg)
                    zc.send_telegram(msg, bot_token)
    
            print("          {:<90}{:<15}".format("Process shots (db)...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
            tmp = process_game_shots_db(tmp_game_shots, goalies, possessions, relevant_players, g, db_existing_shots, next_shot_ID, confirmed_away_team, confirmed_home_team, away_ID, home_ID, game_date, league, conn, cursor)
            g['shots'] = tmp[0]
            next_shot_ID = tmp[1]
            steps.append({'step': 'Process shots_db', 'time': time.time()})

            run_man_up = 1
            try:
                if "Women" not in league:
                    run_man_up = 0
            except Exception:
                zc.send_telegram(traceback.format_exc(), bot_token)
            
            if run_man_up:
                
                print("          {:<90}{:<15}".format("Process man ups...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
                next_man_up_ID = process_man_up_opportunities(man_up_opportunities, game_ID, db_existing_man_up, game_date, next_man_up_ID, conn, cursor)
                steps.append({'step': 'Process man-up', 'time': time.time()})
            
            print("          {:<90}{:<15}".format("Process possessions...", datetime.now().strftime("%H:%M:%S")));
            process_possessions(possessions, game_ID, db_existing_possessions, game_date, conn, cursor)
            steps.append({'step': 'Process possessions', 'time': time.time()})
            
            
            if 1 or '--upload-to-LRP' in sys.argv:
                team_rec = {'ID': home_ID, 'league': league}
                #print ("\n team_rec")
                #zc.print_dict(team_rec)
                #print ("\n game_obj.keys()")
                #print (sorted(game_obj.keys()))
                #print ("\n game_data.keys()")
                #print (sorted(game_data.keys()))
                #print ("\n db_existing_possessions[0].keys()")
                #print (sorted(db_existing_possessions[0].keys()))
                game_obj['game_year'] = game_obj['game_date'].year
                game_obj['home_ID'] = home_ID
                game_obj['away_ID'] = away_ID
                tmp_game_possessions = [z for z in possessions]
                tmp_game_shots = [z for z in tmp_game_shots]
                
                tmp_game_faceoffs = [z for z in faceoffs]
                if 'player_game_analyzer.py' not in sys.argv or '--skip-player-and-career-update-queries' not in sys.argv:
                    for p in tmp_game_possessions:
                        p['adj_before_shot'] = None if p['before_shot'] is None else min(79, p['before_shot'])
                        p['num_shots'] = p['total_shots']
                    tmp_game_obj = build_game_stretches(team_rec, game_obj, tmp_game_possessions, {'shots': tmp_game_shots, 'faceoffs': tmp_game_faceoffs})
                
                
                    print("          {:<90}{:<15}".format("Process game stretches...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
                    process_game_stretches(tmp_game_obj['stretches'], game_ID, db_existing_stretches, game_date, conn, cursor)
                    steps.append({'step': 'Process possessions', 'time': time.time()})
                
                    #zc.print_dict(tmp_game_obj['stretches'])
                    
                    LRP_json['results']['KeyStretches'] = tmp_game_obj['stretches']
            
            cursor.close(); conn.close()
                    
            for s in  stat_summaries_with_filters:
                s['tup'] = (s['filter_ID'], s['filter'], s['filter_val'])
            for ftr in filters:
            
                ftr['tup'] = (ftr['ID'], ftr['filter'], ftr['filter_val'])
                #print ftr['tup']
                stat_summaries_dict = stat_summaries_with_filters[ [z['tup'] for z in stat_summaries_with_filters].index(ftr['tup']) ]['stat_summaries']
                
                tn = ["home", "away"]
                for t in tn:
                    for k in stat_summaries_keys:
                        if 'faceoff_quals' in k:
                            #print ("{:<20}{:<20}{:<20}{:<20}{:<20}".format(t, k['key'], "" if ftr['filter'] is None else ftr['filter'], "" if ftr['filter_val'] is None else ftr['filter_val'], sum([1. for z in faceoffs if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['faceoff_quals'](z)])))
                            
                            stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([1. for z in faceoffs if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['faceoff_quals'](z)])
                            for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([1. for z in faceoffs if k['opp'] != (z['team_type'] == t) and k['faceoff_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]
                            
                        if 'free_position_quals' in k:
                            #print ("{:<20}{:<20}{:<20}{:<20}{:<20}".format(t, k['key'], ftr['filter'], ftr['filter_val'], sum([1. for z in fp_events if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['free_position_quals'](z)])))
                            stat_summaries_dict['%s_%s'% (t, k['key'])]['val'] = sum([1. for z in fp_events if k['opp'] != (z['team_type'] == t) and ftr['qual'](z) and k['free_position_quals'](z)])
                            for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                stat_summaries_dict['%s_%s_by_%s'% (t, k['key'], tmp[0])]['val'] = [sum([1. for z in fp_events if k['opp'] != (z['team_type'] == t) and k['free_position_quals'](z) and qual_period(z[tmp[0]], y)]) for y in range(tmp[1])]
                
                for tname in tn:
                    t_opp = 'away' if tname == "home" else "home"

                    for k in stat_summaries_keys:
                        if k['opp']:
                            t = t_opp
                        else:
                            t = tname

                        if 'formula' in k:
                            

                            if k['formula']['op'] == "divide":
                                stat_summaries_dict['%s_%s'% (tname, k['key'])]['val'] = None
                                if stat_summaries_dict['%s_%s'% (t, k['formula']['denom'])]['val'] != 0:
                                    stat_summaries_dict['%s_%s'% (tname, k['key'])]['val'] = stat_summaries_dict['%s_%s'% (t, k['formula']['num'])]['val']/stat_summaries_dict['%s_%s'% (t, k['formula']['denom'])]['val']

                                    stat_summaries_dict['%s_%s'% (tname, k['key'])]['log'] = "{:<40}{:>30}{:>10.2f}{:>15}{:>30}{:>10.2f}\n".format('%s_%s'% (tname, k['key']), '%s_%s'% (t, k['formula']['num']), stat_summaries_dict['%s_%s'% (t, k['formula']['num'])]['val'], "divide", '%s_%s'% (t, k['formula']['denom']), stat_summaries_dict['%s_%s'% (t, k['formula']['denom'])]['val'])
                                for tmp in [('half', 2), ('quarter', 10), ('split', 2), ('stretch', 2)]:
                                        num_list = stat_summaries_dict['%s_%s_by_%s'% (t, k['formula']['num'], tmp[0])]['val']
                                        denom_list = stat_summaries_dict['%s_%s_by_%s'% (t, k['formula']['denom'], tmp[0])]['val']
                                        for i, (num, denom) in enumerate(zip(num_list, denom_list)):
                                            stat_summaries_dict['%s_%s_by_%s'% (tname, k['key'], tmp[0])]['val'][i] = 0.
                                            if denom != 0:
                                                stat_summaries_dict['%s_%s_by_%s'% (tname, k['key'], tmp[0])]['val'][i] = num/denom

            if show_cgd_timedstamps:
                print("     {:<95}{:<15}".format("Done database table update...", datetime.now().strftime("%H:%M:%S")));
                    
        if '--test-TGS-FP' in sys.argv:
            zc.print_dict(stat_summaries_dict['home_fp_attempts'])
            zc.print_dict(stat_summaries_dict['home_fp_goals'])
            zc.print_dict(stat_summaries_dict['home_fp_shots'])
            zc.print_dict(stat_summaries_dict['home_fp_shots_off_one_pass'])
            zc.print_dict(stat_summaries_dict['home_fp_efficiency'])
            zc.print_dict(stat_summaries_dict['home_fp_utilization'])
            zc.print_dict(stat_summaries_dict['home_fp_shooting_pct'])
            zc.print_dict(stat_summaries_dict['home_fp_shooter_pct'])
            #zc.exit("DoneFP")
        
        if next_game_summary_ID is not None or game_log_IDs is not None and 'ID' in g and g['ID'] is not None:
            populate_team_summary_table(game_log_IDs, confirmed_home_team, confirmed_away_team, g, next_game_summary_ID, stat_summaries_with_filters)
            if show_cgd_timedstamps:
                print("     {:<95}{:<15}".format("Done populate_team_summary_table...", datetime.now().strftime("%H:%M:%S.%f")[0:-3]));
            
            steps.append({'step': 'Pop team summary table', 'time': time.time()})
        

        g_save = {'league': league, 'phils_law': phils_law, 'both_teams': "%s|%s" % (confirmed_home_team, confirmed_away_team), 'max_quarter': None if plays_list == [] else max([z['quarter'] for z in plays_list])+1 , 'plays': plays_list, 'elo_odds': elo, 'logs': logs, 'cur_pos': cur_pos, 'possessions': possessions, 'ID': game_ID, 'home_team': home_team, 'away_team': away_team, 'detail': game_details_save, 'stat_summaries': stat_summaries_dict}
        g_save['detail']['date'] = g_save['detail']['date'].strftime("%m-%d-%Y %H:%M:%S")
        game_json = json.dumps(g_save)
        steps.append({'step': 'Create summary dicts', 'time': time.time()})

        g = add_player_stats_to_game_dict(g)


        # Create LRP JSON object
        LRP_json['home_alt_team'] = home_team['alt_team']
        LRP_json['teams'] = [{'ID': away_ID, 'short_name': away_team['alt_team']}, {'ID': home_ID, 'short_name': home_team['alt_team']}]
        LRP_json['away_alt_team'] = away_team['alt_team']
        LRP_json['headline'] = "%s vs %s" % (home_team['alt_team'], away_team['alt_team'])
        LRP_json['headline_as_%d' % away_ID] = "vs %s" % home_team['alt_team']
        LRP_json['headline_as_%d' % home_ID] = "vs %s" % away_team['alt_team']
        if 'results' in LRP_json:
            LRP_json = LRP_add_basic_counting_team_comparison(LRP_json, g)
            LRP_json = LRP_add_basic_rate_team_comparison(LRP_json, g)
            LRP_json = LRP_add_team_summary_stats(LRP_json, g)
            LRP_json = LRP_add_wp_content(LRP_json, g, plays_list)
            LRP_json['results']['TopStars'] = g['player_summaries']

        if LRP_json is not None:

            f = open(LRP_json_path, 'w')
            f.write(json.dumps(LRP_json))
            f.close()

        if os.path.isdir(os.path.join(lr_fldr, "Logs", "GameJSONs")) and g['ID'] is not None:
            f = open(os.path.join(os.path.join(lr_fldr, "Logs", "GameJSONs"), "%d.json" % g['ID']), 'w')
            f.write(game_json)
            f.close()
            # Add game or update game in team game log file
            # away
            steps.append({'step': 'Print Game JSONs', 'time': time.time()})
        
        if os.path.isdir(os.path.join(lr_fldr, "Logs", "GameJSONs")) and g['ID'] is not None:
            f = open(os.path.join(os.path.join(lr_fldr, "Logs", "GameJSONs"), "%d.json" % g['ID']), 'w')
            f.write(game_json)
            f.close()
            for tmp in ['away', 'home']:
                opp = "home" if tmp == "away" else "away"

                if not os.path.isdir(os.path.join(lr_fldr, 'Teams', 'team%04d' % (g['%s_team' % tmp]['ID']))):
                    os.mkdir(os.path.join(lr_fldr, 'Teams', 'team%04d' % (g['%s_team' % tmp]['ID'])))
                if os.path.isdir(os.path.join(lr_fldr, 'Teams', 'team%04d' % (g['%s_team' % tmp]['ID']))):
                    path = os.path.join(lr_fldr, 'Teams', 'team%04d' % g['%s_team' % tmp]['ID'], '%dGameLog' % game_date.year)
                    games = []
                    game_rec = {'date': game_date.strftime("%Y-%m-%d"), 'opp_ID': g['%s_team' % opp]['ID'], 'opponent': g['%s_team' % opp]['confirmed_team']}
                    for k, v in zip(stat_summaries_dict.keys(), stat_summaries_dict.values()):
                        if (tmp in k or opp in k) and k not in ["sum_gbs", "bad_plays", "total_shots_variance", "attribution_class_cnts"] and "_by_" not in k:
                            game_rec[k.replace("%s_" % tmp, "").replace("%s_" % opp, "opp_")] = str(v)

                        if (tmp in k or opp in k) and k not in ["sum_gbs", "bad_plays", "total_shots_variance", "attribution_class_cnts"] and "_by_quarter" in k:
                            for l in range(4):
                                k_name = k.replace("%s_" % (tmp), "").replace("%s_" % opp, "opp_") + str(l)
                                game_rec[k_name] = str(v['val'][l])

                    games = []
                    if os.path.isfile(path):
                        tmp = open(path, 'r').read()
                        #print len(tmp)
                        if len(tmp) > 0:
                            games = json.loads(tmp)

                    for g_ in games:
                        if g_['date'] == game_rec['date']:
                            if g_ != game_rec:
                                for k, v in zip(game_rec.keys(), game_rec.values()):
                                    g_[k] = v

                    if game_rec['date'] not in [z['date'] for z in games]:
                        games.append(game_rec)


                    game_log = open(path, 'w'); game_log.write(json.dumps(games)); game_log.close()

            steps.append({'step': 'Update game logs', 'time': time.time()})
        g['success'] = 1 
        
    if 'recap' in settings:
        g = write_game_recap(g)
        steps.append({'step': 'Write recap', 'time': time.time()})
    #display_create_game_dict_timing(steps)
    g['errors'] = errors
    g['steps'] = steps
    return g
    
def record_processing_error(scriptname, error_msg, specs={}):
    """
    When a processing error occurs, this function is used to log the error in the LaxRef DB so that we can have a record of how often these issues are popping up, the better to figure out a permanent solution to them.
    """
    
    query = "INSERT INTO LaxRef_Processing_Errors (ID, datestamp, active, scriptname, error_msg) VALUES ((SELECT IFNULL(max(ID),0)+1 from LaxRef_Processing_Errors fds), %s, %s, %s, %s)"
    param = [datetime.now(), 1, scriptname, error_msg]
    
    zcursor = zc.zcursor("LR")
    zcursor.execute(query, param)
    zcursor.commit()
    zcursor.close()

def LRP_add_shots_content(LRP_json, g):
    LRP_json['results']['ShotsBreakdown'] = None
    if g['shots'] is None: return LRP_json
    
    res = {'teams': None}

    
    LRP_json['results']['ShotsBreakdown'] = res
    return LRP_json

def LRP_add_wp_content(LRP_json, g, plays_list):

    res = {'points': [], 'home_goals': None, 'away_goals': None, 'goals': [], 'away_ID': g['away_team']['ID'], 'home_ID': g['home_team']['ID'], 'winner_ID': None, 'y_is_home_odds': 1}
    if 'stat_summaries' in g:
        tmp = g['stat_summaries']
        try:
            res['home_goals'] = tmp['home_goals']['val']
            res['away_goals'] = tmp['away_goals']['val']
        except Exception:
            res['home_goals'] = tmp['home_goals']
            res['away_goals'] = tmp['away_goals']
        
    else:
        msg = "LRP_add_wp_content: In game ID %s, there is no stat_summaries object in the g game variable" % g['ID']
        zc.send_telegram(msg, bot_token)
    
    if res['home_goals'] is not None and res['home_goals'] > res['away_goals']:
        res['winner_ID'] = res['home_ID']
    elif res['home_goals'] is not None and res['away_goals'] > res['home_goals']:
        res['winner_ID'] = res['away_ID']
    
    for p in plays_list:
        pt = {'seq': len(res['points']) + 1, 'x': 100. * p['pct_complete'], 'y': p['home_odds'], 'play_summary': "%s %s" % (p['team'], p['play_type'])}
        res['points'].append(pt)
    LRP_json['results']['WinProbabilityChart'] = res
    
    return LRP_json

def LRP_add_team_summary_stats(LRP_json, g):
    """
    This function creates a 2-item list that contains the summary stats for the two teams that played in the game.
    """
    try:
        all_keys = g['stat_summaries'].keys()
        
        #print ("\n\n[" + ", ".join(['"%s"' % z.replace("home_", "") for z in sorted(all_keys) if 'home' in z and "_by_" not in z]) + "]\n\n"); sys.exit()
        
        
        tags = ['home', 'away']
        res = []
        
        keys_to_include = ["assist_rate", "assists", "avg_time_to_shot", "clear_rate", "def_efficiency", "faceoff_conversions", "faceoffs", "failed_clears", "fo_pct", "forced_turnovers", "fp_attempts", "fp_efficiency", "fp_goals", "fp_shooter_pct", "fp_shooting_pct", "fp_shots", "fp_shots_off_one_pass", "fp_utilization", "free_position_shot_taken", "gb_win_rate", "gbs", "goals", "man_down_goals", "man_up_chances", "man_up_goals", "off_efficiency", "on_keeper_shots", "player_cnt", "poss_plus_clears", "possession_margin", "possessions", "save_pct", "saved_shot_pct", "saved_shots", "saves", "shooting_pct", "shots", "shots_per_possession", "sog", "sog_rate", "sum_fo", "sum_gbs", "time_per_possession", "top", "total_possessions", "total_top", "turnover_rate", "turnovers", "unforced_turnovers"]
        
        for t in tags:
            d = {'team_type': t, 'team': g["%s_team" % t]['team'], 'team_ID': g["%s_team" % t]['ID']}
            for k in keys_to_include:
                d[k] = g['stat_summaries']["%s_%s" % (t, k)]['val']
                
            res.append(d)
        
        
        LRP_json['results']['team_summary_stats'] = res
    except Exception:
        
        LRP_json['results']['team_summary_stats'] = None
        
        if 'errors' not in LRP_json: LRP_json['errors'] = []
        LRP_json['errors'].append({'fn': 'LRP_add_team_summary_stats', 'error': traceback.format_exc()})
            
    return LRP_json

def LRP_add_basic_counting_team_comparison(LRP_json, g):

    res = [{'tag': 'shots', 'display': 'Shots'}, {'tag': 'sog', 'display': 'S.O.G.'}, {'tag': 'goals', 'display': 'Goals'}, {'tag': 'assists', 'display': 'Assists'}, {'tag': 'possessions', 'display': 'Possessions'}, {'tag': 'turnovers', 'display': 'Turnovers'}, {'tag': 'gbs', 'display': 'GBs'}, {'tag': 'faceoffs', 'display': 'Draw Controls' if "Women" in g['league'] else "Faceoff Wins"}, {'tag': 'saves', 'display': 'Saves'}, {'tag': 'top', 'display': 'T.O.P.', 'fmt': "{:.0f}%"}]
    #print sorted((g['stat_summaries'].keys()))
    for i, r in enumerate(res):
        if 'fmt' not in r: r['fmt'] = "{:.0f}"
        r['show'] = 1
        r['seq'] = i



        for tmp in ['home', 'away']:
            r['%s_val' % tmp] =  g['stat_summaries']['%s_%s' % (tmp, r['tag'])]['val']
            if r['%s_val' % tmp] is None: r['show'] = 0; break
            if "%" in r['fmt']:
                r['%s_val_str' % tmp] = r['fmt'].format(100. * r['%s_val' % tmp])
            else:
                r['%s_val_str' % tmp] = r['fmt'].format(r['%s_val' % tmp])

        if r['show']:
            r['total'] = (r['home_val'] + r['away_val'])
            r['pct'] = None if r['total'] in [None, 0] else (r['away_val']/r['total'])

    LRP_json['results']['BasicSummaryCounting'] = [z for z in res if z['show']]

    return LRP_json

def LRP_add_basic_rate_team_comparison(LRP_json, g):
    res = [{'tag': 'off_efficiency', 'display': 'Efficiency', 'fmt': "{:.1f}%"}, {'tag': 'turnover_rate', 'display': 'Turnover Rate', 'fmt': "{:.1f}%"}, {'tag': 'sog_rate', 'display': 'On-Goal Rate', 'fmt': "{:.1f}%"}, {'tag': 'shooting_pct', 'display': 'Shooting Pct', 'fmt': "{:.1f}%"}, {'tag': 'clear_rate', 'display': 'Clear Rate', 'fmt': "{:.0f}%"}, {'tag': 'time_per_possession', 'display': 'Time/Poss', 'fmt': "{:.1f}"}]
    #print sorted((g['stat_summaries'].keys()))
    for i, r in enumerate(res):
        if 'fmt' not in r: r['fmt'] = "{:.0f}"
        r['show'] = 1
        r['seq'] = i



        for tmp in ['home', 'away']:
            r['%s_val' % tmp] =  g['stat_summaries']['%s_%s' % (tmp, r['tag'])]['val']
            if r['%s_val' % tmp] is None: r['show'] = 0; break
            if "%" in r['fmt']:
                r['%s_val_str' % tmp] = r['fmt'].format(100. * r['%s_val' % tmp])
            else:
                r['%s_val_str' % tmp] = r['fmt'].format(r['%s_val' % tmp])
        if r['show']:
            for tmp in ['home', 'away']:
                r['%s_pct' % tmp] = None if max(r['%s_val' % "home"], r['%s_val' % "away"]) == 0 else  r['%s_val' % tmp]/max(r['%s_val' % "home"], r['%s_val' % "away"])

    LRP_json['results']['BasicSummaryRate'] = [z for z in res if z['show']]

    return LRP_json

def display_create_game_dict_timing(steps):
    #zc.print_dict(steps)
    for i, s in enumerate(steps):
        if i > 0:
            s['start'] = steps[i-1]['time']
            s['elapsed'] = s['time'] - s['start']
    tot = sum([z['elapsed'] for z in steps[1:]])
    for i, s in enumerate(steps):
        if i > 0:
            s['pct'] = s['elapsed'] / tot
    steps = sorted(steps[1:], key=lambda x:x['elapsed'], reverse=True)
    print ("\n{:<50}{:>10}{:>10}".format("Step", "Elapsed", "Pct") + "\n" + "-" * 70)
    print ("\n".join(["{:<50}{:>10.3f}{:>9.1f}%".format(z['step'],z['elapsed'], 100.*z['pct']) for z in steps]))
    print ("-" * 70)
    print ("{:<50}{:>10.3f}\n".format("Total", tot))
